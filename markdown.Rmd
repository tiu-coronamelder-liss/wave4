---
title: ""
author: "Dr. ir. L.N. van der Laan, N.E. van der Waal, MSc, J.M.S. de Wit, PDEng"
date: ""
output: 
  bookdown::word_document2:
    toc: true
    toc_depth: 3
    reference_docx: markdown_template.docx
toc-title: "Inhoudsopgave"    
---
```{r setup, include=FALSE}
rm(list = ls()) #Clear workspace
knitr::opts_chunk$set(echo = TRUE)

# Disable output of warnings to the generated doc file
# Set to FALSE for final doc, TRUE for debugging
knitr::opts_chunk$set(warning = FALSE)

##### Load packages
# For importing SPSS files
library(foreign)


# For filtering
library(plyr)
library(dplyr)

# For tables
library(flextable)
library(arsenal)

# Various plotting 
library(ggplot2)
library(tidyr)
library(forcats)
library(scales)
library(RColorBrewer)
library(cowplot) # for aligning ggplots vertically

# For analysis and data preprocessing
library(psy) # psy for the cronbach function
library(reshape2) # For converting from wide to long format (function: melt)
library(rcompanion) # For the posthoc chi square tests

# For the visualization over time
library(ggrepel)

# Other
library(labelled)

################ Settings and variables for plotting, images, etc. #######################
### Set up color palettes for graphs
my_palette5 <- brewer.pal(11,"RdYlGn")[c(4, 5, 6, 7, 8, 9, 10)]
my_palette7 <- brewer.pal(11,"RdYlGn")[c(9,8,7,6,5,4,3)]
my_palette_nonuse = c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "RdYlGn")[c(9,8,7,6,5,4,3)])
my_palette5true <- c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "RdYlGn")[c(6,7,8,9)])
my_palette5blue <- c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "Blues")[c(6,5,4,3)])
my_palette7blue <- brewer.pal(11, "Blues")[c(7,6,5,4,3,2,1)]
my_palette8blue <- c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "Blues")[c(7,6,5,4,3,2,1)])

################ Set up data preprocessing and analysis #############################
##### Load dataset (not included on Github)
data_in <- read.spss('L_Corona_app_wave4_3p.sav', to.data.frame=TRUE, use.missings=FALSE)

# Filter out the respondents that did not complete the entire survey (N = 10)
data <- data_in[!is.na(data_in$duur),]

##### Preprocessing and cleaning up variables
### Drop unused levels from some particular factors. The reason to do this is that there are levels in the dataset that were not included in the current sample (for instance participants of child age are present in the LISS panel but not in the representative sample of Dutch inhabitants that was included for this study)
data$lftdcat = droplevels(data$lftdcat)
data$belbezig = droplevels(data$belbezig)

### Combine some variable levels in order to have sufficient counts in cells for demographics
# For demographic variable stedelijkheid. 
data$sted_simplified = data$sted
levels(data$sted_simplified) <- c(levels(data$sted_simplified),"Onbekend") # Add the new level that will contain the merged levels
data$sted_simplified[is.na(data$sted)] <- "Onbekend"
data$sted_simplified = factor(data$sted_simplified)

# For demographic variable oplmet. 
data$oplmet_simplified = data$oplmet
data$oplmet_simplified[data$oplmet == "anders" | data$oplmet == "(Nog) geen onderwijs afgerond" | data$oplmet == "Volgt nog geen onderwijs"] <- "anders"
data$oplmet_simplified = factor(data$oplmet_simplified)

# For demographic variable belbezig. 
data$belbezig_simplified = data$belbezig
levels(data$belbezig_simplified) <- c(levels(data$belbezig_simplified),"Anders") # Add the new level that will contain the merged levels
data$belbezig_simplified[data$belbezig == "Werkt of is meewerkend in gezins- of familiebedrijf" | data$belbezig == "Zoekt voor het eerst werk" | data$belbezig == "Zoekt werk na verlies werkkring" | data$belbezig == "Verricht onbetaald werk met behoud van uitkering" | data$belbezig == "Verricht vrijwilligerswerk" | data$belbezig == "Vrijgesteld van werkzoeken na verlies van werkkring" |data$belbezig == "Doet iets anders"] <- "Anders"
data$belbezig_simplified = factor(data$belbezig_simplified)
#View(data[,c("belbezig","belbezig_simplified")])

# For demographic variable burgstat. Add the people that are "Gescheiden van tafel en bed" to the "Gescheiden categorie"
data$burgstat_simplified = data$burgstat
data$burgstat_simplified[data$burgstat == "Gescheiden van tafel en bed"] <- "Gescheiden"
data$burgstat_simplified = factor(data$burgstat_simplified)

# For demographic variable nettocat. Make category with 3501 euro or higher and unknown ("weet ik niet" en "wil niet zeggen" en NMISS) 
data$nettocat_simplified = data$nettocat
levels(data$nettocat_simplified) <- c(levels(data$nettocat_simplified),"Meer dan EUR 3501", "Onbekend") # Add the new level that will contain the merged levels
data$nettocat_simplified[data$nettocat == "Dat weet ik echt niet" | data$nettocat == "Dat wil ik niet zeggen" | is.na(data$nettocat)] <- "Onbekend"
data$nettocat_simplified[data$nettocat == "EUR 3501 t/m EUR 4000" | data$nettocat == "EUR 4001 t/m EUR 4500" | data$nettocat == "EUR 4501 t/m EUR 5000" | data$nettocat == "EUR 5001 t/m EUR 7500" | data$nettocat == "Meer dan EUR 7500"] <- "Meer dan EUR 3501"
data$nettocat_simplified = factor(data$nettocat_simplified)

### Add labels to variables of main dataset
attr(data$geslacht,'label')  <- 'Geslacht'
attr(data$lftdcat,'label')  <- 'Leeftijdscategorie'
attr(data$sted_simplified,'label')  <- 'Stedelijkheid woonplaats'
attr(data$belbezig_simplified,'label')  <- 'Belangrijkste bezigheid'
attr(data$nettocat_simplified,'label')  <- 'Netto maandinkomen'
attr(data$oplmet_simplified,'label')  <- 'Hoogste opleiding met diploma'
attr(data$burgstat_simplified,'label')  <- 'Burgerlijke staat'
attr(data$woonvorm,'label')  <- 'Woonvorm huishouden'

### Rename unclear levels (this is the LISS category label but only 17 and older are included in current sample)
levels(data$lftdcat)[levels(data$lftdcat)=="15 - 24 jaar"] <- "17 - 24 jaar"

##### Creating new variables
### User status. 
# Of interest is the comparison of current users and current non users.  
data$user_status[data$Behavior_UTAUT == "Ik gebruik de CoronaMelder app op dit moment"] <- "Gebruiker"
data$user_status[data$Behavior_UTAUT == "Ik heb de CoronaMelder app nooit gebruikt"] <- "Niet gebruiker"
data$user_status[data$Behavior_UTAUT == "Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer"] <- "Voormalig gebruiker"

# Add factor
data$user_status <- factor(data$user_status,levels = c("Gebruiker", "Niet gebruiker", "Voormalig gebruiker"))

### User status and intention. 
# Of interest is the comparison of current users and the non users that are neutral when it comes to intention.  
data$user_status_intention[data$Behavior_UTAUT == "Ik gebruik de CoronaMelder app op dit moment"] <- "Gebruiker"
data$user_status_intention[(data$Behavior_UTAUT == "Ik heb de CoronaMelder app nooit gebruikt") & (data$BI1a_UTAUT == 'Helemaal mee oneens'| data$BI1a_UTAUT == 'Oneens'| data$BI1a_UTAUT == 'Een beetje oneens')] <- "Nooit gebruikt en niet van plan"
data$user_status_intention[(data$Behavior_UTAUT == "Ik heb de CoronaMelder app nooit gebruikt") & (data$BI1a_UTAUT == 'Neutraal')] <- "Nooit gebruikt en neutraal"
data$user_status_intention[(data$Behavior_UTAUT == "Ik heb de CoronaMelder app nooit gebruikt") & (data$BI1a_UTAUT == 'Helemaal mee eens'| data$BI1a_UTAUT == 'Mee eens'| data$BI1a_UTAUT == 'Een beetje mee eens')] <- "Nooit gebruikt en wel van plan"
data$user_status_intention[data$Behavior_UTAUT == "Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer"] <- "Voormalig gebruiker"
#View(data[,c("Behavior_UTAUT","BI1a_UTAUT","user_status_intention")])

# Add factor
data$user_status_intention <- factor(data$user_status_intention,levels = c("Gebruiker", "Nooit gebruikt en niet van plan", "Nooit gebruikt en neutraal", "Nooit gebruikt en wel van plan", "Voormalig gebruiker"))

##### Create new datasets
### Create a dataset with only the current users and never users for all analyses in which these groups are compared. 
data_currentvsneveruser = data[ which(data$user_status=='Gebruiker' | data$user_status=='Niet gebruiker'), ]
# Drop unused levels
data_currentvsneveruser$user_status = droplevels(data_currentvsneveruser$user_status)
# Add labels to variables
attr(data_currentvsneveruser$geslacht,'label')  <- 'Geslacht'
attr(data_currentvsneveruser$lftdcat,'label')  <- 'Leeftijdscategorie'
attr(data_currentvsneveruser$sted_simplified,'label')  <- 'Stedelijkheid woonplaats'
attr(data_currentvsneveruser$belbezig_simplified,'label')  <- 'Belangrijkste bezigheid'
attr(data_currentvsneveruser$nettocat_simplified,'label')  <- 'Netto maandinkomen'
attr(data_currentvsneveruser$oplmet_simplified,'label')  <- 'Hoogste opleiding met diploma'
attr(data_currentvsneveruser$burgstat_simplified,'label')  <- 'Burgerlijke staat'
attr(data_currentvsneveruser$woonvorm,'label')  <- 'Woonvorm huishouden'

# Rename unclear levels (this is the LISS category label but only 17 and older are included in current sample)
levels(data_currentvsneveruser$lftdcat)[levels(data_currentvsneveruser$lftdcat)=="15 - 24 jaar"] <- "17 - 24 jaar"

### Create a dataset with only the current users and never users that are neutral on intention for all analyses in which these groups are compared. 
data_currentvsneveruserneutral = data[ which(data$user_status_intention=='Gebruiker' | data$user_status_intention=='Nooit gebruikt en neutraal'), ]
# Drop unused levels
data_currentvsneveruserneutral$user_status_intention = droplevels(data_currentvsneveruserneutral$user_status_intention)
# Add labels to variables
attr(data_currentvsneveruserneutral$geslacht,'label')  <- 'Geslacht'
attr(data_currentvsneveruserneutral$lftdcat,'label')  <- 'Leeftijdscategorie'
attr(data_currentvsneveruserneutral$sted,'label')  <- 'Stedelijkheid woonplaats'
attr(data_currentvsneveruserneutral$belbezig_simplified,'label')  <- 'Belangrijkste bezigheid'
attr(data_currentvsneveruserneutral$nettocat_simplified,'label')  <- 'Netto maandinkomen'
attr(data_currentvsneveruserneutral$oplmet_simplified,'label')  <- 'Hoogste opleiding met diploma'
attr(data_currentvsneveruserneutral$burgstat_simplified,'label')  <- 'Burgerlijke staat'
attr(data_currentvsneveruserneutral$woonvorm,'label')  <- 'Woonvorm huishouden'

##### Calculate size of user subgroups
# Lookup table for totals of different user groups
usergroup_names = c("users", "former_users", "nonusers", "nonusers_no_intention", "nonusers_neutral", "nonusers_intention")

usergroup_labels = c("Gebruikers", "Voormalig gebruikers", "Niet gebruikers", "Niet gebruikers - niet van plan om te gaan gebruiken", "Niet gebruikers - neutraal", "Niet gebruikers - wel van plan om te gaan gebruiken")

# Create dataframe for totals of each user group
user_totals <- data.frame(matrix(ncol = length(usergroup_names), nrow = 1))
colnames(user_totals) <- usergroup_names

# Current user
user_totals[1] <- sum(data$user_status == "Gebruiker")

# Former user
user_totals[2] <- sum(data$user_status == "Voormalig gebruiker")

# Non user
user_totals[3] <- sum(data$user_status == "Niet gebruiker")

# Non user -- not planning to use
user_totals[4] <- sum(data$user_status_intention == "Nooit gebruikt en niet van plan")

# Non user -- neutral
user_totals[5] <- sum(data$user_status_intention == "Nooit gebruikt en neutraal")

# Non user -- planning to use
user_totals[6] <- sum(data$user_status_intention == "Nooit gebruikt en wel van plan")

######### Set up data preprocessing and analysis for comparison with earlier waves ####################
##### Load dataset of previous wave (not included on Github) and remove missing values
data_wave_min1_in <- read.spss('L_Corona_app_wave3_3p.sav', to.data.frame=TRUE, use.missings=FALSE)
# Filter out the respondents that did not complete the entire survey 
data_wave_min1 <- data_wave_min1_in[!is.na(data_wave_min1_in$duur),]

# Combine the dataset of the current wave (wave 2) with the previous wave (wave1). Only keep participants that completed both waves. 
data_currentwave_wavemin1 = merge(data_wave_min1, data, by = "nomem_encr", all = FALSE, suffix = c("_wmin1", "_cw")) # all = FALSE to only include IDs present in both datasets.

# Make variable for user status. Current wave.
data_currentwave_wavemin1$user_status_intention_cw[data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik gebruik de CoronaMelder app op dit moment"] <- "Gebruiker - huidige meting"
data_currentwave_wavemin1$user_status_intention_cw[(data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik heb de CoronaMelder app nooit gebruikt") & (data_currentwave_wavemin1$BI1a_UTAUT_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$BI1a_UTAUT_cw == 'Oneens'| data_currentwave_wavemin1$BI1a_UTAUT_cw == 'Een beetje oneens')] <- "Nooit gebruikt en niet van plan - huidige meting"
data_currentwave_wavemin1$user_status_intention_cw[(data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik heb de CoronaMelder app nooit gebruikt") & (data_currentwave_wavemin1$BI1a_UTAUT_cw == 'Neutraal')] <- "Nooit gebruikt en neutraal - huidige meting"
data_currentwave_wavemin1$user_status_intention_cw[(data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik heb de CoronaMelder app nooit gebruikt") & (data_currentwave_wavemin1$BI1a_UTAUT_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$BI1a_UTAUT_cw == 'Mee eens'| data_currentwave_wavemin1$BI1a_UTAUT_cw == 'Een beetje mee eens')] <- "Nooit gebruikt en wel van plan - huidige meting"
data_currentwave_wavemin1$user_status_intention_cw[data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer"] <- "Voormalig gebruiker - huidige meting"

# Previous wave
data_currentwave_wavemin1$user_status_intention_wmin1[data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik gebruik de CoronaMelder app op dit moment"] <- "Gebruiker - vorige meting"
data_currentwave_wavemin1$user_status_intention_wmin1[(data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik heb de CoronaMelder app nooit gebruikt") & (data_currentwave_wavemin1$BI1a_UTAUT_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$BI1a_UTAUT_wmin1 == 'Oneens'| data_currentwave_wavemin1$BI1a_UTAUT_wmin1 == 'Een beetje oneens')] <- "Nooit gebruikt en niet van plan - vorige meting"
data_currentwave_wavemin1$user_status_intention_wmin1[(data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik heb de CoronaMelder app nooit gebruikt") & (data_currentwave_wavemin1$BI1a_UTAUT_wmin1 == 'Neutraal')] <- "Nooit gebruikt en neutraal - vorige meting"
data_currentwave_wavemin1$user_status_intention_wmin1[(data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik heb de CoronaMelder app nooit gebruikt") & (data_currentwave_wavemin1$BI1a_UTAUT_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$BI1a_UTAUT_wmin1 == 'Mee eens'| data_currentwave_wavemin1$BI1a_UTAUT_wmin1 == 'Een beetje mee eens')] <- "Nooit gebruikt en wel van plan - vorige meting"
data_currentwave_wavemin1$user_status_intention_wmin1[data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer"] <- "Voormalig gebruiker - vorige meting"

##### Load dataset of all previous waves (not included on Github) and remove missing values
##### (Note: I am re-loading also what is above known as data and data_wave_min1 just to completely separate this process from the others)
##### (Note2: We have to see how easy it is to merge more than two dataframes for wave 3, for inspiration: https://stackoverflow.com/questions/15291613/merge-3-data-frames-by-column-names)

##### Wave 1
data_wave1_in <- read.spss('L_CoronaMelder_wave1_3p.sav', to.data.frame=TRUE, use.missings=FALSE)
# Filter out the respondents that did not complete the entire survey 
data_wave1 <- data_wave1_in[!is.na(data_wave1_in$duur),]

##### Wave 2
data_wave2_in <- read.spss('L_Corona_app_wave2_3p.sav', to.data.frame=TRUE, use.missings=FALSE)
# Filter out the respondents that did not complete the entire survey 
data_wave2 <- data_wave2_in[!is.na(data_wave2_in$duur),]

##### Wave 3
data_wave3_in <- read.spss('L_Corona_app_wave3_3p.sav', to.data.frame=TRUE, use.missings=FALSE)
# Filter out the respondents that did not complete the entire survey 
data_wave3 <- data_wave3_in[!is.na(data_wave3_in$duur),]

##### Wave 4
data_wave4_in <- read.spss('L_Corona_app_wave4_3p.sav', to.data.frame=TRUE, use.missings=FALSE)
# Filter out the respondents that did not complete the entire survey 
data_wave4 <- data_wave4_in[!is.na(data_wave4_in$duur),]

# Combine the dataset of all waves. Only keep participants that completed both waves. 
# all = FALSE to only include IDs present in both datasets.
# data_allwaves1 = merge(data_wave1, data_wave2, by = "nomem_encr", all = FALSE, suffix = c("_w1", "_w2")) %>% merge(data_wave3, by = "nomem_encr", all = FALSE, suffix = c("_w3")) # This method of merging does not add the _w3 suffix

# New method of merging to add all suffixes correctly.
data_tmp = merge(data_wave1, data_wave4, by = "nomem_encr", all = FALSE, suffix = c("_w1", "_w4"))
data_tmp2 = merge(data_wave2, data_wave4, by = "nomem_encr", all = FALSE, suffix = c("_w2", "_w4")) 
data_allwaves = merge(data_wave3, data_wave4, by = "nomem_encr", all = FALSE, suffix = c("_w3", "_w4"))
data_allwaves <- cbind(data_allwaves, select(data_tmp, contains("_w1")))
data_allwaves <- cbind(data_allwaves, select(data_tmp2, contains("_w2")))


```
```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```
# Samenvatting {.unlisted .unnumbered}
## Inleiding {.unlisted .unnumbered}
De CoronaMelder app is ontwikkeld door het ministerie van Volksgezondheid, Welzijn en Sport en wordt nu landelijk gebruikt in de strijd tegen het coronavirus. Het doel van dit onderzoek is om de adoptie van de CoronaMelder app en de (intentie tot) opvolging van de in de app gegeven adviezen te onderzoeken en te verklaren.  

## Methode {.unlisted .unnumbered}
In het kader van de evaluatie van de CoronaMelder wordt er een longitudinaal vragenlijstonderzoek uitgevoerd via het LISS panel. De datacollectie (wave 4) van deze rapportage vond plaats tussen 15 maart 2021 en 28 maart 2021, 5 maanden na de landelijke lancering op 10 oktober 2020. Aan dit onderzoek hebben `r nrow(data)` respondenten deelgenomen (gemiddelde leeftijd in jaren: `r round(mean(data$leeftijd), digits = 1)`, standaarddeviatie: `r round(sd(data$leeftijd), digits = 1)`; `r round((nrow(filter(data, geslacht == 'Vrouw'))/nrow(data))*100, digits = 1)`% vrouw).   

## Resultaten {.unlisted .unnumbered}  
**Adoptie** Iets meer dan 3 op de 10 van de deelnemers gebruiken de CoronaMelder. Van de huidige gebruikers heeft nog steeds het overgrote merendeel de intentie om de CoronaMelder de komende 2 maanden te blijven gebruiken. Nog minder dan 1 op de 20 respondenten die de CoronaMelder nog niet gebruiken, had de intentie om de CoronaMelder te gaan gebruiken en 12.1% staat hier nog neutraal in. Er waren verschillen in gebruikersstatus op basis van demografie: zo gebruiken lager opgeleiden en respondenten met een lager inkomen de CoronaMelder minder vaak.   

**Verklarende factoren voor adoptie**
Verschillende persoonlijke, sociale en omgevingsfactoren die samenhangen met het gebruik van de CoronaMelder zijn geïdentificeerd. De *risicoperceptie* verschilt net als in de vorige metingen tussen gebruikers en niet gebruikers: mensen die de CoronaMelder niet gebruiken schatten de ernst en de vatbaarheid voor het coronavirus lager in dan degenen die hem al wel gebruiken. Vergeleken met de vorige wave wordt het risico op een besmetting en de ernst hiervan nu iets lager ingeschat. De *gebruiksvriendelijkheid* is over het algemeen goed: van de gebruikers geeft het overgrote deel aan dat de CoronaMelder makkelijk te gebruiken is en dat gebruik weinig tijd en energie kost. Bij niet gebruikers blijft deze verwachting echter iets minder positief; dit blijft daarom ook een aandachtspunt. Na eerdere toenames (tussen wave 1 en 2) is met betrekking tot de *technologie gerelateerde belemmeringen* is de situatie nu stabiel: niet gebruikers geven nog steeds minder vaker aan dat zij een telefoon tot de beschikking te hebben waarmee de CoronaMelder kan worden gebruikt en dat zij genoeg technische kennis hebben om de CoronaMelder te gebruiken. Over het algemeen is het vertrouwen in de *adequaatheid van de techniek* (bluetooth) om aan te duiden wie er in de buurt is geweest stabiel hoog in de hele sample. De niet gebruikers hebben echter nog steeds een (veel) lagere verwachting van de *effectiviteit* van de CoronaMelder in de bijdrage aan het bestrijden van het coronavirus. Over de tijd is te zien dat de verwachte effectiviteit varieert maar ten opzichte van de eerste meting 1.5 week (53.4% eens) na de lancering is er een daling te zien (huidige meting 46.6%). Nog steeds denkt de grootste groep dat een adoptie van meer dan 50% nodig is voor de CoronaMelder om effectief te zijn. De mate waarin men denkt dat de CoronaMelder de Nederlandse economie helpt is niet significant afgenomen. Met betrekking tot *privacy* is een opvallende bevinding dat nog steeds een substantieel deel van de gebruikers en (in ernstiger mate) de niet gebruikers (onterecht) denkt dat de CoronaMelder de locatie en persoonsgegevens bijhoudt. Wel denkt een grote meerderheid nog steeds dat de informatie uit de app vertrouwelijk wordt behandeld, hoewel dit percentage wel weer lager is bij de niet gebruikers en dit percentage in de hele sample ten opzichte van de vorige meting licht is gedaald. Gezien de substantiële rol van zorgen over privacy in technologie adoptie is dit een belangrijk aandachtspunt. Opvallend is ook nog steeds dat niet gebruikers vaker aangeven dat door het gebruik van de CoronaMelder technologische bedrijven meer macht krijgen en dat de overheid meer controle over de bevolking krijgt. Ook is nog steeds duidelijk dat niet gebruikers vaker *algemene mispercepties* hebben met betrekking tot het coronavirus, bijvoorbeeld dat het een biologisch wapen is of samenhangt met 5G. Daarnaast staat nog steeds 15.7% van de niet gebruikers *angstig* staat tegenover de CoronaMelder, terwijl dit bij de gebruikers een zeer klein percentage is. Niet gebruikers hebben over het algemeen nog steeds een lager *vertrouwen in de overheidsaanpak* tegen het coronavirus. De *sociale invloeden* omtrent het gebruik van de CoronaMelder zijn nog steeds niet erg gunstig. Een relatief laag percentage denkt dat mensen in hun directe omgeving de CoronaMelder gebruiken of gebruik op prijs zouden stellen. Een substantieel deel staat hier nog steeds neutraal in. Een verklaring hiervoor is dat het gebruik van de CoronaMelder redelijk onzichtbaar is vergeleken met andere preventieve gedragingen en de bevindingen zouden ook kunnen suggereren dat de CoronaMelder in de sociale interacties simpelweg niet besproken wordt. *Media* Nog 7 op de 10 respondenten geven aan de CoronaMelder in de media voorbij te hebben zien komen in de afgelopen maand. Dit is minder dan in de vorige meting en de meting in december waarin dit nog vier op de vijf was. Wel beoordeelden 35.1% de toon van de berichtgeving overwegend positief en 10.8% als overwegend negatief; de rest wist het niet of vond de toon neutraal. *Verplichting tot gebruik* Nog ongeveer zes op de tien mensen die de CoronaMelder op dit moment gebruiken aan het in meer of mindere mate eens te zijn met de stelling dat men zich verplicht voelt hem te gebruiken. Van de mensen die de CoronaMelder niet gebruiken is dat slechts 3.3%. Dit percentage is over de hele groep afgenomen ten opzichte van de vorige meing. De niet gebruikers geven vaker aan dat het aandringen op het gebruik van de CoronaMelder leidt tot boosheid or irritatie. Het merendeel (86.8%) van de respondenten die aangeven zich verplicht te voelen tot gebruik van de CoronaMelder geeft aan dat het gebruiken van de CoronaMelder wordt gezien als maatschappelijke verplichting. Een lager percentage geeft aan het in meer of mindere mate eens te zijn dat de werkgever/opdrachtgever (7.9%), de school/opleiding (9.4%) of de overheid (11.6%) de respondent verplicht om de CoronaMelder te gebruiken.     
*Verklarende modellen voor adoptie* Uit de verklarende modellen voor adoptie kwamen als belangrijkste factoren er uit de verwachte effectiviteit, de gebruiksvriendelijkheid, sociale factoren, voor- en nadelen van gebruik en overtuigingen met betrekking tot privacy, angst en maatchappelijke aspecten (goed burgerschap, bijdrage aan economie).  

**Intentie tot adherentie aan gedragsadviezen in de melding** Vanwege het lage aantal ontvangen meldingen in de meetperiode zijn de getallen voor daadwerkelijk gerapporteerd gedrag minder betrouwbaar. In lijn met eerder onderzoek leken deze cijfers wel te suggereren dat er een discrepantie zit tussen de intenties en het gedrag: de helft van de deelnemers die een of meerdere meldingen had ontvangen gaf aan een coronatest te hebben aangevraagd en zeven op de tien gaf aan vaak, meestal of altijd zo lang thuis te zijn gebleven als de melding adviseert. Over het algemeen zijn de intenties van de gebruikers voor het opvolgen van de in de melding voorgestelde adviezen echter juist zeer goed (rond of zelfs hoger dan 90%), met name indien de gebruiker daarnaast ook (hypothetisch) symptomen heeft die bij het coronavirus passen. Er zijn weinig verschuivingen ten opzichte van de vorige meting te zien. Wel is de intentie tot testen na een melding indien men geen symptomen heeft, toegenomen naar 78.8%. Er was een zeer lichte stijging in het percentage respondenten dat aan gaf dat het advies uit de melding hem/haar irriteert of boos maak. 

Na een afnames in de vorige wave, zijn de gepercipieerde persoonlijke voordelen van het opvolgen van de adviezen (testen, thuisblijven, geen bezoek ontvangen) grotendeels onveranderd. Alleen voor thuisblijven zolang de melding adviseert is het percentage dat hier voordelen in ziet licht gedaald. De persoonlijke nadelen de opvolging van de adviezen zijn stabiel gebleven. Ook is de zelfeffectiviteit voor deze adviezen grotendeels onveranderd, met enkel weer een zeer lichte afname voor thuisblijven. De zelfeffectiviteit hing in de verklarende modellen significant samen met de intentie tot trouw aan de adviezen. 

**Doorgeven GGD-sleutel bij positieve test** Een overgroot deel van de gebruikers van de CoronaMelder gaf nog steeds aan de GGD sleutel door te gaan geven als men positief getest wordt op het coronavirus. Voor de effectiviteit van de CoronaMelder is het wel van belang dat deze intentie omgezet wordt in daadwerkelijk gedrag.

**Onbeoogde effecten: schijnveiligheid** De overgrote meerderheid gelooft niet dat de andere maatregelen niet meer in acht hoeven te worden genomen wanneer men CoronaMelder geïnstalleerd heeft. Wel geven meer drie op de tien respondenten aan dat de stelling *Als ik de CoronaMelder gebruik, verlaag ik mijn risico op een besmetting met het coronavirus*, misschien waar of zeker waar is. Tegelijkertijd zijn er nog steeds geen aanwijzingen dat de gebruikers zich minder aan de algemene maatregelen houden. Zo verschillen gebruikers en niet gebruikers niet of marginaal in hun zelfgerapporteerde gedrag en hebben gebruikers juist vaker de intentie om zich aan de maatregelen te houden dan niet gebruikers. Wel blijft dit een belangrijk punt van aandacht. 


*Voor aanbevelingen en conclusies verwijzen we u graag naar hoofdstuk 4*

```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```


# Achtergrond
De CoronaMelder app is ontwikkeld door het ministerie van Volksgezondheid, Welzijn en Sport en wordt nu landelijk gebruikt in de strijd tegen het coronavirus. Het doel van dit onderzoek is om, over de tijd, de adoptie van de app en de (intentie tot) opvolging van de in de app gegeven adviezen te onderzoeken en te verklaren.

# Methoden  

## Onderzoeksopzet  

In het kader van de evaluatie van de CoronaMelder wordt er een longitudinaal vragenlijstonderzoek uitgevoerd via het LISS panel (LISSdata.nl) waarbij er over een periode van 5 maanden 4 metingen plaatsvinden. Het doel van dit onderzoek is om, over de tijd, de adoptie van de app en de (intentie tot) opvolging van de in de app gegeven adviezen te onderzoeken en te verklaren. Meer specifiek gaan we in dit longitudinale onderzoek in op de volgende onderzoeksvragen:
  
Onderzoeksvraag 1: Wat is de temporele dynamiek van de adoptie van digitale contracttracering in de Nederlandse bevolking en welke factoren (persoonlijk, sociaal, omgevingsfactoren) hebben hierop betrekking? 
  
Onderzoeksvraag 2: Wat is de temporele dynamiek van de intentie om zich te houden aan de adviezen die worden gecommuniceerd in de digitale contacttracing app CoronaMelder en welke factoren (persoonlijk, sociaal, omgeving, app-gerelateerd) zijn hierop van invloed? 

De huidige rapportage beslaat de data van de vierde meting. Ook wordt een vergelijking met de derde meting getoond. De datacollectie (wave 4) van deze rapportage vond plaats tussen 15 maart en 28 maart 2021, 5 maanden na de landelijke lancering op 10 oktober 2020.  

De (8 minuten durende) vragenlijst bevat op elk meetmoment de volgende onderwerpen:   
- Gebruiksgedrag van CoronaMelder  
- Technologische factoren die zijn afgeleid van de Unified Theory of Acceptance and Use of Techology (UTAUT): prestatieverwachting, inspanningsverwachting, sociale invloed en gedragsintentie. 
- COVID-19 en CoronaMelder-gerelateerde percepties en overtuigingen  
- Overtuigingen over de voordelen en de persoonlijke/maatschappelijke waarde van de CoronaMelder  
- Misvattingen over het coronavirus en CoronaMelder  
- Persoonlijke, sociale en omgevingsfactoren   
- Preventief gedrag / naleving van adviezen en factoren die zijn afgeleid van het Health Belief Model (HBM): preventief gedrag (afgelopen week en intentie), waargenomen ernst en vatbaarheid, persoonlijke voordelen en barrières, zelfredzaamheid  

Sommige items zijn aan verandering onderhevig, bijvoorbeeld items over misvattingen over de app of het coronavirus zullen gebaseerd zijn op de meest recente ontwikkelingen en actuele gebeurtenissen in de media. In de bijlage kan de vragenlijst van wave 4 gevonden worden. 

## Beschrijving panel
Het LISS panel is bij uitstek geschikt voor onderzoek waarbij een goede vertegenwoordiging van de Nederlandse bevolking van groot belang is. Het LISS panel is een probability-based (geen zelfselectie) panel dat iedere maand vragenlijsten invult via internet. De adressensteekproeven voor de werving en de bijwervingen zijn getrokken uit het populatieregister in samenwerking met het CBS. Indien een huishouden niet beschikt over een breedbandverbinding en/of computer, dan stelt CentERdata de benodigde apparatuur in bruikleen beschikbaar om alsnog mee te kunnen doen aan het panel. Hiermee onderscheidt het LISS panel zich van andere online panels, waar niet-internetters ontbreken en waar panelleden de gelegenheid hebben om zichzelf aan te melden.  

Panelleden ontvangen € 7,50 voor een vragenlijst met een invultijd van dertig minuten. Omdat het veldwerk 2 weken duurt en men twee herinneringen krijgt, is iedereen (van oud tot jong, werkend of niet werkend en/of tijdelijk afwezig) in de gelegenheid de vragenlijsten in te vullen.

## Huidige rapportage: Meting 4

**Datum van dataverzameling:** 15 - 28 maart 2021.

**Deelnemers:** Voor de vierde meting zijn alle deelnemers uit de derde meting uitgenodigd die de vragenlijst van de derde meting hadden ingevuld. 

**Ter achtergrondinformatie:** de steekproef van de eerste meting was een aselecte steekproef van LISS-panelleden van 16 jaar en ouder die ook de LISS-kernvragenlijst ‘Health’ (afgenomen in november en december 2019) en de vragenlijst over het coronavirus (afgenomen in het LISS panel maart 2020) hebben ingevuld.  


Responsoverzicht wave 4| 
------------- | -------------
Respondenten uitgenodigd voor deelname: | 1.446 (100,0%)  
Nonrespons | 66 (4.6%)  
Respons | 1.380 (95.4%)  
  Compleet | 1.368 (94.6%)  
  Incompleet | 12 (0.8%)  

In de resultatensectie worden de uitkomsten getoond van de 1368 respondenten die de vragenlijst hebben afgemaakt. Ook wordt er een overzicht van de karakteristieken van de steekproef getoond. In de bijlage kan een vergelijking van de demografische samenstelling van de steekproef in vergelijking met die van de Nederlandse bevolking (op basis van gegevens van het CBS) gevonden worden. 

## Vergelijkingen naar gebruikersstatus en over de tijd

Voor de meeste onderwerpen zijn de resultaten uitgesplitst naar gebruikersstatus en is een vergelijking over de tijd getoond. 

Voor de uitsplitsing naar gebruikersstatus werd een respondent aangemerkt als *Gebruiker* indien deze op de vraag 'Welke situatie geldt voor u?' het antwoord 'Ik gebruik de CoronaMelder app op dit moment' had gegeven. Iemand is aangemerkt als *Niet gebruiker* indien de respondent op deze vraag het antwoord 'Ik heb de CoronaMelder app nooit gebruikt' had gegeven. Iemand is aangemerkt als *Voormalig gebruiker* indien de respondent op deze vraag het antwoord 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer' had gegeven. Niet gebruikers die aangaven het in meer of mindere mate *oneens* te zijn met de stelling 'Ik ben van plan de CoronaMelder in de komende 2 maanden te gebruiken' werden aangemerkt als *Niet gebruiker - niet van plan om te gaan gebruiken*. Niet gebruikers die aangaven het in meer of mindere mate *eens* te zijn met de stelling 'Ik ben van plan de CoronaMelder in de komende 2 maanden te gebruiken' werden aangemerkt als *Niet gebruiker - wel van plan om te gaan gebruiken*. Niet gebruikers die *neutraal* antwoorden op de stelling 'Ik ben van plan de CoronaMelder in de komende 2 maanden te gebruiken' werden aangemerkt als *Niet gebruiker - neutraal*. Chi kwadraat toetsen zijn uitgevoerd om te bepalen of het totaal aandeel respondenten dat het eens (een beetje, eens, helemaal mee eens) is met de verschillende stellingen verschilt tussen de huidige gebruikers en degenen die de CoronaMelder nooit gebruikt hebben. 

Voor de vergelijkingen over tijd is een McNemar chi kwadraattoets uitgevoerd om te toetsen of het totaal aandeel respondenten dat het eens (een beetje, eens, helemaal mee eens) is met de verschillende stellingen verschilt tussen de huidige en de vorige meting. Bij deze toetsen en in de bijbehorende grafieken zijn alleen de respondenten meegenomen die zowel de huidige als de vorige vragenlijst volledig hebben ingevuld. Daarom kan het zijn dat percentages 'eens' tijdens de vorige wave die in dit rapport getoond worden afwijken van de percentages die gepresenteerd werden in de vorige rapportage. 

```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```

# Resultaten
## Karakteristieken van de steekproef
### Demografische factoren
Aan dit onderzoek hebben `r nrow(data)` respondenten deelgenomen (gemiddelde leeftijd in jaren: `r round(mean(data$leeftijd), digits = 1)`, standaarddeviatie: `r round(sd(data$leeftijd), digits = 1)`, range: `r min(data$leeftijd)`-`r max(data$leeftijd)`; `r round((nrow(filter(data, geslacht == 'Vrouw'))/nrow(data))*100, digits = 1)`% vrouw). De demografische kenmerken zijn te vinden in de onderstaande tabel. 

```{r, echo=FALSE, results="asis"} 
tab.noby <- tableby(~ geslacht + lftdcat + sted_simplified + belbezig_simplified + oplmet_simplified + burgstat_simplified + nettocat_simplified + woonvorm, data=data)
summary(tab.noby, title="(\\#tab:mytableby) Demografische statistieken van de steekproef")
```

### Gezondheidsmotivatie en risicoperceptie corona besmetting

#### Besmetting met het coronavirus bij zichzelf en mensen in de directe omgeving
In de vragenlijst werd gevraagd of de respondenten zelf of mensen in hun directe omgeving besmet zijn (geweest) met het coronavirus. In totaal gaven `r round(nrow(filter(data, CoronaInfectionSelf == 'Ja'))/nrow(data)*100, digits = 1)`% van de respondenten het antwoord *Ja* op de vraag of zij zelf dachten besmet te zijn (geweest) en `r round(nrow(filter(data, CoronaInfectionSelf == 'Nee'))/nrow(data)*100, digits = 1)`% antwoordde hierop *Nee*. Een substantieel percentage (`r round(nrow(filter(data, CoronaInfectionSelf == 'Ik weet het niet'))/nrow(data)*100, digits = 1)`%) gaf aan dit niet te weten.

Ook werd gevraagd of er wel eens een coronatest bij de respondent was afgenomen. Hierop antwoordde `r round(nrow(filter(data, CoronaInfectionSelfTest == 'Ja, een keer'))/nrow(data)*100, digits = 1)`% dat er 1 keer een test was afgenomen en `r round(nrow(filter(data, CoronaInfectionSelfTest == 'Ja, meerdere keren'))/nrow(data)*100, digits = 1)`% dat er al meerdere keren een test was afgenomen. De rest (`r round(nrow(filter(data, CoronaInfectionSelfTest == 'Nee'))/nrow(data)*100, digits = 1)`%) gaf aan dat er nog nooit een test was afgenomen. 

Van de mensen bij wie al minstens een keer een test was afgenomen (`r  nrow(filter(data, (CoronaInfectionSelfTest == 'Ja, een keer' | CoronaInfectionSelfTest == 'Ja, meerdere keren')))`), gaf  `r  round((nrow(filter(data, (CoronaInfectionSelfTest_1 == 'Ja' | CoronaInfectionSelfTest_2 == 'Ja'))) / nrow(filter(data, (CoronaInfectionSelfTest == 'Ja, een keer' | CoronaInfectionSelfTest == 'Ja, meerdere keren'))))*100, digits = 1)`% aan dat een van deze testen positief was, `r  round((nrow(filter(data, (CoronaInfectionSelfTest_1 == 'Nee' | CoronaInfectionSelfTest_2 == 'Nee'))) / nrow(filter(data, (CoronaInfectionSelfTest == 'Ja, een keer' | CoronaInfectionSelfTest == 'Ja, meerdere keren'))))*100, digits = 1)`% gaf aan dat de test negatief was en de rest (`r  round((nrow(filter(data, (CoronaInfectionSelfTest_1 == 'Weet ik (nog) niet' | CoronaInfectionSelfTest_2 == 'Weet ik (nog) niet'))) / nrow(filter(data, (CoronaInfectionSelfTest == 'Ja, een keer' | CoronaInfectionSelfTest == 'Ja, meerdere keren'))))*100, digits = 1)`%) gaf aan dit (nog) niet te weten. 

In totaal gaf `r round(nrow(filter(data, (CoronaInfectionOther_1 == 'Ja' | CoronaInfectionOther_2 == 'Ja' | CoronaInfectionOther_3 == 'Ja' | CoronaInfectionOther_4 == 'Ja' | CoronaInfectionOther_5 == 'Ja' | CoronaInfectionOther_6 == 'Ja')))/nrow(data)*100, digits = 1)`% aan dat iemand in hun directe omgeving besmet is (geweest)  met het coronavirus. In onderstaande grafiek (figuur \@ref(fig:coronainfectionother)) is te zien welke relatie deze personen tot de respondent hadden. In totaal gaf `r round(nrow(filter(data, (CoronaInfectionOther_7 == 'Ja')))/nrow(data)*100, digits = 1)`% aan dat niemand in hun directe omgeving besmet is (geweest)  met het coronavirus en `r round(nrow(filter(data, (CoronaInfectionOther_8 == 'Ja')))/nrow(data)*100, digits = 1)`% wist dit niet of wilde dit niet zeggen. 

```{r coronainfectionother, echo=FALSE, fig.width=7, fig.height=2.5, fig.cap="Relatie geïnfecteerde personen tot de respondent"}
# Prepare dataset datachart for plot
chartdata <- data.frame(var=c("Ja, mijn partner", 
                         "Ja, een of meerdere familieleden", 
                         "Ja, een of meerdere vrienden", 
                         "Ja, een of meerdere collega\'s of studiegenoten", 
                         "Ja, een of meerdere kennissen", 
                         "Ja, iemand anders"),
                value=c(round((nrow(filter(data, (CoronaInfectionOther_1 == 'Ja')))/nrow(data))*100, digits = 1),
                      round((nrow(filter(data, (CoronaInfectionOther_2 == 'Ja')))/nrow(data))*100, digits = 1),
                      round((nrow(filter(data, (CoronaInfectionOther_3 == 'Ja')))/nrow(data))*100, digits = 1), 
                      round((nrow(filter(data, (CoronaInfectionOther_4 == 'Ja')))/nrow(data))*100, digits = 1),
                      round((nrow(filter(data, (CoronaInfectionOther_5 == 'Ja')))/nrow(data))*100, digits = 1),
                      round((nrow(filter(data, (CoronaInfectionOther_6 == 'Ja')))/nrow(data))*100, digits = 1))
                )
# Create the plot
plot = ggplot(data=chartdata, aes(x=var, y=value)) +
  geom_bar(stat="identity", fill = "#bdd7e7", color = "#6baed6") +
  geom_text(aes(x=var, y=value, label=value, 
                hjust=ifelse(sign(value)>0, 1, 0)), 
            position = position_dodge(width=1)) +
  coord_flip() +
  ylab("Percentage deelnemers (meerdere antwoorden mogelijk)") +
  xlab("") +
  theme(plot.margin = margin(0, 0.1, 0, 0)) +
  theme_bw()
plot

```

#### Corona risicoperceptie en ernst
Uit gedragswetenschappelijke literatuur is bekend dat gepercipieerde ernst en vatbaarheid voor een ziekte een rol kunnen spelen in de acceptatie van gezondheidsadviezen om de ontwikkeling van deze ziekte te voorkomen. Ongeveer de helft van de steekproef acht zichzelf vatbaar voor het coronavirus: `r round((nrow(filter(data, (HBM_PSus_self1 == 'Helemaal mee eens'| HBM_PSus_self1 == 'Mee eens'| HBM_PSus_self1 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% gaf aan het eens te zijn met de stelling dat men risico loopt op een besmetting in de komende twee maanden (zie figuur \@ref(fig:riskperception)). Daarnaast was een vergelijkbaar percentage (`r round((nrow(filter(data, (HBM_PSus_other2 == 'Helemaal mee eens'| HBM_PSus_other2 == 'Mee eens'| HBM_PSus_other2 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) het in meer of mindere mate eens met de stelling dat de kans groot is om een ander te besmetten indien men zelf besmet raakt.

Voor het meten van de gepercipieerde ernst is gevraagd hoe erg respondenten het zouden vinden om zelf besmet te raken of om anderen te besmetten. Een groot deel van de respondenten vindt het erg om zelf besmet te raken (`r round((nrow(filter(data, (HBM_PSev_self1 == 'Helemaal mee eens'| HBM_PSev_self1 == 'Mee eens'| HBM_PSev_self1 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Daarnaast vindt men het erg om anderen te besmetten (`r round((nrow(filter(data, (HBM_PSev_other2 == 'Helemaal mee eens'| HBM_PSev_other2 == 'Mee eens'| HBM_PSev_other2 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). 

```{r riskperception, echo=FALSE, fig.width=7, fig.height=2.2, fig.cap="Waargenomen ernst en vatbaarheid - hele populatie", tab.cap="Waargenomen ernst en vatbaarheid - hele populatie"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_PSus_self1", 
                        "HBM_PSus_other2", 
                        "HBM_PSev_self1", 
                        "HBM_PSev_other2")
graph_questionlabels = c("Ik loop in de komende twee maanden risico op een besmetting met het coronavirus", 
                         "Als ik besmet raak is de kans  groot dat ik anderen zal besmetten", 
                         "Ik vind het erg om besmet te raken", 
                         "Ik vind het erg als ik andere mensen besmet"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
baseplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

ggdraw(baseplot)

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))


# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

##### Waargenomen ernst en vatbaarheid over de tijd
```{r McNemarHBMPsusself1overtime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_PSus_self1_agree_cw[(data_currentwave_wavemin1$HBM_PSus_self1_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_PSus_self1_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_PSus_self1_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_PSus_self1_agree_cw[(data_currentwave_wavemin1$HBM_PSus_self1_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_PSus_self1_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_PSus_self1_cw == 'Oneens'| data_currentwave_wavemin1$HBM_PSus_self1_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_PSus_self1_agree_wmin1[(data_currentwave_wavemin1$HBM_PSus_self1_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_PSus_self1_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_PSus_self1_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_PSus_self1_agree_wmin1[(data_currentwave_wavemin1$HBM_PSus_self1_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_PSus_self1_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_PSus_self1_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_PSus_self1_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_PSus_self1_agree_cw, data_currentwave_wavemin1$HBM_PSus_self1_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_PSus_self1_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_PSus_self1_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat men in de komende twee maanden risico loopt op besmetting met het coronavirus.

```{r McNemarHBMPsusother2overtime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_PSus_other2_agree_cw[(data_currentwave_wavemin1$HBM_PSus_other2_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_PSus_other2_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_PSus_other2_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_PSus_other2_agree_cw[(data_currentwave_wavemin1$HBM_PSus_other2_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_PSus_other2_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_PSus_other2_cw == 'Oneens'| data_currentwave_wavemin1$HBM_PSus_other2_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_PSus_other2_agree_wmin1[(data_currentwave_wavemin1$HBM_PSus_other2_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_PSus_other2_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_PSus_other2_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_PSus_other2_agree_wmin1[(data_currentwave_wavemin1$HBM_PSus_other2_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_PSus_other2_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_PSus_other2_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_PSus_other2_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_PSus_other2_agree_cw, data_currentwave_wavemin1$HBM_PSus_other2_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_PSus_other2_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_PSus_other2_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat de kans groot is dat men anderen zal besmetten, wanneer men zelf besmet is.

```{r McNemarHBMPsevself1overtime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_PSev_self1_agree_cw[(data_currentwave_wavemin1$HBM_PSev_self1_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_PSev_self1_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_PSev_self1_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_PSev_self1_agree_cw[(data_currentwave_wavemin1$HBM_PSev_self1_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_PSev_self1_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_PSev_self1_cw == 'Oneens'| data_currentwave_wavemin1$HBM_PSev_self1_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_PSev_self1_agree_wmin1[(data_currentwave_wavemin1$HBM_PSev_self1_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_PSev_self1_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_PSev_self1_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_PSev_self1_agree_wmin1[(data_currentwave_wavemin1$HBM_PSev_self1_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_PSev_self1_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_PSev_self1_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_PSev_self1_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_PSev_self1_agree_cw, data_currentwave_wavemin1$HBM_PSev_self1_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_PSev_self1_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_PSev_self1_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het erg is om besmet te raken met het coronavirus.

```{r McNemarHBMPsevother2overtime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_PSev_other2_agree_cw[(data_currentwave_wavemin1$HBM_PSev_other2_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_PSev_other2_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_PSev_other2_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_PSev_other2_agree_cw[(data_currentwave_wavemin1$HBM_PSev_other2_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_PSev_other2_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_PSev_other2_cw == 'Oneens'| data_currentwave_wavemin1$HBM_PSev_other2_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_PSev_other2_agree_wmin1[(data_currentwave_wavemin1$HBM_PSev_other2_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_PSev_other2_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_PSev_other2_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_PSev_other2_agree_wmin1[(data_currentwave_wavemin1$HBM_PSev_other2_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_PSev_other2_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_PSev_other2_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_PSev_other2_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_PSev_other2_agree_cw, data_currentwave_wavemin1$HBM_PSev_other2_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_PSev_other2_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_PSev_other2_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het erg is om anderen te besmetten met het coronavirus.

```{r, echo=FALSE, fig.width=5.5, fig.height=4, dpi = 300, fig.cap="Waargenomen ernst en vatbaarheid over de tijd, totaal percentage dat het minstens een beetje eens was met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_PSus_self1", 
                        "HBM_PSus_other2", 
                        "HBM_PSev_self1", 
                        "HBM_PSev_other2")
graph_questionlabels = c("Ik loop in de komende twee maanden risico op een besmetting met het coronavirus", 
                         "Als ik besmet raak is de kans  groot dat ik anderen zal besmetten", 
                         "Ik vind het erg om besmet te raken", 
                         "Ik vind het erg als ik andere mensen besmet"); 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

#### Naleven algemene gedragsregels
In kaart is gebracht in hoeverre de respondenten zich in de afgelopen twee maanden aan een aantal van de algemene gedragsregels hebben gehouden (zie figuur \@ref(fig:behavioradhgenmeasures)). `r round((nrow(filter(data, (Behavior_AdherenceGeneralMeasures_handwashing == 'Altijd'| Behavior_AdherenceGeneralMeasures_handwashing == 'Meestal'| Behavior_AdherenceGeneralMeasures_handwashing == 'Vaak'))) /nrow(data))*100, digits = 1)`% gaf aan, vaak, meestal of altijd handen te wassen. Ongeveer de helft van de respondenten (`r round((nrow(filter(data, (Behavior_AdherenceGeneralMeasures_distance == 'Nooit'| Behavior_AdherenceGeneralMeasures_distance == 'Zelden'| Behavior_AdherenceGeneralMeasures_distance == 'Soms'))) /nrow(data))*100, digits = 1)`%) gaf aan nooit, zelden of soms op minder dan 1,5 meter afstand van mensen buiten het huishouden te zijn geweest. Tot slot gaf `r round((nrow(filter(data, (Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Nooit'| Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Zelden'| Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Soms'))) /nrow(data))*100, digits = 1)`% aan nooit, zelden of soms op een plek te zijn geweest waar 1,5 meter afstand houden eigenlijk niet mogelijk was. 

```{r behavioradhgenmeasures, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Naleving algemene gedragsregels", tab.cap="Naleving algemene gedragsregels. In de afgelopen twee maanden, hoe vaak... "}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Behavior_AdherenceGeneralMeasures_handwashing", 
                        "Behavior_AdherenceGeneralMeasures_distance", 
                        "Behavior_AdherenceGeneralMeasures_avoidbusyplaces")
graph_questionlabels = c("... hebt u uw handen gewassen?", 
                         "... bent u minder dan op 1,5m afstand geweest van mensen buiten uw huishouden?", 
                         "... bent u op een plek geweest waar het eigenlijk te druk was om 1,5m afstand te houden?"); 
plot_title = "In de afgelopen twee maanden, hoe vaak..."

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Altijd", "Meestal", "Vaak", "Regelmatig", "Soms", "Zelden", "Nooit"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle(plot_title) + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Van alle respondenten gaf `r round(nrow(filter(data, Corona_complaints == "Ja"))/nrow(data)*100, digits =1)`% aan klachten te hebben gehad die passen bij het coronavirus in de afgelopen twee maanden. Onderstaande grafiek (figuur \@ref(fig:coronacomplaintsquarantaine)) laat zien in hoeverre deze respondenten in quarantaine bleven: in totaal gaf `r round((nrow(filter(data, Corona_complaints == "Ja" & (Behavior_AdherenceGeneralMeasures_quarantaine == 'Nooit'| Behavior_AdherenceGeneralMeasures_quarantaine == 'Zelden'))) /nrow(filter(data, Corona_complaints == "Ja")))*100, digits = 1)`% aan nooit of zelden naar buiten te zijn geweest met klachten.

```{r coronacomplaintsquarantaine, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Naleving algemene gedragsregels bij klachten", tab.cap = "Naleving algemene gedragsregels bij klachten."}


# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Behavior_AdherenceGeneralMeasures_quarantaine")
graph_questionlabels = c("Bent u, toen u deze klachten had, naar buiten geweest?"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Nooit", "Zelden", "Soms", "Regelmatig", "Vaak", "Meestal", "Altijd"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Corona_complaints=='Ja'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

##### Naleven algemene gedragsregels over de tijd
```{r McNemarBehaviorAdherenceGeneralMeasureshandwashingovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_agree_cw[(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_cw == 'Altijd'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_cw == 'Meestal'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_cw == 'Vaak')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_agree_cw[(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_cw == 'Regelmatig'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_cw == 'Soms'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_cw == 'Zelden'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_cw == 'Nooit')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_agree_wmin1[(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_wmin1 == 'Altijd'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_wmin1 == 'Meestal'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_wmin1 == 'Vaak')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_agree_wmin1[(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_wmin1 == 'Regelmatig'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_wmin1 == 'Soms'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_wmin1 == 'Zelden'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_wmin1 == 'Nooit')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_agree_cw, data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_handwashing_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Behavior_AdherenceGeneralMeasures_handwashing_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Behavior_AdherenceGeneralMeasures_handwashing_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf altijd, meestal, of vaak de handen gewassen te hebben.
```{r McNemarBehaviorAdherenceGeneralMeasuresdistanceovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_agree_cw[(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_cw == 'Altijd'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_cw == 'Meestal'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_cw == 'Vaak')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_agree_cw[(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_cw == 'Regelmatig'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_cw == 'Soms'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_cw == 'Zelden'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_cw == 'Nooit')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_agree_wmin1[(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_wmin1 == 'Altijd'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_wmin1 == 'Meestal'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_wmin1 == 'Vaak')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_agree_wmin1[(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_wmin1 == 'Regelmatig'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_wmin1 == 'Soms'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_wmin1 == 'Zelden'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_wmin1 == 'Nooit')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_agree_cw, data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_distance_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Behavior_AdherenceGeneralMeasures_distance_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Behavior_AdherenceGeneralMeasures_distance_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf altijd, meestal, of vaak op minder dan 1,5 meter afstand geweest te zijn van mensen buiten het huishouden.

```{r McNemarBehaviorAdherenceGeneralMeasuresavoidbusyplacesovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree_cw[(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_cw == 'Altijd'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_cw == 'Meestal'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_cw == 'Vaak')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree_cw[(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_cw == 'Regelmatig'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_cw == 'Soms'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_cw == 'Zelden'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_cw == 'Nooit')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree_wmin1[(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_wmin1 == 'Altijd'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_wmin1 == 'Meestal'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_wmin1 == 'Vaak')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree_wmin1[(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_wmin1 == 'Regelmatig'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_wmin1 == 'Soms'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_wmin1 == 'Zelden'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_wmin1 == 'Nooit')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree_cw, data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf altijd, meestal, of vaak op een plek geweest te zijn waar het eigenlijk te druk was om 1,5 meter afstand te houden.

```{r ChsquareBehaviorAdherenceGeneralMeasuresquarantaineovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_agree_cw[(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_cw == 'Altijd'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_cw == 'Meestal'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_cw == 'Vaak')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_agree_cw[(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_cw == 'Regelmatig'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_cw == 'Soms'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_cw == 'Zelden'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_cw == 'Nooit')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_agree_wmin1[(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_wmin1 == 'Altijd'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_wmin1 == 'Meestal'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_wmin1 == 'Vaak')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_agree_wmin1[(data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_wmin1 == 'Regelmatig'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_wmin1 == 'Soms'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_wmin1 == 'Zelden'| data_currentwave_wavemin1$Behavior_AdherenceGeneralMeasures_quarantaine_wmin1 == 'Nooit')] <- "Neutraal, niet mee eens_wmin1"

# THe following explanation holds for BI1a and BI1b: The fact that for some of the participants the user status changed between wave 1 and wave 2, we decided to perform a chi square in which we compare the proportion of Totaal eens_wmin1 versus Neutraal, niet mee eens_wmin1 for users of wave 1 with the proportion of Totaal eens_cw versus Neutraal, niet mee eens_cw for users of the current wave. For this we have to select, separately for each wave, the users (or non users). For these subsets we calculate counts with Totaal eens and Neutraal, etc. After that we concatenate these counts int a 2x2 table and perform a regular chi square on that.  
data_selected_cw = data_currentwave_wavemin1[data_currentwave_wavemin1$Corona_complaints_cw == "Ja", ]

data_selected_wmin1 = data_currentwave_wavemin1[data_currentwave_wavemin1$Corona_complaints_wmin1 == "Ja", ]

# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$Behavior_AdherenceGeneralMeasures_quarantaine_agree_cw), table(data_selected_wmin1$Behavior_AdherenceGeneralMeasures_quarantaine_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```

Om te bepalen of de mate van naleving van de maatregelen bij klachten verschilt tussen de huidige en de vorige wave is een chi kwadraat toets uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave klachten hadden en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin het ervaren van klachten in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage respondenten met klachten in de huidige wave (`r round((nrow(filter(data_selected_cw, Behavior_AdherenceGeneralMeasures_quarantaine_agree_cw == 'Totaal eens_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf altijd, meestal, of vaak naar buiten te zijn geweest, vergeleken met het percentage respondenten uit de vorige wave dat in de vorige wave aangaf klachten te hebben (`r round((nrow(filter(data_selected_wmin1, Behavior_AdherenceGeneralMeasures_quarantaine_agree_wmin1 == 'Totaal eens_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%).

```{r, echo=FALSE, fig.width=5.5, fig.height=3.5, dpi = 300, fig.cap="Naleven algemene gedragsregels over de tijd, totaal percentage dat vaak, meestal, of altijd het gedrag heeft uitgevoerd."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Behavior_AdherenceGeneralMeasures_handwashing", 
                        "Behavior_AdherenceGeneralMeasures_distance", 
                        "Behavior_AdherenceGeneralMeasures_avoidbusyplaces")
graph_questionlabels = c("In de afgelopen maanden, hoe vaak hebt u uw handen gewassen?", 
                         "In de afgelopen maanden, hoe vaak bent u minder dan op 1,5m afstand geweest van mensen buiten uw huishouden?", 
                         "In de afgelopen maanden, hoe vaak bent u op een plek geweest waar het eigenlijk te druk was om 1,5m afstand te houden?"); 


# Which values do we want to include in the table cells?
include_vars = c("Altijd", "Meestal", "Vaak")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

```{r, echo=FALSE, fig.width=5.5, fig.height=2.5, dpi = 300, fig.cap="Naleving quarantaine maatregel bij klachten over de tijd, totaal percentage dat vaak, meestal, of altijd naar buiten is geweest met klachten."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Behavior_AdherenceGeneralMeasures_quarantaine")
graph_questionlabels = c("Bent u, toen u deze klachten had, naar buiten geweest?"); 

include_vars = c("Vaak", "Meestal", "Altijd")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars & (eval(parse(text=paste('Corona_complaints', include_waves[wave_idx], sep="_")))) == 'Ja')) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) & (eval(parse(text=paste('Corona_complaints', include_waves[wave_idx], sep="_")))) == 'Ja'))    

  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

#### Intentie tot naleving algemene gedragsregels
Er is gevraagd naar de mate waarin men van plan is om zich de komende twee maanden te houden aan een aantal van de algemene gedragsregels. Het percentage respondenten dat aangeeft de intentie te hebben om zich aan de voorgestelde gedragsregels te houden ligt hoog (handen regelmatig wassen: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_handwashing == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_handwashing == 'Mee eens'| Intention_AdherenceGeneralMeasures_handwashing == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; afstand houden: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_distance == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_distance == 'Mee eens'| Intention_AdherenceGeneralMeasures_distance == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; drukke plekken vermijden: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Mee eens'| Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; thuisblijven bij klachten: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_quarantaine == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_quarantaine == 'Mee eens'| Intention_AdherenceGeneralMeasures_quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; testen bij klachten: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_testwithsymptoms == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_testwithsymptoms == 'Mee eens'| Intention_AdherenceGeneralMeasures_testwithsymptoms == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Onderstaande figuur geeft de intenties weer (figuur \@ref(fig:intentionadhgenmeasures)).

```{r intentionadhgenmeasures, echo=FALSE, fig.width=7, fig.height=3, fig.cap="Intentie tot naleving algemene gedragsregels", tab.cap="Intentie tot naleving algemene gedragsregels"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_AdherenceGeneralMeasures_handwashing", 
                        "Intention_AdherenceGeneralMeasures_distance", 
                        "Intention_AdherenceGeneralMeasures_avoidbusyplaces", 
                        "Intention_AdherenceGeneralMeasures_quarantaine",
                        "Intention_AdherenceGeneralMeasures_testwithsymptoms")
graph_questionlabels = c("... mijn handen regelmatig te wassen", 
                         "... 1,5 meter afstand te houden van mensen buiten mijn huishouden", 
                         "... drukke plekken te vermijden", 
                         "... thuis te blijven als ik last heb van klachten die passen bij het coronavirus", 
                         "... een coronatest te doen als ik last heb van klachten die passen bij het coronavirus"); 
plot_title = "Ik ben van plan om de komende 2 maanden..."
# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle(plot_title) + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

##### Intentie tot naleving algemene gedragsregels over de tijd

```{r McIntentionAdherenceGeneralMeasureshandwashingovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_agree_cw[(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_cw == 'Mee eens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_agree_cw[(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_cw == 'Neutraal'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_cw == 'Een beetje oneens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_cw == 'Oneens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_agree_wmin1[(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_wmin1 == 'Mee eens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_agree_wmin1[(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_wmin1 == 'Neutraal'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_wmin1 == 'Oneens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_agree_cw, data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_handwashing_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Intention_AdherenceGeneralMeasures_handwashing_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Intention_AdherenceGeneralMeasures_handwashing_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling van plan te zijn om de komende 2 maanden de handen regelmatig te wassen.
```{r McIntentionAdherenceGeneralMeasureshanddistanceovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_agree_cw[(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_cw == 'Mee eens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_agree_cw[(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_cw == 'Neutraal'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_cw == 'Een beetje oneens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_cw == 'Oneens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_agree_wmin1[(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_wmin1 == 'Mee eens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_agree_wmin1[(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_wmin1 == 'Neutraal'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_wmin1 == 'Oneens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_agree_cw, data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_distance_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Intention_AdherenceGeneralMeasures_distance_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Intention_AdherenceGeneralMeasures_distance_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling van plan te zijn om de komende 2 maanden 1,5 meter afstand te houden van mensen buiten het huishouden. 
```{r McIntentionAdherenceGeneralMeasuresavoidbusyplacesovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree_cw[(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_cw == 'Mee eens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree_cw[(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_cw == 'Neutraal'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_cw == 'Een beetje oneens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_cw == 'Oneens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree_wmin1[(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_wmin1 == 'Mee eens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree_wmin1[(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_wmin1 == 'Neutraal'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_wmin1 == 'Oneens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree_cw, data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling van plan te zijn om de komende 2 maanden drukke plekken te vermijden.
```{r McIntentionAdherenceGeneralMeasuresquarantineovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_agree_cw[(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_cw == 'Mee eens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_agree_cw[(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_cw == 'Neutraal'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_cw == 'Een beetje oneens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_cw == 'Oneens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_agree_wmin1[(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_wmin1 == 'Mee eens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_agree_wmin1[(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_wmin1 == 'Neutraal'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_wmin1 == 'Oneens'| data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_agree_cw, data_currentwave_wavemin1$Intention_AdherenceGeneralMeasures_quarantaine_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Intention_AdherenceGeneralMeasures_quarantaine_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Intention_AdherenceGeneralMeasures_quarantaine_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling van plan te zijn om de komende 2 maanden thuis te blijven als men klachten heeft die passen bij het coronavirus. 


```{r, echo=FALSE, fig.width=5.5, fig.height=4.0, dpi = 300, fig.cap="Intentie tot naleving algemene gedragsregels over de tijd, totaal percentage dat minstens een beetje eens was met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_AdherenceGeneralMeasures_handwashing", 
                        "Intention_AdherenceGeneralMeasures_distance", 
                        "Intention_AdherenceGeneralMeasures_avoidbusyplaces", 
                        "Intention_AdherenceGeneralMeasures_quarantaine")
graph_questionlabels = c("Ik ben van plan om de komende 2 maanden mijn handen regelmatig te wassen", 
                         "Ik ben van plan om de komende 2 maanden 1,5 meter afstand te houden van mensen buiten mijn huishouden", 
                         "Ik ben van plan om de komende 2 maanden drukke plekken te vermijden", 
                         "Ik ben van plan om de komende 2 maanden thuis te blijven als ik last heb van klachten die passen bij het coronavirus"); 

include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

### Algemene opvattingen over het coronavirus

#### Complottheorieën
Om in kaart te brengen in hoeverre complottheorieën een rol spelen is gevraagd of men dacht dat een aantal stellingen waar of onwaar zijn (zie figuur \@ref(fig:complot)). Van de respondenten beoordeelt `r round((nrow(filter(data, (Beliefs_Conspiracy1 == 'Zeker waar'| Beliefs_Conspiracy1 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`% de stelling 'Het coronavirus is een biologisch wapen dat in een laboratorium is gemaakt' met misschien waar of zeker waar. Een kleiner percentage beoordeelt de stelling 'De uitbraak van het coronavirus heeft te maken met het 5G netwerk' als misschien waar of zeker waar (`r round((nrow(filter(data, (Beliefs_Conspiracy2 == 'Zeker waar'| Beliefs_Conspiracy2 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%).

```{r complot, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Geloof in complottheorieën", tab.cap="Geloof in complottheorieën"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_Conspiracy1", 
                        "Beliefs_Conspiracy2")
graph_questionlabels = c("Het coronavirus is een biologisch wapen dat in een laboratorium is gemaakt", 
                         "De uitbraak van het coronavirus heeft te maken met (de aanleg van) het 5G netwerk"); 

# These questions have 5 answer categories: Zeker niet waar - Zeker waar en Weet ik niet. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Zeker waar", "Misschien waar", "Misschien niet waar", "Zeker niet waar"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

#table(data$Beliefs_Conspiracy1)

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

##### Complottheorieën over de tijd
```{r chiBeliefsconspiracy1overtime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_Conspiracy1_agree_cw[(data_currentwave_wavemin1$Beliefs_Conspiracy1_cw == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_Conspiracy1_cw == 'Misschien waar')] <- "Totaal waar_cw"
data_currentwave_wavemin1$Beliefs_Conspiracy1_agree_cw[(data_currentwave_wavemin1$Beliefs_Conspiracy1_cw == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_Conspiracy1_cw == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_Conspiracy1_cw == 'Misschien niet waar')] <- "Weet niet, niet waar_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_Conspiracy1_agree_wmin1[(data_currentwave_wavemin1$Beliefs_Conspiracy1_wmin1 == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_Conspiracy1_wmin1 == 'Misschien waar')] <- "Totaal waar_wmin1"
data_currentwave_wavemin1$Beliefs_Conspiracy1_agree_wmin1[(data_currentwave_wavemin1$Beliefs_Conspiracy1_wmin1 == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_Conspiracy1_wmin1 == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_Conspiracy1_wmin1 == 'Misschien niet waar')] <- "Weet niet, niet waar_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_Conspiracy1_agree_cw, data_currentwave_wavemin1$Beliefs_Conspiracy1_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table) 
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_Conspiracy1_agree_cw == 'Totaal waar_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_Conspiracy1_agree_wmin1 == 'Totaal waar_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf dat de stelling dat het coronavirus een biologisch wapen is dat in een laboratorium is gemaakt, waar is. 
```{r chiBeliefsconspiracy2overtime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_Conspiracy2_agree_cw[(data_currentwave_wavemin1$Beliefs_Conspiracy2_cw == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_Conspiracy2_cw == 'Misschien waar')] <- "Totaal waar_cw"
data_currentwave_wavemin1$Beliefs_Conspiracy2_agree_cw[(data_currentwave_wavemin1$Beliefs_Conspiracy2_cw == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_Conspiracy2_cw == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_Conspiracy2_cw == 'Misschien niet waar')] <- "Weet niet, niet waar_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_Conspiracy2_agree_wmin1[(data_currentwave_wavemin1$Beliefs_Conspiracy2_wmin1 == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_Conspiracy2_wmin1 == 'Misschien waar')] <- "Totaal waar_wmin1"
data_currentwave_wavemin1$Beliefs_Conspiracy2_agree_wmin1[(data_currentwave_wavemin1$Beliefs_Conspiracy2_wmin1 == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_Conspiracy2_wmin1 == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_Conspiracy2_wmin1 == 'Misschien niet waar')] <- "Weet niet, niet waar_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_Conspiracy2_agree_cw, data_currentwave_wavemin1$Beliefs_Conspiracy2_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table) 
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_Conspiracy2_agree_cw == 'Totaal waar_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_Conspiracy2_agree_wmin1 == 'Totaal waar_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf dat de stelling dat de uitbraak van het coronavirus te maken heeft met (de aanleg van) het 5G netwerk, waar is. 

```{r, echo=FALSE, fig.width=5.5, fig.height=3.0, dpi = 300, fig.cap="Complottheorieën over de tijd, totaal percentage waar (misschien waar, zeker waar)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_Conspiracy1", 
                        "Beliefs_Conspiracy2")
graph_questionlabels = c("Het coronavirus is een biologisch wapen dat in een laboratorium is gemaakt", 
                         "De uitbraak van het coronavirus heeft te maken met (de aanleg van) het 5G netwerk"); 

include_vars = c("Zeker waar", "Misschien waar")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

#### Vertrouwen in aanpak van de overheid
Respondenten zijn verdeeld wat betreft het vertrouwen in de overheid met betrekking tot de aanpak van de coronacrisis (zie figuur \@ref(fig:trustgovernment)). Meer dan de helft is het eens met de stelling 'Ik heb vertrouwen in de manier waarop de Nederlandse overheid probeert het coronavirus onder controle te houden' (`r round((nrow(filter(data, (Beliefs_TrustGovernment == 'Helemaal mee eens'| Beliefs_TrustGovernment == 'Mee eens'| Beliefs_TrustGovernment == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).

```{r trustgovernment, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Vertrouwen in de Nederlandse overheid", tab.cap="Vertrouwen in de Nederlandse overheid"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_TrustGovernment")
graph_questionlabels = c("Ik heb vertrouwen in de manier waarop de Nederlandse overheid probeert het coronavirus onder controle te houden"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) 

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])


# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

## Bekendheid met CoronaMelder
In de vragenlijst werd gevraagd hoe bekend men (voor het openen van de vragenlijst) was met de CoronaMelder app. In totaal gaf `r round(((nrow(filter(data, Awareness == 'Heel erg bekend')) + nrow(filter(data, Awareness == 'Bekend')) + nrow(filter(data, Awareness == 'Redelijk bekend'))+ nrow(filter(data, Awareness == 'Een beetje bekend')))/nrow(data)*100), digits = 1)`% aan in meer of mindere mate bekend te zijn met de CoronaMelder (zie figuur \@ref(fig:awarenessCoronaMelder)). Een laag percentage (`r round(nrow(filter(data, Awareness == 'Niet bekend'))/nrow(data)*100, digits = 1)`%) gaf aan niet bekend te zijn met de CoronaMelder.   

```{r awarenessCoronaMelder, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Bekendheid met de CoronaMelder", tab.cap="Bekendheid met de CoronaMelder"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Awareness")
graph_questionlabels = c("Hoe bekend was u met de CoronaMelder?"); 

# These questions have 5 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Niet bekend", "Een beetje bekend", "Redelijk bekend", "Bekend", "Heel erg bekend"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) 

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])


# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

```{r awarenesslftd, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Bekendheid met de CoronaMelder per leeftijdscategorie"}
# Awareness op leeftijdscategorie, met ook 'reversed' labels en waarden in de bar chart:
#ggplot(data=data, aes(fill=Awareness, x=lftdcat)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("15-24", "25-34", "35-44", "45-54", "55-64", "65+")) + coord_flip() + labs(x = "Leeftijdscategorie", y = "", fill = "") + ggtitle("Bekendheid Coronamelder per leeftijdscategorie") + scale_fill_manual(values=my_palette5) + guides(fill = guide_legend(reverse = TRUE))
```

```{r awarenessgender, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Bekendheid met de CoronaMelder per geslacht"}
# Awareness op gender
#ggplot(data=data, aes(fill=Awareness, x=geslacht)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("man", "vrouw")) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Bekendheid Coronamelder per geslacht") + scale_fill_manual(values=my_palette5) + guides(fill = guide_legend(reverse = TRUE))
```

### Bekendheid met CoronaMelder over de tijd
```{r chiawarenessovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Awareness_agree_cw[(data_currentwave_wavemin1$Awareness_cw == 'Heel erg bekend'| data_currentwave_wavemin1$Awareness_cw == 'Bekend'| data_currentwave_wavemin1$Awareness_cw == 'Redelijk bekend'| data_currentwave_wavemin1$Awareness_cw == 'Een beetje bekend')] <- "Totaal bekend_cw"
data_currentwave_wavemin1$Awareness_agree_cw[(data_currentwave_wavemin1$Awareness_cw == 'Niet bekend')] <- "Niet bekend_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Awareness_agree_wmin1[(data_currentwave_wavemin1$Awareness_wmin1 == 'Heel erg bekend'| data_currentwave_wavemin1$Awareness_wmin1 == 'Bekend'| data_currentwave_wavemin1$Awareness_wmin1 == 'Redelijk bekend'| data_currentwave_wavemin1$Awareness_wmin1 == 'Een beetje bekend')] <- "Totaal bekend_wmin1"
data_currentwave_wavemin1$Awareness_agree_wmin1[(data_currentwave_wavemin1$Awareness_wmin1 == 'Niet bekend')] <- "Niet bekend_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Awareness_agree_cw, data_currentwave_wavemin1$Awareness_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table) 
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Awareness_agree_cw == 'Totaal bekend_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Awareness_agree_wmin1 == 'Totaal bekend_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf bekend te zijn met de CoronaMelder (heel erg bekend, bekend, redelijk bekend of een beetje bekend). 

```{r, echo=FALSE, fig.width=5.5, fig.height=2.5, dpi = 300, fig.cap="Bekendheid met CoronaMelder over de tijd, totaal percentage dat bekend is met de app (een beetje bekend, redelijk bekend, bekend, heel erg bekend)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Awareness")
graph_questionlabels = c("Hoe bekend was u met de CoronaMelder?"); 

include_vars = c("Een beetje bekend", "Redelijk bekend", "Bekend", "Heel erg bekend")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

## Gebruik CoronaMelder
Van alle respondenten gaf `r round(nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))/nrow(data)*100, digits = 1)`% (n = `r nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))`) aan dat hij/zij de CoronaMelder op dit moment gebruikt en `r round(nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt'))/nrow(data)*100, digits = 1)`% (n = `r nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt'))`) geeft aan de CoronaMelder nooit te hebben gebruikt. Slechts `r round(nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer'))/nrow(data)*100, digits = 1)`% (n = `r nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer'))`) gaf aan de CoronaMelder in het verleden gebruikt te hebben maar op dit moment niet meer. 


```{r echo = FALSE, eval = FALSE}
##### Open vraag: redenen om de CoronaMelder niet (meer) te gebruiken
## Clean up the text for analysis
library(tm)
# Select only those who used to use the CoronaMelder
data_formerusers <- filter(data, Behavior_UTAUT == "Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer")
data_formerusers_NoNA <- data_formerusers[complete.cases(data_formerusers$GeenGebruik_reden),]

GeenGebruik.corpus <- Corpus(VectorSource (data_formerusers_NoNA$GeenGebruik_reden))
GeenGebruik.corpus <- tm_map(GeenGebruik.corpus, stripWhitespace)
GeenGebruik.corpus <- tm_map(GeenGebruik.corpus, content_transformer(tolower))
GeenGebruik.corpus <- tm_map(GeenGebruik.corpus, removeWords, stopwords("dutch"))
GeenGebruik.corpus <- tm_map(GeenGebruik.corpus, removeNumbers)
GeenGebruik.corpus <- tm_map(GeenGebruik.corpus, removePunctuation)

GeenGebruik.dtm <- TermDocumentMatrix(GeenGebruik.corpus, control = list(stopwords=TRUE,wordLengths = c(1,30)))
findFreqTerms(GeenGebruik.dtm, lowfreq=10) ##Terms that appear 10 times

# Counts for top words
freqwrds <- sort (rowSums (as.matrix(GeenGebruik.dtm)),decreasing=TRUE)
# Returns top 100 words
melt(freqwrds [1:100])

library(tidyverse)
sums <- as.data.frame(colSums(as.matrix(GeenGebruik.dtm)))
sums <- rownames_to_column(sums) 
colnames(sums) <- c("term", "count")
sums <- arrange(sums, desc(count))
head <- sums[1:75,]
library(wordcloud)

#wordcloud(words = head$term, freq = head$count, min.freq = 3,
#  max.words=100, random.order=FALSE, rot.per=0.35, 
#  colors=brewer.pal(8, "Dark2"))

```

### Gebruik CoronaMelder over de tijd
De onderstaande tabel toont het verloop in gebruikersstatus tussen de huidige en de vorige meting. 


```{r userstatustime, echo=FALSE, tab.cap="Verloop in gebruikersstatus tussen de huidige en de vorige meting."}

table_userstatusintention_cw_wmin1 = table(data_currentwave_wavemin1$user_status_intention_cw, data_currentwave_wavemin1$user_status_intention_wmin1)
#df_userstatusintention_cw_wmin1 = as.data.frame.matrix(table_userstatusintention_cw_wmin1)
df_userstatusintention_cw_wmin1 = as.data.frame(table_userstatusintention_cw_wmin1)
df_userstatusintention_cw_wmin1_wide <- spread(df_userstatusintention_cw_wmin1, Var2, Freq)
#flextable(df_userstatusintention_cw_wmin1)
#flextable(as.data.frame(table_userstatusintention_cw_wmin1))
#flextable(data.frame(rbind(table_userstatusintention_cw_wmin1)))

# Build the basic table
ft <- flextable(
  head(df_userstatusintention_cw_wmin1_wide, n = nrow(df_userstatusintention_cw_wmin1_wide))
)

# Header
table_headerlabels = list()
table_headerlabels["Var1"] <- ""

ft <- set_header_labels(ft, values = table_headerlabels)

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(df_userstatusintention_cw_wmin1_wide))-1))

ft_out


#knitr::kable(df_userstatusintention_cw_wmin1, format="markdown")

```

## Intentie tot (blijvend) gebruik CoronaMelder
Er werd gevraagd of de respondenten de intentie hadden om de CoronaMelder de komende twee maanden te (blijven) gebruiken. Van de respondenten die de CoronaMelder app nooit hebben gebruikt, gaf `r round((nrow(filter(data, (BI1a_UTAUT == 'Helemaal mee eens'| BI1a_UTAUT == 'Mee eens'| BI1a_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`% aan van plan te zijn om de CoronaMelder te gebruiken in de komende twee maanden (zie figuur \@ref(fig:intentiontousenonusers)). Nog `r round((nrow(filter(data, (BI1a_UTAUT == 'Neutraal') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`% geeft aan hier neutraal in te staan. Het merendeel (`r round((nrow(filter(data, (BI1a_UTAUT == 'Helemaal mee oneens'| BI1a_UTAUT == 'Oneens'| BI1a_UTAUT == 'Een beetje oneens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`%) geeft aan niet van plan te zijn de CoronaMelder te gaan gebruiken.  

```{r intentiontousenonusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot gebruik bij respondenten die de CoronaMelder nooit hebben gebruikt", tab.cap="Intentie tot gebruik bij respondenten die de CoronaMelder nooit hebben gebruikt"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("BI1a_UTAUT", 
                        "BI2a_UTAUT")
graph_questionlabels = c("Ik ben van plan de CoronaMelder in de komende 2 maanden te gebruiken", 
                         "Het is waarschijnlijk dat ik de CoronaMelder in de komende 2 maanden zal gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik heb de CoronaMelder app nooit gebruikt'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])


# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Van de respondenten die de CoronaMelder op dit moment al gebruiken, gaf een overgrote meerderheid (`r round((nrow(filter(data, (BI1b_UTAUT == 'Helemaal mee eens'| BI1b_UTAUT == 'Mee eens'| BI1b_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`%) aan van plan te zijn de CoronaMelder te blijven gebruiken in de komende 2 maanden (zie figuur \@ref(fig:intentiontousecurrentusers)). Een kleine hoeveelheid respondenten gaf aan hier neutraal in te staan (`r round((nrow(filter(data, (BI1b_UTAUT == 'Neutraal') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`%) Slechts `r round((nrow(filter(data, (BI1b_UTAUT == 'Helemaal mee oneens'| BI1b_UTAUT == 'Oneens'| BI1b_UTAUT == 'Een beetje oneens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`% gaf aan niet van plan te zijn de CoronaMelder te blijven gebruiken. 

```{r intentiontousecurrentusers, eval=TRUE, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot gebruik bij respondenten die de CoronaMelder op dit moment al gebruiken", tab.cap="Intentie tot gebruik bij respondenten die de CoronaMelder op dit moment al gebruiken"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("BI1b_UTAUT", 
                        "BI2b_UTAUT")
graph_questionlabels = c("Ik ben van plan de CoronaMelder in de komende 2 maanden te blijven gebruiken", 
                         "Het is waarschijnlijk dat ik de CoronaMelder de komende 2 maanden zal blijven gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


### Intentie tot (blijvend) gebruik CoronaMelder over de tijd
```{r ChisquareBI1aUtautovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$BI1a_UTAUT_agree_cw[(data_currentwave_wavemin1$BI1a_UTAUT_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$BI1a_UTAUT_cw == 'Mee eens'| data_currentwave_wavemin1$BI1a_UTAUT_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$BI1a_UTAUT_agree_cw[(data_currentwave_wavemin1$BI1a_UTAUT_cw == 'Neutraal'| data_currentwave_wavemin1$BI1a_UTAUT_cw == 'Een beetje oneens'| data_currentwave_wavemin1$BI1a_UTAUT_cw == 'Oneens'| data_currentwave_wavemin1$BI1a_UTAUT_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$BI1a_UTAUT_agree_wmin1[(data_currentwave_wavemin1$BI1a_UTAUT_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$BI1a_UTAUT_wmin1 == 'Mee eens'| data_currentwave_wavemin1$BI1a_UTAUT_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$BI1a_UTAUT_agree_wmin1[(data_currentwave_wavemin1$BI1a_UTAUT_wmin1 == 'Neutraal'| data_currentwave_wavemin1$BI1a_UTAUT_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$BI1a_UTAUT_wmin1 == 'Oneens'| data_currentwave_wavemin1$BI1a_UTAUT_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# THe following explanation holds for BI1a and BI1b: The fact that for some of the participants the user status changed between wave 1 and wave 2, we decided to perform a chi square in which we compare the proportion of Totaal eens_wmin1 versus Neutraal, niet mee eens_wmin1 for users of wave 1 with the proportion of Totaal eens_cw versus Neutraal, niet mee eens_cw for users of the current wave. For this we have to select, separately for each wave, the users (or non users). For these subsets we calculate counts with Totaal eens and Neutraal, etc. After that we concatenate these counts int a 2x2 table and perform a regular chi square on that.  
data_selected_cw = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik heb de CoronaMelder app nooit gebruikt", ]

data_selected_wmin1 = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik heb de CoronaMelder app nooit gebruikt", ]


# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$BI1a_UTAUT_agree_cw), table(data_selected_wmin1$BI1a_UTAUT_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```
Om te bepalen of de intentie tot (toekomstig) gebruik bij de niet gebruikers verschilt tussen de huidige en de vorige wave is een chi kwadraat uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave gebruikers waren en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin de gebruikersstatus in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage niet gebruikers in de huidige wave (`r round((nrow(filter(data_selected_cw, BI1a_UTAUT_agree_cw == 'Totaal eens_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij de CoronaMelder in de komende twee maanden gaat gebruiken vergeleken met het percentage niet gebruikers uit de vorige wave dat in de vorige wave aangaf het hiermee eens te zijn (`r round((nrow(filter(data_selected_wmin1, BI1a_UTAUT_agree_wmin1 == 'Totaal eens_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%). 

```{r, echo=FALSE, fig.width=5.5, fig.height=3.0, dpi = 300, fig.cap="Intentie tot gebruik over tijd bij respondenten die de CoronaMelder op dit moment niet gebruiken, totaal percentage dat minstens een beetje eens was met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("BI1a_UTAUT", 
                        "BI2a_UTAUT")
graph_questionlabels = c("Ik ben van plan de CoronaMelder in de komende 2 maanden te gebruiken", 
                         "Het is waarschijnlijk dat ik de CoronaMelder in de komende 2 maanden zal gebruiken"); 

include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```



```{r ChisquareBI1bUtautovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$BI1b_UTAUT_agree_cw[(data_currentwave_wavemin1$BI1b_UTAUT_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$BI1b_UTAUT_cw == 'Mee eens'| data_currentwave_wavemin1$BI1b_UTAUT_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$BI1b_UTAUT_agree_cw[(data_currentwave_wavemin1$BI1b_UTAUT_cw == 'Neutraal'| data_currentwave_wavemin1$BI1b_UTAUT_cw == 'Een beetje oneens'| data_currentwave_wavemin1$BI1b_UTAUT_cw == 'Oneens'| data_currentwave_wavemin1$BI1b_UTAUT_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$BI1b_UTAUT_agree_wmin1[(data_currentwave_wavemin1$BI1b_UTAUT_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$BI1b_UTAUT_wmin1 == 'Mee eens'| data_currentwave_wavemin1$BI1b_UTAUT_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$BI1b_UTAUT_agree_wmin1[(data_currentwave_wavemin1$BI1b_UTAUT_wmin1 == 'Neutraal'| data_currentwave_wavemin1$BI1b_UTAUT_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$BI1b_UTAUT_wmin1 == 'Oneens'| data_currentwave_wavemin1$BI1b_UTAUT_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# THe following explanation holds for BI1a and BI1b: The fact that for some of the participants the user status changed between wave 1 and wave 2, we decided to perform a chi square in which we compare the proportion of Totaal eens_wmin1 versus Neutraal, niet mee eens_wmin1 for users of wave 1 with the proportion of Totaal eens_cw versus Neutraal, niet mee eens_cw for users of the current wave. For this we have to select, separately for each wave, the users (or non users). For these subsets we calculate counts with Totaal eens and Neutraal, etc. After that we concatenate these counts int a 2x2 table and perform a regular chi square on that.  
data_selected_cw = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik gebruik de CoronaMelder app op dit moment", ]

data_selected_wmin1 = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik gebruik de CoronaMelder app op dit moment", ]

# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$BI1b_UTAUT_agree_cw), table(data_selected_wmin1$BI1b_UTAUT_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```
Om te bepalen of de intentie tot blijvend gebruik bij de gebruikers verschilt tussen de huidige en de vorige wave is een chi kwadraat uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave gebruikers waren en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin de gebruikersstatus in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers in de huidige wave (`r round((nrow(filter(data_selected_cw, BI1b_UTAUT_agree_cw == 'Totaal eens_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij de CoronaMelder in de komende twee maanden blijft gebruiken vergeleken met het percentage gebruikers uit de vorige wave dat in de vorige wave aangaf het hiermee eens te zijn (`r round((nrow(filter(data_selected_wmin1, BI1b_UTAUT_agree_wmin1 == 'Totaal eens_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%). 


```{r, echo=FALSE, fig.width=5.5, fig.height=3.0, dpi = 300, fig.cap="Intentie tot gebruik over tijd bij respondenten die de CoronaMelder op dit moment gebruiken, totaal percentage dat het minstens een beetje eens was met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("BI1b_UTAUT", 
                        "BI2b_UTAUT")
graph_questionlabels = c("Ik ben van plan de CoronaMelder in de komende 2 maanden te blijven gebruiken", 
                         "Het is waarschijnlijk dat ik de CoronaMelder de komende 2 maanden zal blijven gebruiken"); 

include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

## Vergelijking gebruikers en niet gebruikers
### Demografische gegevens naar gebruikersstatus {#demouserstatus}
Om inzicht te krijgen in welke factoren (demografisch, persoonlijk, sociaal, omgevingsfactoren) samenhangen met het gebruiken van de CoronaMelder worden respondenten die momenteel de CoronaMelder gebruiken vergeleken met de respondenten die de CoronaMelder nooit hebben gebruikt. 

Om dit te onderzoeken wordt voor elke demografische variabele een chi kwadraat toets uitgevoerd. In het geval dat deze toets aangeeft dat de demografische variabele en de gebruikersstatus afhankelijk zijn - oftewel dat een of meerdere van de subgroepen afwijken van het gemiddelde percentage gebruikers - worden er posthoc paarsgewijze chi kwadraattests met FDR-correctie uitgevoerd om te bepalen welke groepen significant van elkaar verschillen in percentage gebruikers. In de onderstaande tabel kunnen de resultaten gevonden worden. In de appendix kunnen alle paarsgewijze vergelijkingen gevonden worden voor variabelen die samenhingen met de gebruikersstatus. 

Demografische variabelen die niet samenhingen met gebruik waren geslacht, leeftijd, de stedelijkheid van de woonplaats, de dagelijkse bezigheid (bv. loondienst, pensioen), de burgerlijke staat en de woonvorm van het huishouden (bv. alleen wonend of met kinderen). 

Voor de volgende demografische kenmerken was er wel een afhankelijkheid: het percentage gebruikers was niet gelijk verdeeld over de verschillende opleidingsniveaus. Bij de hoger opgeleiden (wo) was het percentage gebruikers het hoogst. Bij mensen die alleen basisonderwijs of vmbo hebben gevolgd was dit percentage het laagst. Ook netto maandkomen hing samen met gebruik: mensen die maandelijks meer dan 3501 euro netto verdienen gebruiken de CoronaMelder het vaakst. 


```{r demobyuserstatus, echo=FALSE, results="asis", tab.cap = "Demografische kenmerken naar gebruikersstatus"} 
tab.noby <- tableby(user_status ~ geslacht + lftdcat + sted_simplified + belbezig_simplified  + oplmet_simplified + burgstat_simplified + nettocat_simplified + woonvorm, cat.stats = "countrowpct", data=data_currentvsneveruser) # cat.stats = "countrowpct") for row percentages in stead of column percentages
summary(tab.noby, title="(\\#tab:mytableby2) Demografische kenmerken naar gebruikersstatus")
```

### Gezondheidsmotivatie en risicoperceptie naar gebruikersstatus
Chi kwadraat toetsen zijn uitgevoerd om te bepalen of het totaal aandeel respondenten dat het eens  (een beetje, eens, helemaal mee eens) is met de stellingen die betrekking hebben op gezondheidsmotivatie en risicoperceptie verschilt tussen de huidige gebruikers en degenen die de CoronaMelder nooit gebruikt hebben.  
```{r chiHBMsuscself1usernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$HBM_PSus_self1_agree[(data$HBM_PSus_self1 == 'Helemaal mee eens'| data$HBM_PSus_self1 == 'Mee eens'| data$HBM_PSus_self1 == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_PSus_self1_agree[(data$HBM_PSus_self1 == 'Neutraal'| data$HBM_PSus_self1 == 'Een beetje oneens'| data$HBM_PSus_self1 == 'Oneens'| data$HBM_PSus_self1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_PSus_self1_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& HBM_PSus_self1_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat men in komende twee maanden een risico op een besmetting met het coronavirus loopt vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & HBM_PSus_self1_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  


```{r chiPHBMPsusother2utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$HBM_PSus_other2_agree[(data$HBM_PSus_other2 == 'Helemaal mee eens'| data$HBM_PSus_other2 == 'Mee eens'| data$HBM_PSus_other2 == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_PSus_other2_agree[(data$HBM_PSus_other2 == 'Neutraal'| data$HBM_PSus_other2 == 'Een beetje oneens'| data$HBM_PSus_other2 == 'Oneens'| data$HBM_PSus_other2 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_PSus_other2_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& HBM_PSus_other2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat de kans groot zou zijn dat diegene anderen zal besmetten indien hij/zij zelf besmet zou zijn, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & HBM_PSus_other2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiHBMsevcself1usernonuser, echo=FALSE}
# First calculate a proportion for the variable.
data$HBM_PSev_self1_agree[(data$HBM_PSev_self1 == 'Helemaal mee eens'| data$HBM_PSev_self1 == 'Mee eens'| data$HBM_PSev_self1 == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_PSus_PSev_agree[(data$HBM_PSev_self1 == 'Neutraal'| data$HBM_PSev_self1 == 'Een beetje oneens'| data$HBM_PSev_self1 == 'Oneens'| data$HBM_PSev_self1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_PSev_self1_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& HBM_PSev_self1_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij het erg zou vinden om besmet te raken met het coronavirus vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & HBM_PSev_self1_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiPHBMPsevother2utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$HBM_PSev_other2_agree[(data$HBM_PSev_other2 == 'Helemaal mee eens'| data$HBM_PSev_other2 == 'Mee eens'| data$HBM_PSev_other2 == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_PSev_other2_agree[(data$HBM_PSev_other2 == 'Neutraal'| data$HBM_PSev_other2 == 'Een beetje oneens'| data$HBM_PSev_other2 == 'Oneens'| data$HBM_PSev_other2 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_PSev_other2_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& HBM_PSev_other2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij het erg zou vinden om andere mensen te besmetten met het coronavirus vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & HBM_PSev_other2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r, echo=FALSE, tab.cap ="Ernst en vatbaarheid coronavirus naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_PSus_self1", 
                        "HBM_PSus_other2", 
                        "HBM_PSev_self1", 
                        "HBM_PSev_other2")                     
graph_questionlabels = c("Ik loop in de komende twee maanden risico op een besmetting met het coronavirus", 
                         "Als ik besmet raak met het coronavirus is de kans groot dat ik anderen zal besmetten", 
                         "Ik vind het erg om besmet te raken met het coronavirus", 
                         "Ik vind het erg als ik andere mensen besmet met het coronavirus") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))

  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Voormalig gebruiker"))
  
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```
In onderstaande tabellen is te zien hoe deze percentages opgebouwd zijn voor deze vier vragen, voor huidige gebruikers en niet gebruikers. 

```{r, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Waargenomen ernst en vatbaarheid - Gebruikers", tab.cap="Waargenomen ernst en vatbaarheid - Gebruikers"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_PSus_self1", 
                        "HBM_PSus_other2", 
                        "HBM_PSev_self1", 
                        "HBM_PSev_other2")
graph_questionlabels = c("Ik loop in de komende twee maanden risico op een besmetting met het coronavirus", 
                         "Als ik besmet raak is de kans  groot dat ik anderen zal besmetten", 
                         "Ik vind het erg om besmet te raken", 
                         "Ik vind het erg als ik andere mensen besmet"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])


```

```{r perceivedsuscsev, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Waargenomen ernst en vatbaarheid - Niet gebruikers", tab.cap="Waargenomen ernst en vatbaarheid - Niet gebruikers"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_PSus_self1", 
                        "HBM_PSus_other2", 
                        "HBM_PSev_self1", 
                        "HBM_PSev_other2")
graph_questionlabels = c("Ik loop in de komende twee maanden risico op een besmetting met het coronavirus", 
                         "Als ik besmet raak is de kans  groot dat ik anderen zal besmetten", 
                         "Ik vind het erg om besmet te raken", 
                         "Ik vind het erg als ik andere mensen besmet"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik heb de CoronaMelder app nooit gebruikt'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])


```

  
### Naleving en intentie tot naleving algemene gedragsregels naar gebruikersstatus
Relevant om te weten is of de mensen die de CoronaMelder momenteel gebruiken, mensen zijn die zich in het algemeen al beter aan de gedragsregels houden. 

Chi kwadraat toetsen zijn uitgevoerd om te bepalen of het totaal aandeel respondenten dat het eens  (een beetje, eens, helemaal mee eens) is met de stellingen verschilt tussen de huidige gebruikers en degenen die de CoronaMelder nooit gebruikt hebben.  

```{r chiintentionhandwashingusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Intention_AdherenceGeneralMeasures_handwashing_agree[(data$Intention_AdherenceGeneralMeasures_handwashing == 'Helemaal mee eens'| data$Intention_AdherenceGeneralMeasures_handwashing == 'Mee eens'| data$Intention_AdherenceGeneralMeasures_handwashing == 'Een beetje mee eens')] <- "Totaal eens"
data$Intention_AdherenceGeneralMeasures_handwashing_agree[(data$Intention_AdherenceGeneralMeasures_handwashing == 'Neutraal'| data$Intention_AdherenceGeneralMeasures_handwashing == 'Een beetje oneens'| data$Intention_AdherenceGeneralMeasures_handwashing == 'Oneens'| data$Intention_AdherenceGeneralMeasures_handwashing == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Intention_AdherenceGeneralMeasures_handwashing_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Intention_AdherenceGeneralMeasures_handwashing_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf de intentie te hebben om handen regelmatig te wassen vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Intention_AdherenceGeneralMeasures_handwashing_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chibehaviorhandwashingusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Behavior_AdherenceGeneralMeasures_handwashing_agree[(data$Behavior_AdherenceGeneralMeasures_handwashing == 'Vaak'| data$Behavior_AdherenceGeneralMeasures_handwashing == 'Meestal'| data$Behavior_AdherenceGeneralMeasures_handwashing == 'Altijd')] <- "Totaal eens"
data$Behavior_AdherenceGeneralMeasures_handwashing_agree[(data$Behavior_AdherenceGeneralMeasures_handwashing == 'Nooit'| data$Behavior_AdherenceGeneralMeasures_handwashing == 'Zelden'| data$Behavior_AdherenceGeneralMeasures_handwashing == 'Soms'| data$Behavior_AdherenceGeneralMeasures_handwashing == 'Regelmatig')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Behavior_AdherenceGeneralMeasures_handwashing_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Behavior_AdherenceGeneralMeasures_handwashing_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf vaak, meestal of altijd de handen te wassen met water en zeep vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Behavior_AdherenceGeneralMeasures_handwashing_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  


```{r chiintentiondistancingusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Intention_AdherenceGeneralMeasures_distance_agree[(data$Intention_AdherenceGeneralMeasures_distance == 'Helemaal mee eens'| data$Intention_AdherenceGeneralMeasures_distance == 'Mee eens'| data$Intention_AdherenceGeneralMeasures_distance == 'Een beetje mee eens')] <- "Totaal eens"
data$Intention_AdherenceGeneralMeasures_distance_agree[(data$Intention_AdherenceGeneralMeasures_distance == 'Neutraal'| data$Intention_AdherenceGeneralMeasures_distance == 'Een beetje oneens'| data$Intention_AdherenceGeneralMeasures_distance == 'Oneens'| data$Intention_AdherenceGeneralMeasures_distance == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Intention_AdherenceGeneralMeasures_distance_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Intention_AdherenceGeneralMeasures_distance_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf de intentie te hebben om 1.5 meter afstand te houden van mensen buiten hun huishouden vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Intention_AdherenceGeneralMeasures_distance_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chibehaviordistancingusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Behavior_AdherenceGeneralMeasures_distance_agree[(data$Behavior_AdherenceGeneralMeasures_distance == 'Vaak'| data$Behavior_AdherenceGeneralMeasures_distance == 'Meestal'| data$Behavior_AdherenceGeneralMeasures_distance == 'Altijd')] <- "Totaal eens"
data$Behavior_AdherenceGeneralMeasures_distance_agree[(data$Behavior_AdherenceGeneralMeasures_distance == 'Nooit'| data$Behavior_AdherenceGeneralMeasures_distance == 'Zelden'| data$Behavior_AdherenceGeneralMeasures_distance == 'Soms'| data$Behavior_AdherenceGeneralMeasures_distance == 'Regelmatig')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Behavior_AdherenceGeneralMeasures_distance_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Behavior_AdherenceGeneralMeasures_distance_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf vaak, meestal of altijd 1.5 meter afstand te houden van mensen buiten hun huishouden vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Behavior_AdherenceGeneralMeasures_distance_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiintentionbusyusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree[(data$Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Helemaal mee eens'| data$Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Mee eens'| data$Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Een beetje mee eens')] <- "Totaal eens"
data$Intention_Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree[(data$Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Neutraal'| data$Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Een beetje oneens'| data$Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Oneens'| data$Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf de intentie te hebben om drukke plekken te vermijden vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chibehaviorbusyusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree[(data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Vaak'| data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Meestal'| data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Altijd')] <- "Totaal eens"
data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree[(data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Nooit'| data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Zelden'| data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Soms'| data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Regelmatig')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf vaak, meestal of altijd op plekken te zijn geweest die eigenlijk te druk waren om 1.5 meter afstand te houden, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  


```{r chiIntentionadherencequarantaine, echo=FALSE}
# First calculate a proportion for the variable. 
data$Intention_AdherenceGeneralMeasures_quarantaine_agree[(data$Intention_AdherenceGeneralMeasures_quarantaine == 'Helemaal mee eens'| data$Intention_AdherenceGeneralMeasures_quarantaine == 'Mee eens'| data$Intention_AdherenceGeneralMeasures_quarantaine == 'Een beetje mee eens')] <- "Totaal eens"
data$Intention_AdherenceGeneralMeasures_quarantaine_agree[(data$Intention_AdherenceGeneralMeasures_quarantaine == 'Neutraal'| data$Intention_AdherenceGeneralMeasures_quarantaine == 'Een beetje oneens'| data$Intention_AdherenceGeneralMeasures_quarantaine == 'Oneens'| data$Intention_AdherenceGeneralMeasures_quarantaine == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Intention_AdherenceGeneralMeasures_quarantaine_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Intention_AdherenceGeneralMeasures_quarantaine_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf intentie te hebben om in quarantaine te gaan in geval van klachten vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Intention_AdherenceGeneralMeasures_quarantaine_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiIntentionadherencetestwsymptoms, echo=FALSE}
# First calculate a proportion for the variable. 
data$Intention_AdherenceGeneralMeasures_testwithsymptoms_agree[(data$Intention_AdherenceGeneralMeasures_testwithsymptoms == 'Helemaal mee eens'| data$Intention_AdherenceGeneralMeasures_testwithsymptoms == 'Mee eens'| data$Intention_AdherenceGeneralMeasures_testwithsymptoms == 'Een beetje mee eens')] <- "Totaal eens"
data$Intention_AdherenceGeneralMeasures_testwithsymptoms_agree[(data$Intention_AdherenceGeneralMeasures_testwithsymptoms == 'Neutraal'| data$Intention_AdherenceGeneralMeasures_testwithsymptoms == 'Een beetje oneens'| data$Intention_AdherenceGeneralMeasures_testwithsymptoms == 'Oneens'| data$Intention_AdherenceGeneralMeasures_testwithsymptoms == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Intention_AdherenceGeneralMeasures_testwithsymptoms_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Intention_AdherenceGeneralMeasures_testwithsymptoms_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf intentie te hebben om zich te laten testen op het coronavirus in geval van klachten vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Intention_AdherenceGeneralMeasures_testwithsymptoms_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  


```{r, echo=FALSE, tab.cap = "Intentie tot houden aan algemene gedragsadviezen naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens) per gedragsadvies. Ik ben van plan om de komende 2 maanden ..."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_AdherenceGeneralMeasures_handwashing", 
                        "Intention_AdherenceGeneralMeasures_distance",
                        "Intention_AdherenceGeneralMeasures_avoidbusyplaces",
                        "Intention_AdherenceGeneralMeasures_quarantaine", 
                        "Intention_AdherenceGeneralMeasures_testwithsymptoms"
                        )                     
graph_questionlabels = c("... mijn handen regelmatig te wassen", 
                         "... 1,5 meter afstand te houden van mensen buiten mijn huishouden",
                         "... drukke plekken te vermijden", 
                         "... thuis te blijven als ik last heb van klachten die passen bij het coronavirus", 
                         "... een coronatest te doen als ik last heb van klachten die passen bij het coronavirus"
                         ) 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))

  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Voormalig gebruiker"))
    
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```


```{r, echo=FALSE, tab.cap = "Zelfgerapporteerde naleving algemene gedragsadviezen naar gebruikersstatus. Aantal en totaal percentage hoogfrequent (vaak, meestal en altijd) per gedragsadvies. In de afgelopen 2 maanden, hoe vaak ..."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Behavior_AdherenceGeneralMeasures_handwashing", 
                        "Behavior_AdherenceGeneralMeasures_distance",
                        "Behavior_AdherenceGeneralMeasures_avoidbusyplaces"
                        )                     
graph_questionlabels = c("... hebt u uw handen gewassen met water en zeep?", 
                         "... bent u minder dan op 1,5 meter afstand geweest van mensen buiten uw huishouden?",
                         "... bent u op een plek geweest waar het eigenlijk te druk was om de 1,5 meter afstand te houden?"
                         ) 

# Which values do we want to include in the table cells?
include_vars = c("Vaak", "Meestal", "Altijd")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))

  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Voormalig gebruiker"))
    
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```

### Algemene opvattingen over het coronavirus naar gebruikersstatus
Chi kwadraat toetsen zijn uitgevoerd om te bepalen of het totaal aandeel respondenten die denkt dat de stelling waar is (*zeker waar* en *misschien waar*) verschilt tussen de huidige gebruikers en degenen die de CoronaMelder nooit gebruikt hebben.  

#### Complottheorieën naar gebruikersstatus

```{r chiconspiracy1usernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_Conspiracy1_agree[data$Beliefs_Conspiracy1 == 'Zeker waar'| data$Beliefs_Conspiracy1 == 'Misschien waar'] <- "Totaal waar"
data$Beliefs_Conspiracy1_agree[data$Beliefs_Conspiracy1 == 'Weet ik niet'| data$Beliefs_Conspiracy1 == 'Misschien niet waar'| data$Beliefs_Conspiracy1 == 'Zeker niet waar'] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_Conspiracy1_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_Conspiracy1_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf dat het waar is dat het coronavirus een biologisch wapen is dat in een laboratorium is gemaakt, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_Conspiracy1_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiconspiracy2usernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_Conspiracy2_agree[data$Beliefs_Conspiracy2 == 'Zeker waar'| data$Beliefs_Conspiracy2 == 'Misschien waar'] <- "Totaal waar"
data$Beliefs_Conspiracy2_agree[data$Beliefs_Conspiracy2 == 'Weet ik niet'| data$Beliefs_Conspiracy2 == 'Misschien niet waar'| data$Beliefs_Conspiracy2 == 'Zeker niet waar'] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_Conspiracy2_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_Conspiracy2_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf dat het waar is dat de uitbraak van het coronavirus heeft te maken met het 5G netwerk, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_Conspiracy2_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r, echo=FALSE, tab.cap ="Geloof in complottheorieën. Aantal en totaal percentage dat overtuigd is dat de stelling waar is (zeker waar, misschien waar)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_Conspiracy1", 
                        "Beliefs_Conspiracy2")                     
graph_questionlabels = c("Het coronavirus is een biologisch wapen dat in een laboratorium is gemaakt", 
                         "De uitbraak van het coronavirus heeft te maken met (de aanleg van) het 5G netwerk") 

# Which values do we want to include in the table cells?
include_vars = c("Zeker waar", "Misschien waar")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))

  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Voormalig gebruiker"))
    
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```

#### Vertrouwen in de overheid naar gebruikersstatus
```{r chiPBeliefsTrustGovernmentusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_TrustGovernment_agree[(data$Beliefs_TrustGovernment == 'Helemaal mee eens'| data$Beliefs_TrustGovernment == 'Mee eens'| data$Beliefs_TrustGovernment == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_TrustGovernment_agree[(data$Beliefs_TrustGovernment == 'Neutraal'| data$Beliefs_TrustGovernment == 'Een beetje oneens'| data$Beliefs_TrustGovernment == 'Oneens'| data$Beliefs_TrustGovernment == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_TrustGovernment_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_TrustGovernment_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat ze vertrouwen hebben in de aanpak van de Nederlandse overheid om het coronavirus onder controle te krijgen, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_TrustGovernment_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r, echo=FALSE, tab.cap ="Vertrouwen in aanpak overheid naar gebruikersstatus. Aantal en totaal percentage dat het eens is met de stelling (helemaal mee eens, mee eens, een beetje mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_TrustGovernment")                     
graph_questionlabels = c("Ik heb vertrouwen in de manier waarop de Nederlandse overheid probeert het coronavirus onder controle te houden") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Voormalig gebruiker"))
  
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```

## Verklarende variabelen voor adoptie
### Verwachte effectiviteit CoronaMelder in bestrijding coronavirus
In kaart is gebracht in welke mate men denkt dat de CoronaMelder bijdraagt aan de bestrijding van het coronavirus. In totaal gaf `r round((nrow(filter(data, (PE1_UTAUT == 'Helemaal mee eens'| PE1_UTAUT == 'Mee eens'| PE1_UTAUT == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan het eens te zijn met de stelling dat men door het gebruiken van de CoronaMelder bijdraagt aan de bestrijding van het coronavirus. Daarnaast gaf `r round((nrow(filter(data, (PE2_UTAUT == 'Helemaal mee eens'| PE2_UTAUT == 'Mee eens'| PE2_UTAUT == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan dat de CoronaMelder nuttig is om ervoor te zorgen dat het coronavirus zich minder verspreidt en geeft `r round((nrow(filter(data, (Beliefs_Protectriskgroups == 'Helemaal mee eens'| Beliefs_Protectriskgroups == 'Mee eens'| Beliefs_Protectriskgroups == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan dat de CoronaMelder helpt om mensen met een kwetsbare gezondheid te beschermen. 

```{r, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Verwachte effectiviteit CoronaMelder", tab.cap="Verwachte effectiviteit CoronaMelder"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("PE1_UTAUT", 
                        "PE2_UTAUT", 
                        "Beliefs_Protectriskgroups")
graph_questionlabels = c("Door de CoronaMelder app te gebruiken help ik mee bij de bestrijding van het coronavirus", 
                         "De CoronaMelder app is nuttig om ervoor te zorgen dat het coronavirus zich minder verspreidt", 
                         "De CoronaMelder app helpt om mensen met een kwetsbare gezondheid te beschermen") 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Er is ook gevraagd hoeveel procent van de Nederlandse bevolking volgens de respondent de CoronaMelder app zou moeten gebruiken om de verspreiding van het coronavirus tegen te gaan. De meeste respondenten (`r round(nrow(filter(data, Beliefs_ResponseefficasyOther == '76-90%'))/nrow(data)*100, digits = 1)`%) dachten dat 76-90% van de Nederlandse bevolking de CoronaMelder moet gebruiken om de verspreiding van het coronavirus tegen te gaan. In totaal dacht `r round(((nrow(filter(data, Beliefs_ResponseefficasyOther == '51-75%')) + nrow(filter(data, Beliefs_ResponseefficasyOther == '76-90%')) + nrow(filter(data, Beliefs_ResponseefficasyOther == '91-100%')))/nrow(data)*100), digits = 1)`% van de respondenten dat meer dan 50% van de Nederlandse bevolking de CoronaMelder app moet gebruiken om effectief te zijn. Het aandeel respondenten dat aan gaf niet te weten hoeveel mensen de CoronaMelder app zouden moeten gebruiken is `r round(nrow(filter(data, Beliefs_ResponseefficasyOther == 'Weet ik niet'))/nrow(data)*100, digits = 1)`%. 

```{r, echo=FALSE, fig.width=5.5, fig.height=3, fig.cap="Percentage van Nederlandse bevolking dat de CoronaMelder moet gebruiken om verspreiding van het virus tegen te gaan", tab.cap="Percentage van Nederlandse bevolking dat de CoronaMelder moet gebruiken om verspreiding van het virus tegen te gaan"}
# Beliefs_ResponseefficasyOther
ggplot(data=data, aes(x = Beliefs_ResponseefficasyOther)) +
  theme_bw() +
  xlab(paste(names(table(data$Beliefs_ResponseefficasyOther)))) + 
  ylab(" ") + 
  xlab(" ") + 
  geom_bar(fill = "#bdd7e7", color = "#6baed6") + 
  theme(plot.margin = margin(0, 0.1, 0, 0)) + 
  theme(axis.title=element_text(size=10))

graph_variablenames = "Beliefs_ResponseefficasyOther"
graph_questionlabels = "Hoeveel procent van de Nederlandse bevolking zou volgens u de CoronaMelder app moeten gebruiken om de verspreiding van het coronavirus tegen te gaan?"

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Verwachte effectiviteit CoronaMelder naar gebruikersstatus

Om te onderzoeken of de verwachte effectiviteit een rol speelt in adoptie, is gekeken of er verschillen waren in verwachte effectiviteit naar gebruikersstatus. 
```{r chiPE1utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$PE1_UTAUT_agree[(data$PE1_UTAUT == 'Helemaal mee eens'| data$PE1_UTAUT == 'Mee eens'| data$PE1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$PE1_UTAUT_agree[(data$PE1_UTAUT == 'Neutraal'| data$PE1_UTAUT == 'Een beetje oneens'| data$PE1_UTAUT == 'Oneens'| data$PE1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$PE1_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& PE1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat, door de CoronaMelder te gebruiken, men bijdraagt aan de bestrijding van het coronavirus, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & PE1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  
```{r chiPE1utautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$PE1_UTAUT_agree[(data$PE1_UTAUT == 'Helemaal mee eens'| data$PE1_UTAUT == 'Mee eens'| data$PE1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$PE1_UTAUT_agree[(data$PE1_UTAUT == 'Neutraal'| data$PE1_UTAUT == 'Een beetje oneens'| data$PE1_UTAUT == 'Oneens'| data$PE1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$PE1_UTAUT_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& PE1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat, door de CoronaMelder te gebruiken, men bijdraagt aan de bestrijding van het coronavirus, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & PE1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 
```{r chiPE2utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$PE2_UTAUT_agree[(data$PE2_UTAUT == 'Helemaal mee eens'| data$PE2_UTAUT == 'Mee eens'| data$PE2_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$PE2_UTAUT_agree[(data$PE2_UTAUT == 'Neutraal'| data$PE2_UTAUT == 'Een beetje oneens'| data$PE2_UTAUT == 'Oneens'| data$PE2_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$PE2_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& PE2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat de CoronaMelder nuttig is om ervoor te zorgen dat het coronavirus zich minder verspreidt, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & PE2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  
```{r chiPE2utautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$PE2_UTAUT_agree[(data$PE2_UTAUT == 'Helemaal mee eens'| data$PE2_UTAUT == 'Mee eens'| data$PE2_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$PE2_UTAUT_agree[(data$PE2_UTAUT == 'Neutraal'| data$PE2_UTAUT == 'Een beetje oneens'| data$PE2_UTAUT == 'Oneens'| data$PE2_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$PE2_UTAUT_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& PE2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat de CoronaMelder nuttig is om ervoor te zorgen dat het coronavirus zich minder verspreidt, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & PE2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 
```{r chiBeliefsprotectriskgroupsusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_Protectriskgroups_agree[(data$Beliefs_Protectriskgroups == 'Helemaal mee eens'| data$Beliefs_Protectriskgroups == 'Mee eens'| data$Beliefs_Protectriskgroups == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_Protectriskgroups_agree[(data$Beliefs_Protectriskgroups == 'Neutraal'| data$Beliefs_Protectriskgroups == 'Een beetje oneens'| data$Beliefs_Protectriskgroups == 'Oneens'| data$Beliefs_Protectriskgroups == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_Protectriskgroups_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_Protectriskgroups_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat de CoronaMelder helpt om mensen met een kwetsbare gezondheid te beschermen, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_Protectriskgroups_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).
```{r chiBeliefsprotectriskgroupsusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_Protectriskgroups_agree[(data$Beliefs_Protectriskgroups == 'Helemaal mee eens'| data$Beliefs_Protectriskgroups == 'Mee eens'| data$Beliefs_Protectriskgroups == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_Protectriskgroups_agree[(data$Beliefs_Protectriskgroups == 'Neutraal'| data$Beliefs_Protectriskgroups == 'Een beetje oneens'| data$Beliefs_Protectriskgroups == 'Oneens'| data$Beliefs_Protectriskgroups == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_Protectriskgroups_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& Beliefs_Protectriskgroups_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat de CoronaMelder helpt om mensen met een kwetsbare gezondheid te beschermen, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_Protectriskgroups_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r, echo=FALSE, tab.cap = "Verwachte effectiviteit CoronaMelder naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("PE1_UTAUT", 
                        "PE2_UTAUT", 
                        "Beliefs_Protectriskgroups")
graph_questionlabels = c("Door de CoronaMelder app te gebruiken help ik mee bij de bestrijding van het coronavirus", 
                         "De CoronaMelder app is nuttig om ervoor te zorgen dat het coronavirus zich minder verspreidt", 
                         "De CoronaMelder app helpt om mensen met een kwetsbare gezondheid te beschermen") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))

  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Voormalig gebruiker"))
    
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```

#### Verwachte effectiviteit CoronaMelder over de tijd
```{r McNemarPE1utautovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$PE1_UTAUT_agree_cw[(data_currentwave_wavemin1$PE1_UTAUT_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$PE1_UTAUT_cw == 'Mee eens'| data_currentwave_wavemin1$PE1_UTAUT_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$PE1_UTAUT_agree_cw[(data_currentwave_wavemin1$PE1_UTAUT_cw == 'Neutraal'| data_currentwave_wavemin1$PE1_UTAUT_cw == 'Een beetje oneens'| data_currentwave_wavemin1$PE1_UTAUT_cw == 'Oneens'| data_currentwave_wavemin1$PE1_UTAUT_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$PE1_UTAUT_agree_wmin1[(data_currentwave_wavemin1$PE1_UTAUT_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$PE1_UTAUT_wmin1 == 'Mee eens'| data_currentwave_wavemin1$PE1_UTAUT_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$PE1_UTAUT_agree_wmin1[(data_currentwave_wavemin1$PE1_UTAUT_wmin1 == 'Neutraal'| data_currentwave_wavemin1$PE1_UTAUT_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$PE1_UTAUT_wmin1 == 'Oneens'| data_currentwave_wavemin1$PE1_UTAUT_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$PE1_UTAUT_agree_cw, data_currentwave_wavemin1$PE1_UTAUT_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (PE1_UTAUT_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (PE1_UTAUT_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat men door de CoronaMelder te gebruiken meehelpt bij de bestrijding van het coronavirus.
```{r McNemarPE2utautovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$PE2_UTAUT_agree_cw[(data_currentwave_wavemin1$PE2_UTAUT_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$PE2_UTAUT_cw == 'Mee eens'| data_currentwave_wavemin1$PE2_UTAUT_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$PE2_UTAUT_agree_cw[(data_currentwave_wavemin1$PE2_UTAUT_cw == 'Neutraal'| data_currentwave_wavemin1$PE2_UTAUT_cw == 'Een beetje oneens'| data_currentwave_wavemin1$PE2_UTAUT_cw == 'Oneens'| data_currentwave_wavemin1$PE2_UTAUT_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$PE2_UTAUT_agree_wmin1[(data_currentwave_wavemin1$PE2_UTAUT_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$PE2_UTAUT_wmin1 == 'Mee eens'| data_currentwave_wavemin1$PE2_UTAUT_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$PE2_UTAUT_agree_wmin1[(data_currentwave_wavemin1$PE2_UTAUT_wmin1 == 'Neutraal'| data_currentwave_wavemin1$PE2_UTAUT_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$PE2_UTAUT_wmin1 == 'Oneens'| data_currentwave_wavemin1$PE2_UTAUT_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$PE2_UTAUT_agree_cw, data_currentwave_wavemin1$PE2_UTAUT_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (PE2_UTAUT_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (PE2_UTAUT_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat de CoronaMelder nuttig is om ervoor te zorgen dat het coronavirus zich minder verspreidt.
```{r McNemarbeliefsprotectriskgroupsovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_Protectriskgroups_agree_cw[(data_currentwave_wavemin1$Beliefs_Protectriskgroups_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_Protectriskgroups_cw == 'Mee eens'| data_currentwave_wavemin1$Beliefs_Protectriskgroups_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Beliefs_Protectriskgroups_agree_cw[(data_currentwave_wavemin1$Beliefs_Protectriskgroups_cw == 'Neutraal'| data_currentwave_wavemin1$Beliefs_Protectriskgroups_cw == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_Protectriskgroups_cw == 'Oneens'| data_currentwave_wavemin1$Beliefs_Protectriskgroups_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_Protectriskgroups_agree_wmin1[(data_currentwave_wavemin1$Beliefs_Protectriskgroups_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_Protectriskgroups_wmin1 == 'Mee eens'| data_currentwave_wavemin1$Beliefs_Protectriskgroups_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Beliefs_Protectriskgroups_agree_wmin1[(data_currentwave_wavemin1$Beliefs_Protectriskgroups_wmin1 == 'Neutraal'| data_currentwave_wavemin1$Beliefs_Protectriskgroups_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_Protectriskgroups_wmin1 == 'Oneens'| data_currentwave_wavemin1$Beliefs_Protectriskgroups_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_Protectriskgroups_agree_cw, data_currentwave_wavemin1$Beliefs_Protectriskgroups_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_Protectriskgroups_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_Protectriskgroups_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat de CoronaMelder helpt bij het beschermen van de mensen met een kwetsbare gezondheid.

```{r, echo=FALSE, fig.width=5.5, fig.height=3, dpi = 300, fig.cap="Verwachte effectiviteit CoronaMelder over de tijd, totaal percentage dat minstens een beetje eens was met de stelling (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("PE1_UTAUT", 
                        "PE2_UTAUT", 
                        "Beliefs_Protectriskgroups")
graph_questionlabels = c("Door de CoronaMelder app te gebruiken help ik mee bij de bestrijding van het coronavirus", 
                         "De CoronaMelder app is nuttig om ervoor te zorgen dat het coronavirus zich minder verspreidt", 
                         "De CoronaMelder app helpt om mensen met een kwetsbare gezondheid te beschermen") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```


### CoronaMelder in de media
Er is gekeken of men gemerkt heeft dat de CoronaMelder in de media en/of het nieuws voorbij is gekomen, en wat de toon van deze berichten was. In totaal gaf `r round((nrow(filter(data, (Media == 'Vaak'| Media == 'Soms'| Media == 'Af en toe'))) /nrow(data))*100, digits = 1)`% aan dat de CoronaMelder af en toe, soms of vaak in de media en/of het nieuws voorbij was gekomen. 

```{r, echo=FALSE, fig.width=7, fig.height=2, fig.cap="CoronaMelder in de media", tab.cap="CoronaMelder in de media"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Media")
graph_questionlabels = c("Hoe vaak hebt u de CoronaMelder voorbij zien komen in de media en/of het nieuws in de afgelopen maand?") 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Vaak", "Soms", "Af en toe", "Nooit"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Daarnaast is aan de respondenten (`r nrow(filter(data, (Media == 'Vaak'| Media == 'Soms'| Media == 'Af en toe')))`) die de in voorgaande vraag aangaven de CoronaMelder af en toe, soms of vaak voorbij te hebben zien gekomen in de media en/of nieuws ook gevraagd naar de toon van de berichtgeving over de CoronaMelder. Hierbij gaf `r round((nrow(filter(data, (MediaValence == 'Heel erg positief'| MediaValence == 'Positief'| MediaValence == 'Een beetje positief'))) /nrow(filter(data, (Media == 'Vaak'| Media == 'Soms'| Media == 'Af en toe'))))*100, digits = 1)`% aan dat deze berichten in de media over het algemeen positief van toon waren. In totaal gaf `r round((nrow(filter(data, (MediaValence == 'Heel erg negatief'| MediaValence == 'Negatief'| MediaValence == 'Een beetje negatief'))) /nrow(filter(data, (Media == 'Vaak'| Media == 'Soms'| Media == 'Af en toe'))))*100, digits = 1)`% aan dat de berichten negatief van toon waren. 

```{r, echo=FALSE, fig.width=7, fig.height=2.5, fig.cap="Toon van mediaberichten over de CoronaMelder", tab.cap="Toon van mediaberichten over de CoronaMelder"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("MediaValence")
graph_questionlabels = c("Waren deze berichten/items over het algemeen negatief of positief van toon?") 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette8blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Heel erg positief", "Positief", "Een beetje positief", "Neutraal", "Een beetje negatief", "Negatief", "Heel erg negatief"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
# NOTE: Filtering out NAs here
data_graph_wideformat = select(data[data$Media != "Nooit" & data$Media != "Weet ik niet",], nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### CoronaMelder in de media naar gebruikersstatus

Om te onderzoeken of de media-aandacht een rol speelt in adoptie, is gekeken of er verschillen waren in media-aandacht en toon van berichten naar gebruikersstatus. 
```{r chiMediausernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Media_agree[(data$Media == 'Vaak'| data$Media == 'Soms'| data$Media == 'Af en toe')] <- "Gezien"
data$Media_agree[(data$Media == 'Nooit'| data$Media == 'Weet ik niet')] <- "Nooit, weet niet" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Media_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Media_agree == 'Gezien'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf de CoronaMelder voorbij te hebben zien komen in de media en/of het nieuws, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Media_agree == 'Gezien'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  
 
```{r chiMediaValenceusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$MediaValence_agree[(data$MediaValence == 'Heel erg positief'| data$MediaValence == 'Positief'| data$MediaValence == 'Een beetje positief')] <- "Positief"
data$MediaValence_agree[(data$MediaValence == 'Neutraal'| data$MediaValence == 'Een beetje negatief'| data$MediaValence == 'Negatief'| data$MediaValence == 'Heel erg negatief'| data$MediaValence == 'Weet ik niet')] <- "Neutraal, negatief, weet niet" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected = data_selected[(data_selected$Media == 'Vaak'| data_selected$Media == 'Soms'| data_selected$Media == 'Af en toe'),]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$MediaValence_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& MediaValence_agree == 'Positief'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf dat de berichten/items over de CoronaMelder over het algemeen positief van toon waren, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & MediaValence_agree == 'Positief'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r, echo=FALSE, tab.cap = "Mediaberichten over de CoronaMelder naar gebruikersstatus. Aantal en totaal percentage dat minstens af en toe berichten heeft gezien (af en toe, soms, vaak)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Media")
graph_questionlabels = c("Hoe vaak hebt u de CoronaMelder voorbij zien komen in de media en/of het nieuws in de afgelopen maand?") 

# Which values do we want to include in the table cells?
include_vars = c("Vaak", "Soms", "Af en toe")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))

  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Voormalig gebruiker"))
    
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```



```{r, echo=FALSE, tab.cap = "Toon van mediaberichten over de CoronaMelder naar gebruikersstatus. Aantal en totaal percentage dat deze toon als positief beschouwt (een beetje positief, positief, heel erg positief)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("MediaValence")
graph_questionlabels = c("Waren deze berichten/items over het algemeen negatief of positief van toon?") 

# Which values do we want to include in the table cells?
include_vars = c("Heel erg positief", "Positief", "Een beetje positief")

# Note: for this table, the totals should include only people that have seen some messages about CoronaMelder
# in the media, so we should filter those out (and not use the generic totals table created at the start
# of this document).
usergroup_names = c("users", "former_users", "nonusers", "nonusers_no_intention", "nonusers_neutral", "nonusers_intention")

usergroup_labels = c("Gebruikers", "Voormalig gebruikers", "Niet gebruikers", "Niet gebruikers - niet van plan om te gaan gebruiken", "Niet gebruikers - neutraal", "Niet gebruikers - wel van plan om te gaan gebruiken")

user_totals_media <- data.frame(matrix(ncol = length(usergroup_names), nrow = 1))
colnames(user_totals_media) <- usergroup_names

# Current user
user_totals_media[1] <- sum(data$user_status == "Gebruiker" & data$Media != "Nooit" & data$Media != "Weet ik niet")

# Former user
user_totals_media[2] <- sum(data$user_status == "Voormalig gebruiker" & data$Media != "Nooit" & data$Media != "Weet ik niet")

# Non user
user_totals_media[3] <- sum(data$user_status == "Niet gebruiker" & data$Media != "Nooit" & data$Media != "Weet ik niet")

# Non user -- not planning to use
user_totals_media[4] <- sum(data$user_status_intention == "Nooit gebruikt en niet van plan" & data$Media != "Nooit" & data$Media != "Weet ik niet")

# Non user -- neutral
user_totals_media[5] <- sum(data$user_status_intention == "Nooit gebruikt en neutraal" & data$Media != "Nooit" & data$Media != "Weet ik niet")

# Non user -- planning to use
user_totals_media[6] <- sum(data$user_status_intention == "Nooit gebruikt en wel van plan" & data$Media != "Nooit" & data$Media != "Weet ik niet")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals_media))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))

  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Voormalig Gebruiker"))
    
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals_media)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals_media[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```

#### CoronaMelder in de media over de tijd
```{r McNemarmediaovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Media_agree_cw[(data_currentwave_wavemin1$Media_cw == 'Vaak'| data_currentwave_wavemin1$Media_cw == 'Soms'| data_currentwave_wavemin1$Media_cw == 'Af en toe')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Media_agree_cw[(data_currentwave_wavemin1$Media_cw == 'Nooit'| data_currentwave_wavemin1$Media_cw == 'Weet ik niet')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Media_agree_wmin1[(data_currentwave_wavemin1$Media_wmin1 == 'Vaak'| data_currentwave_wavemin1$Media_wmin1 == 'Soms'| data_currentwave_wavemin1$Media_wmin1 == 'Af en toe')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Media_agree_wmin1[(data_currentwave_wavemin1$Media_wmin1 == 'Nooit'| data_currentwave_wavemin1$Media_wmin1 == 'Weet ik niet')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Media_agree_cw, data_currentwave_wavemin1$Media_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Media_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Media_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf de CoronaMelder voorbij te hebben zien komen in de media en/of het nieuws in de afgelopen maand.


```{r, echo=FALSE, fig.width=5.5, fig.height=2.5, dpi = 300, fig.cap="Mediaberichten over de CoronaMelder over de tijd. Aantal en totaal percentage dat minstens af en toe berichten heeft gezien (af en toe, soms, vaak)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Media")
graph_questionlabels = c("Hoe vaak hebt u de CoronaMelder voorbij zien komen in de media en/of het nieuws in de afgelopen maand?") 

# Which values do we want to include in the table cells?
include_vars = c("Vaak", "Soms", "Af en toe")

# Which waves do we want to include in the table cells?
include_waves = c("w2", "w3", "w4")

# Labels for the waves
wave_labels = c("7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-1)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

```{r ChisquareMediaValenceOvertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$MediaValence_agree_cw[(data_currentwave_wavemin1$MediaValence_cw == 'Heel erg positief'| data_currentwave_wavemin1$MediaValence_cw == 'Positief'| data_currentwave_wavemin1$MediaValence_cw == 'Een beetje positief')] <- "Positief_cw"

data_currentwave_wavemin1$MediaValence_agree_cw[(data_currentwave_wavemin1$MediaValence_cw == 'Neutraal'| data_currentwave_wavemin1$MediaValence_cw == 'Een beetje negatief'| data_currentwave_wavemin1$MediaValence_cw == 'Negatief'| data_currentwave_wavemin1$MediaValence_cw == 'Heel erg negatief'| data_currentwave_wavemin1$MediaValence_cw == 'Weet ik niet')] <- "Neutraal, negatief, weet niet_cw"


# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$MediaValence_agree_wmin1[(data_currentwave_wavemin1$MediaValence_wmin1 == 'Heel erg positief'| data_currentwave_wavemin1$MediaValence_wmin1 == 'Positief'| data_currentwave_wavemin1$MediaValence_wmin1 == 'Een beetje positief')] <- "Positief_wmin1"

data_currentwave_wavemin1$MediaValence_agree_wmin1[(data_currentwave_wavemin1$MediaValence_wmin1 == 'Neutraal'| data_currentwave_wavemin1$MediaValence_wmin1 == 'Een beetje negatief'| data_currentwave_wavemin1$MediaValence_wmin1 == 'Negatief'| data_currentwave_wavemin1$MediaValence_wmin1 == 'Heel erg negatief'| data_currentwave_wavemin1$MediaValence_wmin1 == 'Weet ik niet')] <- "Neutraal, negatief, weet niet_wmin1"

# Similar to BI1a and BI1b: take into account whether respondents saw the CoronaMelder in the media, otherwise they
# did not answer this current question on valence.
data_selected_cw = data_currentwave_wavemin1[data_currentwave_wavemin1$Media_cw == 'Vaak' | data_currentwave_wavemin1$Media_cw == 'Soms' | data_currentwave_wavemin1$Media_cw == 'Af en toe', ]

data_selected_wmin1 = data_currentwave_wavemin1[data_currentwave_wavemin1$Media_wmin1 == 'Vaak' | data_currentwave_wavemin1$Media_wmin1 == 'Soms' | data_currentwave_wavemin1$Media_wmin1 == 'Af en toe', ]

# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$MediaValence_agree_cw), table(data_selected_wmin1$MediaValence_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```
Om te bepalen of de toon van de mediaberichten over de CoronaMelder verschilt tussen de huidige en de vorige wave is een chi kwadraat uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave de CoronaMelder in de media hadden gezien en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin het voorbij zien komen in de media in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage respondenten in de huidige wave (`r round((nrow(filter(data_selected_cw, MediaValence_agree_cw == 'Positief_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf dat de berichten/items over de CoronaMelder in de media over het algemeen positief waren, vergeleken met het percentage uit de vorige wave (`r round((nrow(filter(data_selected_wmin1, MediaValence_agree_wmin1 == 'Positief_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%).

```{r, echo=FALSE, fig.width=5.5, fig.height=2.5, dpi = 300, fig.cap="Toon van mediaberichten over de CoronaMelder over de tijd. Aantal en totaal percentage dat deze toon als positief beschouwt (een beetje positief, positief, heel erg positief)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("MediaValence")
graph_questionlabels = c("Waren deze berichten/items over het algemeen negatief of positief van toon?") 

# Which values do we want to include in the table cells?
include_vars = c("Heel erg positief", "Positief", "Een beetje positief")

# Which waves do we want to include in the table cells?
include_waves = c("w2", "w3", "w4")

# Labels for the waves
wave_labels = c("7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-1)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

### Vertrouwen in adequaatheid techniek
In de vragenlijst werd gepeild in welke mate men vertrouwen heeft in de adequaatheid van de techniek. Het overgrote deel van de respondenten antwoordde 'zeker waar' of 'misschien waar' op de stelling 'De techniek (Bluetooth) die wordt gebruikt in de CoronaMelder geeft aan wie er in de buurt is geweest van een persoon die besmet is' (`r round((nrow(filter(data, (Beliefs_technologyperformance == 'Zeker waar'| Beliefs_technologyperformance == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%). 

```{r technology, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Vertrouwen in techniek", tab.cap="Vertrouwen in techniek"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_technologyperformance")
                        
graph_questionlabels = c("De techniek (bluetooth) die wordt gebruikt in de CoronaMelder geeft aan wie er in de buurt is geweest van een persoon die besmet is"); 

# These questions have 5 answer categories: Zeker niet waar - Zeker waar en Weet ik niet. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Zeker waar", "Misschien waar", "Misschien niet waar", "Zeker niet waar"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


#### Vertrouwen in adequaatheid techniek naar gebruikersstatus
```{r, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_technologyperformance_agree[(data$Beliefs_technologyperformance == 'Zeker waar'| data$Beliefs_technologyperformance == 'Misschien waar')] <- "Totaal waar"
data$Beliefs_technologyperformance_agree[(data$Beliefs_technologyperformance == 'Weet ik niet'| data$Beliefs_technologyperformance == 'Zeker niet waar'| data$Beliefs_technologyperformance == 'Misschien niet waar')] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_technologyperformance_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_technologyperformance_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf dat de CoronaMelder via bluetooth kan aangeven wie er in de buurt is geweest van een persoon die besmet is, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_technologyperformance_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%). 


```{r, echo=FALSE, tab.cap ="Vertrouwen in technologie naar gebruikersstatus. Aantal en totaal percentage waar (misschien waar, zeker waar)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_technologyperformance")
graph_questionlabels = c("De techniek (bluetooth) die wordt gebruikt in de CoronaMelder geeft aan wie er in de buurt is geweest van een persoon die besmet is") 

# Which values do we want to include in the table cells?
include_vars = c("Zeker waar", "Misschien waar")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))

    data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Voormalig gebruiker"))
  
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```


#### Vertrouwen in adequaatheid techniek over de tijd
```{r chiBeliefstechnologyperformanceovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_technologyperformance_agree_cw[(data_currentwave_wavemin1$Beliefs_technologyperformance_cw == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_technologyperformance_cw == 'Misschien waar')] <- "Totaal waar_cw"
data_currentwave_wavemin1$Beliefs_technologyperformance_agree_cw[(data_currentwave_wavemin1$Beliefs_technologyperformance_cw == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_technologyperformance_cw == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_technologyperformance_cw == 'Misschien niet waar')] <- "Weet niet, niet waar_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_technologyperformance_agree_wmin1[(data_currentwave_wavemin1$Beliefs_technologyperformance_wmin1 == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_technologyperformance_wmin1 == 'Misschien waar')] <- "Totaal waar_wmin1"
data_currentwave_wavemin1$Beliefs_technologyperformance_agree_wmin1[(data_currentwave_wavemin1$Beliefs_technologyperformance_wmin1 == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_technologyperformance_wmin1 == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_technologyperformance_wmin1 == 'Misschien niet waar')] <- "Weet niet, niet waar_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_technologyperformance_agree_cw, data_currentwave_wavemin1$Beliefs_technologyperformance_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table) 
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_technologyperformance_agree_cw == 'Totaal waar_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_technologyperformance_agree_wmin1 == 'Totaal waar_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf dat de stelling dat de CoronaMelder via bluetooth kan aangeven wie er in de buurt is geweest van een persoon die besmet is, waar is. 

```{r, echo=FALSE, fig.width=5.5, fig.height=2.5, dpi = 300, fig.cap="Vertrouwen in techniek over de tijd, totaal percentage dat de stelling minstens misschien waar vond (misschien waar, zeker waar)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_technologyperformance")
graph_questionlabels = c("De techniek (bluetooth) die wordt gebruikt in de CoronaMelder geeft aan wie er in de buurt is geweest van een persoon die besmet is") 

# Which values do we want to include in the table cells?
include_vars = c("Zeker waar", "Misschien waar")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

### Maatschappelijke gevolgen gebruik CoronaMelder
Aan de respondenten werd gevraagd in hoeverre zij dachten dat het gebruik van de CoronaMelder de Nederlandse economie helpt. Meer dan een kwart van de respondenten heeft de overtuiging dat de CoronaMelder de Nederlandse economie zal helpen (`r round((nrow(filter(data, (Beliefs_benefiteconomic == 'Helemaal mee eens'| Beliefs_benefiteconomic == 'Mee eens'| Beliefs_benefiteconomic == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).

```{r beneficteconomic, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Overtuiging dat de CoronaMelder de Nederlandse economie helpt", tab.cap="Geloof dat de CoronaMelder de Nederlandse economie helpt"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_benefiteconomic")
graph_questionlabels = c("Gebruik van de CoronaMelder helpt de Nederlandse economie"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) 

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


#### Maatschappelijke gevolgen gebruik CoronaMelder naar gebruikersstatus
```{r chiBeliefsbenefiteconomicusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_benefiteconomic_agree[(data$Beliefs_benefiteconomic == 'Helemaal mee eens'| data$Beliefs_benefiteconomic == 'Mee eens'| data$Beliefs_benefiteconomic == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_benefiteconomic_agree[(data$Beliefs_benefiteconomic == 'Neutraal'| data$Beliefs_benefiteconomic == 'Een beetje oneens'| data$Beliefs_benefiteconomic == 'Oneens'| data$Beliefs_benefiteconomic == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_benefiteconomic_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_benefiteconomic_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat gebruik van de CoronaMelder de Nederlandse economie helpt, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_benefiteconomic_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  


```{r, echo=FALSE, tab.cap ="Maatschappelijke gevolgen gebruik CoronaMelder naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_benefiteconomic")
graph_questionlabels = c("Gebruik van de CoronaMelder helpt de Nederlandse economie") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))

  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Voormalig gebruiker"))
    
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```


#### Maatschappelijke gevolgen gebruik CoronaMelder over de tijd
```{r McNemarBeliefsbenefiteconomicovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_benefiteconomic_agree_cw[(data_currentwave_wavemin1$Beliefs_benefiteconomic_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_benefiteconomic_cw == 'Mee eens'| data_currentwave_wavemin1$Beliefs_benefiteconomic_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Beliefs_benefiteconomic_agree_cw[(data_currentwave_wavemin1$Beliefs_benefiteconomic_cw == 'Neutraal'| data_currentwave_wavemin1$Beliefs_benefiteconomic_cw == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_benefiteconomic_cw == 'Oneens'| data_currentwave_wavemin1$Beliefs_benefiteconomic_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_benefiteconomic_agree_wmin1[(data_currentwave_wavemin1$Beliefs_benefiteconomic_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_benefiteconomic_wmin1 == 'Mee eens'| data_currentwave_wavemin1$Beliefs_benefiteconomic_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Beliefs_benefiteconomic_agree_wmin1[(data_currentwave_wavemin1$Beliefs_benefiteconomic_wmin1 == 'Neutraal'| data_currentwave_wavemin1$Beliefs_benefiteconomic_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_benefiteconomic_wmin1 == 'Oneens'| data_currentwave_wavemin1$Beliefs_benefiteconomic_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_benefiteconomic_agree_cw, data_currentwave_wavemin1$Beliefs_benefiteconomic_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_benefiteconomic_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_benefiteconomic_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het gebruik van de CoronaMelder de Nederlandse economie helpt.

```{r, echo=FALSE, fig.width=5.5, fig.height=2.5, dpi = 300, fig.cap="Maatschappelijke gevolgen CoronaMelder over de tijd, totaal percentage dat het minstens een beetje eens was met de stelling (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_benefiteconomic")
graph_questionlabels = c("Gebruik van de CoronaMelder helpt de Nederlandse economie") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

### Verwachte gebruiksvriendelijkheid, inspanningsverwachting en zelfeffectiviteit

Gebruiksvriendelijkheid, inspanningsverwachting en zelfeffectiviteit zijn factoren die belangrijk zijn in de adoptie van nieuwe technologie. Opvallend is dat van de mensen die de CoronaMelder nog *niet* gebruiken, 1 op de 5 mensen (`r round((nrow(filter(data, (EE1b_UTAUT == 'Helemaal mee eens'| EE1b_UTAUT == 'Mee eens'| EE1b_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`%) denkt dat het veel tijd en energie kost om deze te gaan gebruiken en een aanzienlijk deel hier neutraal in staat (`r round((nrow(filter(data, (EE1b_UTAUT == 'Neutraal') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`%). Ongeveer de helft (`r round((nrow(filter(data, (EE1b_UTAUT == 'Helemaal mee oneens'| EE1b_UTAUT == 'Oneens'| EE1b_UTAUT == 'Een beetje oneens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`%) is het hier mee oneens.

Daar staat tegenover dat van de mensen die de CoronaMelder al *wel* gebruiken, slechts `r round((nrow(filter(data, (EE1a_UTAUT == 'Helemaal mee eens'| EE1a_UTAUT == 'Mee eens'| EE1a_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`% aangaf dat het ze veel tijd en energie gekost had. Een overgrote meerderheid (`r round((nrow(filter(data, (EE1a_UTAUT == 'Helemaal mee oneens'| EE1a_UTAUT == 'Oneens'| EE1a_UTAUT == 'Een beetje oneens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`%) gaf aan het niet eens te zijn met deze stelling. 

Hetzelfde patroon was te zien voor de vraag over gebruiksgemak: het merendeel (`r round((nrow(filter(data, (EE2a_UTAUT == 'Helemaal mee eens'| EE2a_UTAUT == 'Mee eens'| EE2a_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`%) van de respondenten die de CoronaMelder op dit moment gebruiken was het eens met de stelling dat de CoronaMelder makkelijk te gebruiken is. Van degenen die de CoronaMelder nooit hebben gebruikt gaf `r round((nrow(filter(data, (EE2b_UTAUT == 'Helemaal mee eens'| EE2b_UTAUT == 'Mee eens'| EE2b_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`% aan dat hij/zij verwacht dat de CoronaMelder makkelijk te gebruiken is. 

```{r effortexpectancynonusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Gebruiksvriendelijkheid en inspanningsverwachting bij respondenten die de CoronaMelder nooit gebruikt hebben", tab.cap="Gebruiksvriendelijkheid en inspanningsverwachting bij respondenten die de CoronaMelder nooit gebruikt hebben"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("EE1b_UTAUT", 
                        "EE2b_UTAUT")
graph_questionlabels = c("Ik denk dat het mij veel tijd en energie kost om de CoronaMelder te gebruiken", 
                         "Ik denk dat de CoronaMelder makkelijk te gebruiken is"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik heb de CoronaMelder app nooit gebruikt'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

In onderstaande grafiek en tabellen zijn de resultaten voor de respondenten die de CoronaMelder momenteel gebruiken, te vinden. 

```{r effortexpectancyusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Gebruiksvriendelijkheid en inspanningsverwachting  bij respondenten die de CoronaMelder op dit moment gebruiken", tab.cap="Gebruiksvriendelijkheid en inspanningsverwachting bij respondenten die de CoronaMelder op dit moment gebruiken"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("EE1a_UTAUT", 
                        "EE2a_UTAUT")
graph_questionlabels = c("Het kost(te) mij veel tijd en energie om de CoronaMelder te gebruiken", 
                         "De CoronaMelder is makkelijk te gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out

```

Zelfeffectiviteit is de persoonlijke inschatting van de eigen bekwaamheid om bepaald gedrag uit te kunnen voeren. Er is gevraagd of men zichzelf in staat achtte om de CoronaMelder te gebruiken: `r round((nrow(filter(data, (HBM_selfefficacy_CoronaMelder == 'Helemaal mee eens'| HBM_selfefficacy_CoronaMelder == 'Mee eens'| HBM_selfefficacy_CoronaMelder == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% acht zichzelf in staat de CoronaMelder te gebruiken. Gebruikers (`r round((nrow(filter(data, (user_status == 'Gebruiker')&(HBM_selfefficacy_CoronaMelder == 'Helemaal mee eens'| HBM_selfefficacy_CoronaMelder == 'Mee eens'| HBM_selfefficacy_CoronaMelder == 'Een beetje mee eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`%) zich vaker in staat achten om de CoronaMelder te gebruiken dan niet gebruikers (`r round((nrow(filter(data, (user_status == 'Niet gebruiker')&(HBM_selfefficacy_CoronaMelder == 'Helemaal mee eens'| HBM_selfefficacy_CoronaMelder == 'Mee eens'| HBM_selfefficacy_CoronaMelder == 'Een beetje mee eens'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%). In onderstaande grafiek en tabel zijn de resultaten voor de gehele sample te zien. 

```{r selfefficacyCM, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Zelfeffectiviteit om CoronaMelder te gebruiken", tab.cap="Zelfeffectiviteit om CoronaMelder te gebruiken"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_selfefficacy_CoronaMelder")
graph_questionlabels = c("Ik ben in staat om de CoronaMelder te gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


#### Verwachte gebruiksvriendelijkheid en inspanningsverwachting over de tijd - niet gebruikers
```{r ChisquareEE1bUtautovertimenonusers, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$EE1b_UTAUT_agree_cw[(data_currentwave_wavemin1$EE1b_UTAUT_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$EE1b_UTAUT_cw == 'Mee eens'| data_currentwave_wavemin1$EE1b_UTAUT_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$EE1b_UTAUT_agree_cw[(data_currentwave_wavemin1$EE1b_UTAUT_cw == 'Neutraal'| data_currentwave_wavemin1$EE1b_UTAUT_cw == 'Een beetje oneens'| data_currentwave_wavemin1$EE1b_UTAUT_cw == 'Oneens'| data_currentwave_wavemin1$EE1b_UTAUT_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$EE1b_UTAUT_agree_wmin1[(data_currentwave_wavemin1$EE1b_UTAUT_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$EE1b_UTAUT_wmin1 == 'Mee eens'| data_currentwave_wavemin1$EE1b_UTAUT_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$EE1b_UTAUT_agree_wmin1[(data_currentwave_wavemin1$EE1b_UTAUT_wmin1 == 'Neutraal'| data_currentwave_wavemin1$EE1b_UTAUT_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$EE1b_UTAUT_wmin1 == 'Oneens'| data_currentwave_wavemin1$EE1b_UTAUT_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# THe following explanation holds for BI1a and BI1b: The fact that for some of the participants the user status changed between wave 1 and wave 2, we decided to perform a chi square in which we compare the proportion of Totaal eens_wmin1 versus Neutraal, niet mee eens_wmin1 for users of wave 1 with the proportion of Totaal eens_cw versus Neutraal, niet mee eens_cw for users of the current wave. For this we have to select, separately for each wave, the users (or non users). For these subsets we calculate counts with Totaal eens and Neutraal, etc. After that we concatenate these counts int a 2x2 table and perform a regular chi square on that.  
data_selected_cw = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik heb de CoronaMelder app nooit gebruikt", ]

data_selected_wmin1 = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik heb de CoronaMelder app nooit gebruikt", ]


# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$EE1b_UTAUT_agree_cw), table(data_selected_wmin1$EE1b_UTAUT_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```
Om te bepalen of de inspanningsverwachting bij de niet gebruikers verschilt tussen de huidige en de vorige wave is een chi kwadraat uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave gebruikers waren en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin de gebruikersstatus in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage niet gebruikers in de huidige wave (`r round((nrow(filter(data_selected_cw, EE1b_UTAUT_agree_cw == 'Totaal eens_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij denk dat het gebruik van de CoronaMelder veel tijd en energie gaat kosten, vergeleken met het percentage niet gebruikers uit de vorige wave dat in de vorige wave aangaf het hiermee eens te zijn (`r round((nrow(filter(data_selected_wmin1, EE1b_UTAUT_agree_wmin1 == 'Totaal eens_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%).

```{r ChisquareEE2bUtautovertimenonusers, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$EE2b_UTAUT_agree_cw[(data_currentwave_wavemin1$EE2b_UTAUT_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$EE2b_UTAUT_cw == 'Mee eens'| data_currentwave_wavemin1$EE2b_UTAUT_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$EE2b_UTAUT_agree_cw[(data_currentwave_wavemin1$EE2b_UTAUT_cw == 'Neutraal'| data_currentwave_wavemin1$EE2b_UTAUT_cw == 'Een beetje oneens'| data_currentwave_wavemin1$EE2b_UTAUT_cw == 'Oneens'| data_currentwave_wavemin1$EE2b_UTAUT_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$EE2b_UTAUT_agree_wmin1[(data_currentwave_wavemin1$EE2b_UTAUT_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$EE2b_UTAUT_wmin1 == 'Mee eens'| data_currentwave_wavemin1$EE2b_UTAUT_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$EE2b_UTAUT_agree_wmin1[(data_currentwave_wavemin1$EE2b_UTAUT_wmin1 == 'Neutraal'| data_currentwave_wavemin1$EE2b_UTAUT_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$EE2b_UTAUT_wmin1 == 'Oneens'| data_currentwave_wavemin1$EE2b_UTAUT_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# THe following explanation holds for BI1a and BI1b: The fact that for some of the participants the user status changed between wave 1 and wave 2, we decided to perform a chi square in which we compare the proportion of Totaal eens_wmin1 versus Neutraal, niet mee eens_wmin1 for users of wave 1 with the proportion of Totaal eens_cw versus Neutraal, niet mee eens_cw for users of the current wave. For this we have to select, separately for each wave, the users (or non users). For these subsets we calculate counts with Totaal eens and Neutraal, etc. After that we concatenate these counts int a 2x2 table and perform a regular chi square on that.  
data_selected_cw = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik heb de CoronaMelder app nooit gebruikt", ]

data_selected_wmin1 = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik heb de CoronaMelder app nooit gebruikt", ]


# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$EE2b_UTAUT_agree_cw), table(data_selected_wmin1$EE2b_UTAUT_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```
Om te bepalen of de verwachte gebruiksvriendelijkheid bij de niet gebruikers verschilt tussen de huidige en de vorige wave is een chi kwadraat uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave gebruikers waren en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin de gebruikersstatus in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage niet gebruikers in de huidige wave (`r round((nrow(filter(data_selected_cw, EE2b_UTAUT_agree_cw == 'Totaal eens_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij de CoronaMelder makkelijk te gebruiken is, vergeleken met het percentage niet gebruikers uit de vorige wave dat in de vorige wave aangaf het hiermee eens te zijn (`r round((nrow(filter(data_selected_wmin1, EE2b_UTAUT_agree_wmin1 == 'Totaal eens_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%).

```{r, echo=FALSE, fig.width=5.5, fig.height=4, dpi = 300, fig.cap="Verwachte gebruiksvriendelijkheid en inspanningsverwachting over de tijd, alleen niet gebruikers, totaal percentage dat het minstens een beetje eens was met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("EE1b_UTAUT", 
                        "EE2b_UTAUT")
graph_questionlabels = c("Ik denk dat het mij veel tijd en energie kost om de CoronaMelder te gebruiken", 
                         "Ik denk dat de CoronaMelder makkelijk te gebruiken is"); 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars & (eval(parse(text=paste('Behavior_UTAUT', include_waves[wave_idx], sep="_")))) != 'Ik gebruik de CoronaMelder app op dit moment')) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) & (eval(parse(text=paste('Behavior_UTAUT', include_waves[wave_idx], sep="_")))) != 'Ik gebruik de CoronaMelder app op dit moment'))
    }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```


#### Verwachte gebruiksvriendelijkheid en inspanningsverwachting over de tijd - gebruikers
```{r ChisquareEE1aUtautovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$EE1a_UTAUT_agree_cw[(data_currentwave_wavemin1$EE1a_UTAUT_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$EE1a_UTAUT_cw == 'Mee eens'| data_currentwave_wavemin1$EE1a_UTAUT_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$EE1a_UTAUT_agree_cw[(data_currentwave_wavemin1$EE1a_UTAUT_cw == 'Neutraal'| data_currentwave_wavemin1$EE1a_UTAUT_cw == 'Een beetje oneens'| data_currentwave_wavemin1$EE1a_UTAUT_cw == 'Oneens'| data_currentwave_wavemin1$EE1a_UTAUT_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$EE1a_UTAUT_agree_wmin1[(data_currentwave_wavemin1$EE1a_UTAUT_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$EE1a_UTAUT_wmin1 == 'Mee eens'| data_currentwave_wavemin1$EE1a_UTAUT_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$EE1a_UTAUT_agree_wmin1[(data_currentwave_wavemin1$EE1a_UTAUT_wmin1 == 'Neutraal'| data_currentwave_wavemin1$EE1a_UTAUT_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$EE1a_UTAUT_wmin1 == 'Oneens'| data_currentwave_wavemin1$EE1a_UTAUT_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# THe following explanation holds for BI1a and BI1b: The fact that for some of the participants the user status changed between wave 1 and wave 2, we decided to perform a chi square in which we compare the proportion of Totaal eens_wmin1 versus Neutraal, niet mee eens_wmin1 for users of wave 1 with the proportion of Totaal eens_cw versus Neutraal, niet mee eens_cw for users of the current wave. For this we have to select, separately for each wave, the users (or non users). For these subsets we calculate counts with Totaal eens and Neutraal, etc. After that we concatenate these counts int a 2x2 table and perform a regular chi square on that.  
data_selected_cw = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik gebruik de CoronaMelder app op dit moment", ]

data_selected_wmin1 = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik gebruik de CoronaMelder app op dit moment", ]

# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$EE1a_UTAUT_agree_cw), table(data_selected_wmin1$EE1a_UTAUT_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```
Om te bepalen of de inspanningsverwachting bij de gebruikers verschilt tussen de huidige en de vorige wave is een chi kwadraat uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave gebruikers waren en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin de gebruikersstatus in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers in de huidige wave (`r round((nrow(filter(data_selected_cw, EE1a_UTAUT_agree_cw == 'Totaal eens_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling het veel tijd en energie kostte om de CoronaMelder te gebruiken, vergeleken met het percentage gebruikers uit de vorige wave dat in de vorige wave aangaf het hiermee eens te zijn (`r round((nrow(filter(data_selected_wmin1, EE1a_UTAUT_agree_wmin1 == 'Totaal eens_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%).

```{r ChisquareEE2aUtautovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$EE2a_UTAUT_agree_cw[(data_currentwave_wavemin1$EE2a_UTAUT_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$EE2a_UTAUT_cw == 'Mee eens'| data_currentwave_wavemin1$EE2a_UTAUT_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$EE2a_UTAUT_agree_cw[(data_currentwave_wavemin1$EE2a_UTAUT_cw == 'Neutraal'| data_currentwave_wavemin1$EE2a_UTAUT_cw == 'Een beetje oneens'| data_currentwave_wavemin1$EE2a_UTAUT_cw == 'Oneens'| data_currentwave_wavemin1$EE2a_UTAUT_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$EE2a_UTAUT_agree_wmin1[(data_currentwave_wavemin1$EE2a_UTAUT_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$EE2a_UTAUT_wmin1 == 'Mee eens'| data_currentwave_wavemin1$EE2a_UTAUT_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$EE2a_UTAUT_agree_wmin1[(data_currentwave_wavemin1$EE2a_UTAUT_wmin1 == 'Neutraal'| data_currentwave_wavemin1$EE2a_UTAUT_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$EE2a_UTAUT_wmin1 == 'Oneens'| data_currentwave_wavemin1$EE2a_UTAUT_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# THe following explanation holds for BI1a and BI1b: The fact that for some of the participants the user status changed between wave 1 and wave 2, we decided to perform a chi square in which we compare the proportion of Totaal eens_wmin1 versus Neutraal, niet mee eens_wmin1 for users of wave 1 with the proportion of Totaal eens_cw versus Neutraal, niet mee eens_cw for users of the current wave. For this we have to select, separately for each wave, the users (or non users). For these subsets we calculate counts with Totaal eens and Neutraal, etc. After that we concatenate these counts int a 2x2 table and perform a regular chi square on that.  
data_selected_cw = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik gebruik de CoronaMelder app op dit moment", ]

data_selected_wmin1 = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik gebruik de CoronaMelder app op dit moment", ]

# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$EE2a_UTAUT_agree_cw), table(data_selected_wmin1$EE2a_UTAUT_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```
Om te bepalen of de inschatting van gebruiksvriendelijkheid bij de gebruikers verschilt tussen de huidige en de vorige wave is een chi kwadraat uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave gebruikers waren en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin de gebruikersstatus in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers in de huidige wave (`r round((nrow(filter(data_selected_cw, EE2a_UTAUT_agree_cw == 'Totaal eens_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat de CoronaMelder makkelijk te gebruiken is, vergeleken met het percentage gebruikers uit de vorige wave dat in de vorige wave aangaf het hiermee eens te zijn (`r round((nrow(filter(data_selected_wmin1, EE2a_UTAUT_agree_wmin1 == 'Totaal eens_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%).

```{r, echo=FALSE, fig.width=5.5, fig.height=4, dpi = 300, fig.cap="Verwachte gebruiksvriendelijkheid en inspanningsverwachting over de tijd, alleen huidige gebruikers, totaal percentage dat het minstens een beetje eens was met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("EE1a_UTAUT", 
                        "EE2a_UTAUT")
graph_questionlabels = c("Het kost(te) mij veel tijd en energie om de CoronaMelder te gebruiken", 
                         "De CoronaMelder is makkelijk te gebruiken"); 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars & (eval(parse(text=paste('Behavior_UTAUT', include_waves[wave_idx], sep="_")))) == 'Ik gebruik de CoronaMelder app op dit moment')) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) & (eval(parse(text=paste('Behavior_UTAUT', include_waves[wave_idx], sep="_")))) == 'Ik gebruik de CoronaMelder app op dit moment'))
    }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```


#### Zelfeffectiviteit over de tijd
```{r McNemarselfefficacyCMovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_agree_cw[(data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_agree_cw[(data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_cw == 'Oneens'| data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_agree_wmin1[(data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_agree_wmin1[(data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_agree_cw, data_currentwave_wavemin1$HBM_selfefficacy_CoronaMelder_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_selfefficacy_CoronaMelder_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_selfefficacy_CoronaMelder_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat men in staat is om de CoronaMelder te gebruiken.

```{r, echo=FALSE, fig.width=5.5, fig.height=2.5, dpi = 300, fig.cap="Zelfeffectiviteit om CoronaMelder te gebruiken over de tijd, totaal percentage dat het minstens een beetje eens was met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_selfefficacy_CoronaMelder")
graph_questionlabels = c("Ik ben in staat om de CoronaMelder te gebruiken"); 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

### Technologie gerelateerde belemmeringen
Vanuit de Unified Theory of Acceptance and Use of Technology is bekend dat technologie gerelateerde belemmeringen een rol kunnen spelen in de adoptie van nieuwe technologieën zoals de CoronaMelder. In totaal gaf slechts `r round((nrow(filter(data, (FC1_UTAUT == 'Helemaal mee oneens'| FC1_UTAUT == 'Oneens'| FC1_UTAUT == 'Een beetje oneens'))) /nrow(data))*100, digits = 1)`% aan het oneens te zijn met de stelling dat hij/zij beschikking heeft over een smartphone waarmee de CoronaMelder gebruikt kan worden. Daarnaast gaf een laag percentage (`r round((nrow(filter(data, (FC2_UTAUT == 'Helemaal mee oneens'| FC2_UTAUT == 'Oneens'| FC2_UTAUT == 'Een beetje oneens'))) /nrow(data))*100, digits = 1)`%) aan het oneens te zijn met de stelling dat hij/zij genoeg (technische) kennis heeft om de CoronaMelder te gebruiken.  

```{r , echo=FALSE, fig.width=7, fig.height=3, fig.cap="Technologie gerelateerde belemmeringen", tab.cap="Technologie gerelateerde belemmeringen"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("FC1_UTAUT", 
                        "FC2_UTAUT")
graph_questionlabels = c("Ik heb een smartphone tot mijn beschikking met toegang tot het internet waarmee ik de CoronaMelder kan gebruiken", 
                         "Ik heb genoeg (technische) kennis om de CoronaMelder te gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


#### Technologie gerelateerde belemmeringen naar gebruikersstatus
```{r chiFC1utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$FC1_UTAUT_agree[(data$FC1_UTAUT == 'Helemaal mee eens'| data$FC1_UTAUT == 'Mee eens'| data$FC1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$FC1_UTAUT_agree[(data$FC1_UTAUT == 'Neutraal'| data$FC1_UTAUT == 'Een beetje oneens'| data$FC1_UTAUT == 'Oneens'| data$FC1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$FC1_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& FC1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn beschikking te hebben over een smartphone met internet, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & FC1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).

```{r chiFC2utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$FC2_UTAUT_agree[(data$FC2_UTAUT == 'Helemaal mee eens'| data$FC2_UTAUT == 'Mee eens'| data$FC2_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$FC2_UTAUT_agree[(data$FC2_UTAUT == 'Neutraal'| data$FC2_UTAUT == 'Een beetje oneens'| data$FC2_UTAUT == 'Oneens'| data$FC2_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$FC2_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& FC2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling genoeg technische kennis te hebben om de CoronaMelder te installeren, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & FC2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r, echo=FALSE, tab.cap = "Technologie gerelateerde belemmeringen naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("FC1_UTAUT", 
                        "FC2_UTAUT")
graph_questionlabels = c("Ik heb een smartphone tot mijn beschikking met toegang tot het internet waarmee ik de CoronaMelder kan gebruiken", 
                         "Ik heb genoeg (technische) kennis om de CoronaMelder te gebruiken"); 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Voormalig gebruiker"))
  
  
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```

#### Technologie gerelateerde belemmeringen over de tijd
```{r McNemarFC1utautovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$FC1_UTAUT_agree_cw[(data_currentwave_wavemin1$FC1_UTAUT_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$FC1_UTAUT_cw == 'Mee eens'| data_currentwave_wavemin1$FC1_UTAUT_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$FC1_UTAUT_agree_cw[(data_currentwave_wavemin1$FC1_UTAUT_cw == 'Neutraal'| data_currentwave_wavemin1$FC1_UTAUT_cw == 'Een beetje oneens'| data_currentwave_wavemin1$FC1_UTAUT_cw == 'Oneens'| data_currentwave_wavemin1$FC1_UTAUT_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$FC1_UTAUT_agree_wmin1[(data_currentwave_wavemin1$FC1_UTAUT_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$FC1_UTAUT_wmin1 == 'Mee eens'| data_currentwave_wavemin1$FC1_UTAUT_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$FC1_UTAUT_agree_wmin1[(data_currentwave_wavemin1$FC1_UTAUT_wmin1 == 'Neutraal'| data_currentwave_wavemin1$FC1_UTAUT_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$FC1_UTAUT_wmin1 == 'Oneens'| data_currentwave_wavemin1$FC1_UTAUT_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$FC1_UTAUT_agree_cw, data_currentwave_wavemin1$FC1_UTAUT_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (FC1_UTAUT_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (FC1_UTAUT_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat men een smartphone tot beschikking heeft waarmee de CoronaMelder kan worden gebruikt.
```{r McNemarFC2utautovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$FC2_UTAUT_agree_cw[(data_currentwave_wavemin1$FC2_UTAUT_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$FC2_UTAUT_cw == 'Mee eens'| data_currentwave_wavemin1$FC2_UTAUT_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$FC2_UTAUT_agree_cw[(data_currentwave_wavemin1$FC2_UTAUT_cw == 'Neutraal'| data_currentwave_wavemin1$FC2_UTAUT_cw == 'Een beetje oneens'| data_currentwave_wavemin1$FC2_UTAUT_cw == 'Oneens'| data_currentwave_wavemin1$FC2_UTAUT_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$FC2_UTAUT_agree_wmin1[(data_currentwave_wavemin1$FC2_UTAUT_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$FC2_UTAUT_wmin1 == 'Mee eens'| data_currentwave_wavemin1$FC2_UTAUT_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$FC2_UTAUT_agree_wmin1[(data_currentwave_wavemin1$FC2_UTAUT_wmin1 == 'Neutraal'| data_currentwave_wavemin1$FC2_UTAUT_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$FC2_UTAUT_wmin1 == 'Oneens'| data_currentwave_wavemin1$FC2_UTAUT_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$FC2_UTAUT_agree_cw, data_currentwave_wavemin1$FC2_UTAUT_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Daarnaast liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (FC2_UTAUT_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (FC2_UTAUT_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling genoeg technische kennis te hebben om de CoronaMelder te gebruiken.

```{r, echo=FALSE, fig.width=5.5, fig.height=3, dpi = 300, fig.cap="Technologie gerelateerde belemmeringen over de tijd, totaal percentage dat het minstens een beetje eens was met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("FC1_UTAUT", 
                        "FC2_UTAUT")
graph_questionlabels = c("Ik heb een smartphone tot mijn beschikking met toegang tot het internet waarmee ik de CoronaMelder kan gebruiken", 
                         "Ik heb genoeg (technische) kennis om de CoronaMelder te gebruiken"); 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

### Persoonlijke voor- en nadelen van gebruik
Belangrijke variabelen uit de Unified Theory of Acceptance and Use of Technology en het Health Belief Model zijn de verwachte voor- en nadelen van het gebruik. Het percentage van de respondenten dat voordelen ziet van het gebruik ligt vrij laag (`r round((nrow(filter(data, (HBM_perceivedbenefits_CoronaMelder == 'Helemaal mee eens'| HBM_perceivedbenefits_CoronaMelder == 'Mee eens'| HBM_perceivedbenefits_CoronaMelder == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), evenals het percentage dat nadelen ziet van het gebruik (`r round((nrow(filter(data, (HBM_barriers_CoronaMelder == 'Helemaal mee eens'| HBM_barriers_CoronaMelder == 'Mee eens'| HBM_barriers_CoronaMelder == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).

```{r Motivationsbarriers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Persoonlijke voor- en nadelen van gebruik", tab.cap="Persoonlijke nadelen", tab.cap="Persoonlijke voor- en nadelen van gebruik"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_perceivedbenefits_CoronaMelder",
                        "HBM_barriers_CoronaMelder")
graph_questionlabels = c("Het heeft voor mij persoonlijke voordelen om de CoronaMelder te gebruiken",
                         "Het heeft voor mij persoonlijke nadelen om de CoronaMelder te gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])


# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}


# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```



#### Persoonlijke voor- en nadelen van gebruik naar gebruikersstatus

```{r chiHBMperceivedbenefitsCoronaMelderutautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$HBM_perceivedbenefits_CoronaMelder_agree[(data$HBM_perceivedbenefits_CoronaMelder == 'Helemaal mee eens'| data$HBM_perceivedbenefits_CoronaMelder == 'Mee eens'| data$HBM_perceivedbenefits_CoronaMelder == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_perceivedbenefits_CoronaMelder_agree[(data$HBM_perceivedbenefits_CoronaMelder == 'Neutraal'| data$HBM_perceivedbenefits_CoronaMelder == 'Een beetje oneens'| data$HBM_perceivedbenefits_CoronaMelder == 'Oneens'| data$HBM_perceivedbenefits_CoronaMelder == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_perceivedbenefits_CoronaMelder_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& HBM_perceivedbenefits_CoronaMelder_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat het gebruik van de CoronaMelder persoonlijke voordelen heeft, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & HBM_perceivedbenefits_CoronaMelder_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiHBMbarriersCoronaMelderutautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$HBM_barriers_CoronaMelder_agree[(data$HBM_barriers_CoronaMelder == 'Helemaal mee eens'| data$HBM_barriers_CoronaMelder == 'Mee eens'| data$HBM_barriers_CoronaMelder == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_barriers_CoronaMelder_agree[(data$HBM_barriers_CoronaMelder == 'Neutraal'| data$HBM_barriers_CoronaMelder == 'Een beetje oneens'| data$HBM_barriers_CoronaMelder == 'Oneens'| data$HBM_barriers_CoronaMelder == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_barriers_CoronaMelder_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& HBM_barriers_CoronaMelder_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat het gebruik van de CoronaMelder persoonlijke nadelen heeft, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & HBM_barriers_CoronaMelder_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r, echo=FALSE, tab.cap ="Persoonlijke voor- en nadelen van gebruik naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_perceivedbenefits_CoronaMelder",
                        "HBM_barriers_CoronaMelder")
graph_questionlabels = c("Het heeft voor mij persoonlijke voordelen om de CoronaMelder te gebruiken",
                         "Het heeft voor mij persoonlijke nadelen om de CoronaMelder te gebruiken"); 



# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))

  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Voormalig gebruiker"))
    
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```

#### Persoonlijke voor- en nadelen van gebruik over de tijd
```{r McNemarHBMperceivedbenefitsCoronaMelderutautovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_agree_cw[(data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_agree_cw[(data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_cw == 'Oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_agree_wmin1[(data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_agree_wmin1[(data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_agree_cw, data_currentwave_wavemin1$HBM_perceivedbenefits_CoronaMelder_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_perceivedbenefits_CoronaMelder_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_perceivedbenefits_CoronaMelder_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het persoonlijke voordelen heeft om de CoronaMelder te gebruiken.
```{r McNemarHBMbarriersCoronaMelderutautovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_barriers_CoronaMelder_agree_cw[(data_currentwave_wavemin1$HBM_barriers_CoronaMelder_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_barriers_CoronaMelder_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_barriers_CoronaMelder_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_barriers_CoronaMelder_agree_cw[(data_currentwave_wavemin1$HBM_barriers_CoronaMelder_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_barriers_CoronaMelder_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_barriers_CoronaMelder_cw == 'Oneens'| data_currentwave_wavemin1$HBM_barriers_CoronaMelder_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_barriers_CoronaMelder_agree_wmin1[(data_currentwave_wavemin1$HBM_barriers_CoronaMelder_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_barriers_CoronaMelder_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_barriers_CoronaMelder_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_barriers_CoronaMelder_agree_wmin1[(data_currentwave_wavemin1$HBM_barriers_CoronaMelder_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_barriers_CoronaMelder_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_barriers_CoronaMelder_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_barriers_CoronaMelder_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_barriers_CoronaMelder_agree_cw, data_currentwave_wavemin1$HBM_barriers_CoronaMelder_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Daarnaast liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_barriers_CoronaMelder_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_barriers_CoronaMelder_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het persoonlijke nadelen heeft om de CoronaMelder te gebruiken.

```{r, echo=FALSE, fig.width=5.5, fig.height=3, dpi = 300, fig.cap="Persoonlijke voor- en nadelen van gebruik over de tijd, totaal percentage dat het minstens een beetje eens was met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_perceivedbenefits_CoronaMelder",
                        "HBM_barriers_CoronaMelder")
graph_questionlabels = c("Het heeft voor mij persoonlijke voordelen om de CoronaMelder te gebruiken",
                         "Het heeft voor mij persoonlijke nadelen om de CoronaMelder te gebruiken"); 



# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

### Verplichting tot gebruik
Er is ook gekeken naar de mate waarin iemand een verplichting voelt om de techniek te gebruiken, en hoe mensen reageren als zij het gevoel hebben dat er wordt aangedrongen op het gebruiken van de CoronaMelder. In totaal `r round((nrow(filter(data, (Beliefs_voluntariness == 'Helemaal mee eens'| Beliefs_voluntariness == 'Mee eens'| Beliefs_voluntariness == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% voelt zich verplicht tot het gebruik, en `r round((nrow(filter(data, (Beliefs_voluntariness2 == 'Helemaal mee eens'| Beliefs_voluntariness2 == 'Mee eens'| Beliefs_voluntariness2 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% voelt zich niet vrij om zelf te kiezen of hij/zij de CoronaMelder gebruikt. Daarnaast gaf `r round((nrow(filter(data, (Beliefs_AffectIrritation == 'Helemaal mee eens'| Beliefs_AffectIrritation == 'Mee eens'| Beliefs_AffectIrritation == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan zich te irriteren aan het aandringen op het gebruik van de CoronaMelder en `r round((nrow(filter(data, (Beliefs_AffectAnger == 'Helemaal mee eens'| Beliefs_AffectAnger == 'Mee eens'| Beliefs_AffectAnger == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% is hier boos over.

```{r Voluntariness, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Verplichting tot gebruik", tab.cap="Verplichting tot gebruik", tab.cap="Verplichting tot gebruik", tab.cap="Verplichting tot gebruik"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_voluntariness",
                        "Beliefs_voluntariness2", 
                        "Beliefs_AffectIrritation",
                        "Beliefs_AffectAnger")
graph_questionlabels = c("Ik voel me verplicht om de CoronaMelder te gebruiken",
                         "Ik voel me niet vrij om zelf te kiezen of ik de Coronamelder app gebruik", 
                         "Het irriteert me dat er wordt aangedrongen op het gebruiken van de CoronaMelder app",
                         "Het maakt me boos dat er wordt aangedrongen op het gebruiken van de CoronaMelder app"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])


# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}


# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```



#### Verplichting tot gebruik naar gebruikersstatus
```{r chiBeliefsvoluntarinessusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_voluntariness_agree[(data$Beliefs_voluntariness == 'Helemaal mee eens'| data$Beliefs_voluntariness == 'Mee eens'| data$Beliefs_voluntariness == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_voluntariness_agree[(data$Beliefs_voluntariness == 'Neutraal'| data$Beliefs_voluntariness == 'Een beetje oneens'| data$Beliefs_voluntariness == 'Oneens'| data$Beliefs_voluntariness == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_voluntariness_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_voluntariness_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling zich verplicht te voelen om de CoronaMelder te gebruiken, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_voluntariness_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiBeliefsvoluntariness2usernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_voluntariness2_agree[(data$Beliefs_voluntariness2 == 'Helemaal mee eens'| data$Beliefs_voluntariness2 == 'Mee eens'| data$Beliefs_voluntariness2 == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_voluntariness2_agree[(data$Beliefs_voluntariness2 == 'Neutraal'| data$Beliefs_voluntariness2 == 'Een beetje oneens'| data$Beliefs_voluntariness2 == 'Oneens'| data$Beliefs_voluntariness2 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_voluntariness2_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_voluntariness2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling zich niet vrij te voelen om zelf te kiezen om de CoronaMelder te gebruiken, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_voluntariness2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiBeliefsirritationusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_AffectIrritation_agree[(data$Beliefs_AffectIrritation == 'Helemaal mee eens'| data$Beliefs_AffectIrritation == 'Mee eens'| data$Beliefs_AffectIrritation == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_AffectIrritation_agree[(data$Beliefs_AffectIrritation == 'Neutraal'| data$Beliefs_AffectIrritation == 'Een beetje oneens'| data$Beliefs_AffectIrritation == 'Oneens'| data$Beliefs_AffectIrritation == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_AffectIrritation_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_AffectIrritation_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat zij zich eraan irriteren dat er wordt aangedrongen op het gebruiken van de CoronaMelder, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_AffectIrritation_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiBeliefsangerusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_AffectAnger_agree[(data$Beliefs_AffectAnger == 'Helemaal mee eens'| data$Beliefs_AffectAnger == 'Mee eens'| data$Beliefs_AffectAnger == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_AffectAnger_agree[(data$Beliefs_AffectAnger == 'Neutraal'| data$Beliefs_AffectAnger == 'Een beetje oneens'| data$Beliefs_AffectAnger == 'Oneens'| data$Beliefs_AffectAnger == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_AffectAnger_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_AffectAnger_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat het hen boos maakt dat er wordt aangedrongen op het gebruiken van de CoronaMelder, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_AffectAnger_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  


```{r, echo=FALSE, tab.cap ="Verplichting tot gebruik naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_voluntariness",
                        "Beliefs_voluntariness2", 
                        "Beliefs_AffectIrritation",
                        "Beliefs_AffectAnger")
graph_questionlabels = c("Ik voel me verplicht om de CoronaMelder te gebruiken",
                         "Ik voel me niet vrij om zelf te kiezen of ik de Coronamelder app gebruik", 
                         "Het irriteert me dat er wordt aangedrongen op het gebruiken van de CoronaMelder app",
                         "Het maakt me boos dat er wordt aangedrongen op het gebruiken van de CoronaMelder app"); 


# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))

  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Voormalig gebruiker"))
    
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```

#### Verplichting tot gebruik over de tijd
```{r McNemarBeliefsvoluntarinesovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_voluntariness_agree_cw[(data_currentwave_wavemin1$Beliefs_voluntariness_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_voluntariness_cw == 'Mee eens'| data_currentwave_wavemin1$Beliefs_voluntariness_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Beliefs_voluntariness_agree_cw[(data_currentwave_wavemin1$Beliefs_voluntariness_cw == 'Neutraal'| data_currentwave_wavemin1$Beliefs_voluntariness_cw == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_voluntariness_cw == 'Oneens'| data_currentwave_wavemin1$Beliefs_voluntariness_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_voluntariness_agree_wmin1[(data_currentwave_wavemin1$Beliefs_voluntariness_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_voluntariness_wmin1 == 'Mee eens'| data_currentwave_wavemin1$Beliefs_voluntariness_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Beliefs_voluntariness_agree_wmin1[(data_currentwave_wavemin1$Beliefs_voluntariness_wmin1 == 'Neutraal'| data_currentwave_wavemin1$Beliefs_voluntariness_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_voluntariness_wmin1 == 'Oneens'| data_currentwave_wavemin1$Beliefs_voluntariness_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_voluntariness_agree_cw, data_currentwave_wavemin1$Beliefs_voluntariness_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_voluntariness_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_voluntariness_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat men zich verplicht voelt om de CoronaMelder te gebruiken.

```{r McNemarBeliefsvoluntarines2overtime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_voluntariness2_agree_cw[(data_currentwave_wavemin1$Beliefs_voluntariness2_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_voluntariness2_cw == 'Mee eens'| data_currentwave_wavemin1$Beliefs_voluntariness2_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Beliefs_voluntariness2_agree_cw[(data_currentwave_wavemin1$Beliefs_voluntariness2_cw == 'Neutraal'| data_currentwave_wavemin1$Beliefs_voluntariness2_cw == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_voluntariness2_cw == 'Oneens'| data_currentwave_wavemin1$Beliefs_voluntariness2_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_voluntariness2_agree_wmin1[(data_currentwave_wavemin1$Beliefs_voluntariness2_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_voluntariness2_wmin1 == 'Mee eens'| data_currentwave_wavemin1$Beliefs_voluntariness2_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Beliefs_voluntariness2_agree_wmin1[(data_currentwave_wavemin1$Beliefs_voluntariness2_wmin1 == 'Neutraal'| data_currentwave_wavemin1$Beliefs_voluntariness2_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_voluntariness2_wmin1 == 'Oneens'| data_currentwave_wavemin1$Beliefs_voluntariness2_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_voluntariness2_agree_cw, data_currentwave_wavemin1$Beliefs_voluntariness2_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_voluntariness2_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_voluntariness2_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat men zich niet vrij voelt om zelf te kiezen of hij/zij de CoronaMelder gebruikt.

```{r McNemarBeliefsAffectIrritationovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_AffectIrritation_agree_cw[(data_currentwave_wavemin1$Beliefs_AffectIrritation_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_AffectIrritation_cw == 'Mee eens'| data_currentwave_wavemin1$Beliefs_AffectIrritation_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Beliefs_AffectIrritation_agree_cw[(data_currentwave_wavemin1$Beliefs_AffectIrritation_cw == 'Neutraal'| data_currentwave_wavemin1$Beliefs_AffectIrritation_cw == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_AffectIrritation_cw == 'Oneens'| data_currentwave_wavemin1$Beliefs_AffectIrritation_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_AffectIrritation_agree_wmin1[(data_currentwave_wavemin1$Beliefs_AffectIrritation_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_AffectIrritation_wmin1 == 'Mee eens'| data_currentwave_wavemin1$Beliefs_AffectIrritation_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Beliefs_AffectIrritation_agree_wmin1[(data_currentwave_wavemin1$Beliefs_AffectIrritation_wmin1 == 'Neutraal'| data_currentwave_wavemin1$Beliefs_AffectIrritation_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_AffectIrritation_wmin1 == 'Oneens'| data_currentwave_wavemin1$Beliefs_AffectIrritation_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_AffectIrritation_agree_cw, data_currentwave_wavemin1$Beliefs_AffectIrritation_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_AffectIrritation_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_AffectIrritation_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het aandringen op het gebruik van de CoronaMelder irritatie opwekt.

```{r McNemarBeliefsAffectAngerovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_AffectAnger_agree_cw[(data_currentwave_wavemin1$Beliefs_AffectAnger_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_AffectAnger_cw == 'Mee eens'| data_currentwave_wavemin1$Beliefs_AffectAnger_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Beliefs_AffectAnger_agree_cw[(data_currentwave_wavemin1$Beliefs_AffectAnger_cw == 'Neutraal'| data_currentwave_wavemin1$Beliefs_AffectAnger_cw == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_AffectAnger_cw == 'Oneens'| data_currentwave_wavemin1$Beliefs_AffectAnger_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_AffectAnger_agree_wmin1[(data_currentwave_wavemin1$Beliefs_AffectAnger_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_AffectAnger_wmin1 == 'Mee eens'| data_currentwave_wavemin1$Beliefs_AffectAnger_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Beliefs_AffectAnger_agree_wmin1[(data_currentwave_wavemin1$Beliefs_AffectAnger_wmin1 == 'Neutraal'| data_currentwave_wavemin1$Beliefs_AffectAnger_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_AffectAnger_wmin1 == 'Oneens'| data_currentwave_wavemin1$Beliefs_AffectAnger_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_AffectAnger_agree_cw, data_currentwave_wavemin1$Beliefs_AffectAnger_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_AffectAnger_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_AffectAnger_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het aandringen op het gebruik van de CoronaMelder boosheid opwekt.


```{r, echo=FALSE, fig.width=5.5, fig.height=2.5, dpi = 300, fig.cap="Verplichting tot gebruik over de tijd, totaal percentage dat het minstens een beetje eens was met de stelling (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_voluntariness")
graph_questionlabels = c("Ik voel me verplicht om de CoronaMelder te gebruiken"); 



# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

```{r, echo=FALSE, fig.width=5.5, fig.height=4, dpi = 300, fig.cap="Verplichting tot gebruik over de tijd, totaal percentage dat het minstens een beetje eens was met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_voluntariness",
                        "Beliefs_voluntariness2", 
                        "Beliefs_AffectIrritation",
                        "Beliefs_AffectAnger")
graph_questionlabels = c("Ik voel me verplicht om de CoronaMelder te gebruiken",
                         "Ik voel me niet vrij om zelf te kiezen of ik de Coronamelder app gebruik", 
                         "Het irriteert me dat er wordt aangedrongen op het gebruiken van de CoronaMelder app",
                         "Het maakt me boos dat er wordt aangedrongen op het gebruiken van de CoronaMelder app"); 


# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w2", "w3", "w4")

# Labels for the waves
wave_labels = c("7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-1)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

#### Bron van verplichting tot gebruik
Aan de respondenten (`r nrow(filter(data, (Beliefs_voluntariness == "Een beetje mee eens"| Beliefs_voluntariness == "Mee eens"| Beliefs_voluntariness == "Helemaal mee eens")))`) die aangaven het in meer of mindere mate eens (helemaal mee eens, mee eens, een beetje mee eens) te zijn met de stelling dat ze zich verplicht voelen om de CoronaMelder te gebruiken, is gevraagd wat de aard van deze verplichting is. Een groot deel (`r round((nrow(filter(data, (Beliefs_voluntariness_civic == 'Helemaal mee eens'| Beliefs_voluntariness_civic == 'Mee eens'| Beliefs_voluntariness_civic == 'Een beetje mee eens'))) /nrow(filter(data, (Beliefs_voluntariness == "Een beetje mee eens"| Beliefs_voluntariness == "Mee eens"| Beliefs_voluntariness == "Helemaal mee eens"))))*100, digits = 1)`%) gaf aan het gebruiken van de CoronaMelder als een maatschappelijke verplichting te zien. Het percentage respondenten dat aangaf dat de verplichting gevoeld werd vanuit de werkgever (`r round((nrow(filter(data, (Beliefs_voluntariness_employer == 'Helemaal mee eens'| Beliefs_voluntariness_employer == 'Mee eens'| Beliefs_voluntariness_employer == 'Een beetje mee eens'))) /nrow(filter(data, (Beliefs_voluntariness == "Een beetje mee eens"| Beliefs_voluntariness == "Mee eens"| Beliefs_voluntariness == "Helemaal mee eens"))))*100, digits = 1)`%), opleiding (`r round((nrow(filter(data, (Beliefs_voluntariness_school == 'Helemaal mee eens'| Beliefs_voluntariness_school == 'Mee eens'| Beliefs_voluntariness_school == 'Een beetje mee eens'))) /nrow(filter(data, (Beliefs_voluntariness == "Een beetje mee eens"| Beliefs_voluntariness == "Mee eens"| Beliefs_voluntariness == "Helemaal mee eens"))))*100, digits = 1)`%) of overheid (`r round((nrow(filter(data, (Beliefs_voluntariness_government == 'Helemaal mee eens'| Beliefs_voluntariness_government == 'Mee eens'| Beliefs_voluntariness_government == 'Een beetje mee eens'))) /nrow(filter(data, (Beliefs_voluntariness == "Een beetje mee eens"| Beliefs_voluntariness == "Mee eens"| Beliefs_voluntariness == "Helemaal mee eens"))))*100, digits = 1)`%) was lager. 

Wanneer deze percentages berekend worden exclusief degenen die aangeven 'niet van toepassing', komt dit respectievelijk op `r round((nrow(filter(data, (Beliefs_voluntariness_employer == 'Helemaal mee eens'| Beliefs_voluntariness_employer == 'Mee eens'| Beliefs_voluntariness_employer == 'Een beetje mee eens'))) /nrow(filter(data, (Beliefs_voluntariness_employer == "Een beetje mee eens"| Beliefs_voluntariness_employer == "Mee eens"| Beliefs_voluntariness_employer == "Helemaal mee eens" | Beliefs_voluntariness_employer == "Neutraal" | Beliefs_voluntariness_employer == "Een beetje oneens" | Beliefs_voluntariness_employer == "Oneens"| Beliefs_voluntariness_employer == "Helemaal mee oneens"))))*100, digits = 1)`% voor verplichting vanuit de werkgever of opdrachtgever, op `r round((nrow(filter(data, (Beliefs_voluntariness_school == 'Helemaal mee eens'| Beliefs_voluntariness_school == 'Mee eens'| Beliefs_voluntariness_school == 'Een beetje mee eens'))) /nrow(filter(data, (Beliefs_voluntariness_school == "Een beetje mee eens"| Beliefs_voluntariness_school == "Mee eens"| Beliefs_voluntariness_school == "Helemaal mee eens" | Beliefs_voluntariness_school == "Neutraal" | Beliefs_voluntariness_school == "Een beetje oneens" | Beliefs_voluntariness_school == "Oneens"| Beliefs_voluntariness_school == "Helemaal mee oneens"))))*100, digits = 1)`% voor verplichting vanuit de school of opleiding en voor `r round((nrow(filter(data, (Beliefs_voluntariness_government == 'Helemaal mee eens'| Beliefs_voluntariness_government == 'Mee eens'| Beliefs_voluntariness_government == 'Een beetje mee eens'))) /nrow(filter(data, (Beliefs_voluntariness_government == "Een beetje mee eens"| Beliefs_voluntariness_government == "Mee eens"| Beliefs_voluntariness_government == "Helemaal mee eens" | Beliefs_voluntariness_government == "Neutraal" | Beliefs_voluntariness_government == "Een beetje oneens" | Beliefs_voluntariness_government == "Oneens"| Beliefs_voluntariness_government == "Helemaal mee oneens"))))*100, digits = 1)`% vanuit de overheid. 


```{r, echo=FALSE, fig.width=7, fig.height=2.5, fig.cap="Aard van de verplichting. Percentage dat aangeeft het eens (helemaal mee eens, mee eens, een beetje mee eens) te zijn met de stelling.", tab.cap="Aard van de verplichting. Percentage dat aangeeft het eens (helemaal mee eens, mee eens, een beetje mee eens) te zijn met de stelling."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_voluntariness_employer", 
                        "Beliefs_voluntariness_school", 
                        "Beliefs_voluntariness_government",
                        "Beliefs_voluntariness_civic"
                        )
graph_questionlabels = c("Mijn werkgever of opdrachtgever verplicht mij om de CoronaMelder te gebruiken", 
                         "Mijn school of opleiding verplicht mij om de CoronaMelder te gebruiken", 
                         "De overheid verplicht mij om de CoronaMelder te gebruiken", 
                         "Ik zie het als een maatschappelijke verplichting om de CoronaMelder te gebruiken") 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette8blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Niet van toepassing", "Helemaal mee oneens", "Oneens", "Een beetje oneens", "Neutraal", "Een beetje mee eens", "Mee eens", "Helemaal mee eens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
# NOTE: Filtering out NAs here
data_graph_wideformat = select(data[data$Beliefs_voluntariness == "Een beetje mee eens" | data$Beliefs_voluntariness == "Mee eens" | data$Beliefs_voluntariness == "Helemaal mee eens",], nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

### Affectieve reacties
In kaart is gebracht in welke mate de CoronaMelder in het algemeen en meer specifiek het ontvangen van een melding een emotionele reactie opwekt. Slechts `r round((nrow(filter(data, (Beliefs_fear == 'Helemaal mee eens'| Beliefs_fear == 'Mee eens'| Beliefs_fear == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% geeft aan de CoronaMelder eng te vinden en 
`r round((nrow(filter(data, (Beliefs_fear == 'Neutraal'))) /nrow(data))*100, digits = 1)`% staat hier neutraal tegenover. Een iets groter aandeel zou angstig worden bij het ontvangen van een melding (`r round((nrow(filter(data, (Beliefs_notificationfear == 'Helemaal mee eens'| Beliefs_notificationfear == 'Mee eens'| Beliefs_notificationfear == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) en `r round((nrow(filter(data, (Beliefs_notificationfear == 'Neutraal'))) /nrow(data))*100, digits = 1)`% staat hier neutraal in.

```{r Affective, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Affectieve reacties", tab.cap="Affectieve reacties"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_fear", 
                        "Beliefs_notificationfear")
graph_questionlabels = c("Ik vind de CoronaMelder eng", 
                         "Ik zou angstig worden als ik een melding ontvang van de CoronaMelder"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```
#### Affectieve reacties naar gebruikersstatus
```{r chiBeliefs_fearusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_fear_agree[(data$Beliefs_fear == 'Helemaal mee eens'| data$Beliefs_fear == 'Mee eens'| data$Beliefs_fear == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_fear_agree[(data$Beliefs_fear == 'Neutraal'| data$Beliefs_fear == 'Een beetje oneens'| data$Beliefs_fear == 'Oneens'| data$Beliefs_fear == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_fear_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_fear_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat ze de CoronaMelder eng vinden vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_fear_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  


```{r chiBeliefs_notificationfearusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_notificationfear_agree[(data$Beliefs_notificationfear == 'Helemaal mee eens'| data$Beliefs_notificationfear == 'Mee eens'| data$Beliefs_notificationfear == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_notificationfear_agree[(data$Beliefs_notificationfear == 'Neutraal'| data$Beliefs_notificationfear == 'Een beetje oneens'| data$Beliefs_notificationfear == 'Oneens'| data$Beliefs_notificationfear == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_notificationfear_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_notificationfear_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij angstig zou worden na het ontvangen van een melding van de CoronaMelder app vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_notificationfear_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  


```{r, echo=FALSE, tab.cap ="Affectieve reakties naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_fear", 
                        "Beliefs_notificationfear")                     
graph_questionlabels = c("Ik vind de CoronaMelder app eng", 
                         "Ik zou angstig worden als ik een melding ontvang van de CoronaMelder app") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))

  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Voormalig gebruiker"))
    
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```


#### Affectieve reacties over de tijd
```{r McNemarBeliefs_fearovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_fear_agree_cw[(data_currentwave_wavemin1$Beliefs_fear_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_fear_cw == 'Mee eens'| data_currentwave_wavemin1$Beliefs_fear_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Beliefs_fear_agree_cw[(data_currentwave_wavemin1$Beliefs_fear_cw == 'Neutraal'| data_currentwave_wavemin1$Beliefs_fear_cw == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_fear_cw == 'Oneens'| data_currentwave_wavemin1$Beliefs_fear_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_fear_agree_wmin1[(data_currentwave_wavemin1$Beliefs_fear_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_fear_wmin1 == 'Mee eens'| data_currentwave_wavemin1$Beliefs_fear_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Beliefs_fear_agree_wmin1[(data_currentwave_wavemin1$Beliefs_fear_wmin1 == 'Neutraal'| data_currentwave_wavemin1$Beliefs_fear_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_fear_wmin1 == 'Oneens'| data_currentwave_wavemin1$Beliefs_fear_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_fear_agree_cw, data_currentwave_wavemin1$Beliefs_fear_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_fear_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_fear_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat men de CoronaMelder app eng vindt. 
```{r McNemarBeliefs_notificationfear, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_notificationfear_agree_cw[(data_currentwave_wavemin1$Beliefs_notificationfear_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_notificationfear_cw == 'Mee eens'| data_currentwave_wavemin1$Beliefs_notificationfear_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Beliefs_notificationfear_agree_cw[(data_currentwave_wavemin1$Beliefs_notificationfear_cw == 'Neutraal'| data_currentwave_wavemin1$Beliefs_notificationfear_cw == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_notificationfear_cw == 'Oneens'| data_currentwave_wavemin1$Beliefs_notificationfear_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_notificationfear_agree_wmin1[(data_currentwave_wavemin1$Beliefs_notificationfear_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_notificationfear_wmin1 == 'Mee eens'| data_currentwave_wavemin1$Beliefs_notificationfear_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Beliefs_notificationfear_agree_wmin1[(data_currentwave_wavemin1$Beliefs_notificationfear_wmin1 == 'Neutraal'| data_currentwave_wavemin1$Beliefs_notificationfear_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_notificationfear_wmin1 == 'Oneens'| data_currentwave_wavemin1$Beliefs_notificationfear_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_notificationfear_agree_cw, data_currentwave_wavemin1$Beliefs_notificationfear_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Daarnaast liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_notificationfear_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_notificationfear_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat men angstig zou worden als men een melding ontvangt van de CoronaMelder app.

```{r, echo=FALSE, fig.width=5.5, fig.height=3, dpi = 300, fig.cap="Affectieve reacties over de tijd, totaal percentage dat het minstens een beetje eens was met de stelling (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_fear", 
                        "Beliefs_notificationfear")                     
graph_questionlabels = c("Ik vind de CoronaMelder app eng", 
                         "Ik zou angstig worden als ik een melding ontvang van de CoronaMelder app") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

### Sociale invloeden
Om de sociale invloeden in kaart te brengen is gevraagd naar descriptieve en injunctieve normen en is gevraagd om een indicatie te geven van welk percentage van de Nederlandse bevolking de CoronaMelder gebruikt. Opvallend is dat een relatief laag percentage (`r round((nrow(filter(data, (SI1_UTAUT == 'Helemaal mee eens'| SI1_UTAUT == 'Mee eens'| SI1_UTAUT == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) van de respondenten het eens is met de stelling dat veel mensen in hun omgeving de CoronaMelder gebruiken. Daarnaast staat een groot deel neutraal tegenover deze stelling (`r round((nrow(filter(data, (SI1_UTAUT == 'Neutraal'))) /nrow(data))*100, digits = 1)`%).

Ook de injunctieve norm is nauwelijks aanwezig, meer dan de helft is het oneens met de stelling 'Mensen in mijn directe omgeving vinden dat ik de CoronaMelder moet gebruiken' (`r round((nrow(filter(data, (SI2_UTAUT == 'Helemaal mee oneens'| SI2_UTAUT == 'Oneens'| SI2_UTAUT == 'Een beetje oneens'))) /nrow(data))*100, digits = 1)`%), en ook een aanzienlijk percentage staat hier neutraal in (`r round((nrow(filter(data, (SI2_UTAUT == 'Neutraal'))) /nrow(data))*100, digits = 1)`%). Van de respondenten is `r round((nrow(filter(data, (Beliefs_civicduty == 'Helemaal mee eens'| Beliefs_civicduty == 'Mee eens'| Beliefs_civicduty == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% het eens met de stelling dat de CoronaMelder je een goede burger maakt.

```{r Socialnormscivicduty, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Sociale normen", tab.cap="Sociale normen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("SI1_UTAUT", 
                        "SI2_UTAUT",
                        "Beliefs_civicduty")
graph_questionlabels = c("Veel mensen in mijn omgeving gebruiken de CoronaMelder", 
                         "Mensen in mijn directe omgeving vinden dat ik de CoronaMelder moet gebruiken",
                         "Het gebruiken van de CoronaMelder maakt je een goede burger"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Er werd ook gevraagd aan de respondenten hoeveel procent van de Nederlandse bevolking zij dachten dat de CoronaMelder gebruikt. De meeste respondenten (`r round((nrow(filter(data, (Beliefs_AppAdoption == '26-50%'))) /nrow(data))*100, digits = 1)`%) dachten dat tussen de 26 en 50% van de bevolking de CoronaMelder gebruikt, gevolgd door de categorie van 11 tot 25% (`r round((nrow(filter(data, (Beliefs_AppAdoption == '11-25%'))) /nrow(data))*100, digits = 1)`%).


```{r Beliefsappadoption, echo=FALSE, fig.width=5.5, fig.height=3, fig.cap="Percentage Nederlandse bevolking dat volgens de respondent de CoronaMelder gebruikt", tab.cap="Percentage Nederlandse bevolking dat volgens de respondent de CoronaMelder gebruikt"}
ggplot(data=data, aes(x = Beliefs_AppAdoption)) + theme_bw() + xlab(paste(names(table(data$Beliefs_AppAdoption)))) + ylab(" ") + xlab("") + geom_bar(fill = "#bdd7e7", color = "#6baed6") + theme(plot.margin = margin(0, 0.1, 0, 0)) + theme(axis.title=element_text(size=10))

graph_variablenames = "Beliefs_AppAdoption"
graph_questionlabels = "Hoeveel procent van de Nederlandse bevolking denkt u dat de CoronaMelder app gebruikt?"

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


#### Sociale invloeden naar gebruikersstatus
Chi kwadraat toetsen zijn uitgevoerd om te bepalen of het totaal aandeel respondenten dat het eens  (een beetje, eens, helemaal mee eens) is met de stellingen verschilt tussen de huidige gebruikers en degenen die de CoronaMelder nooit gebruikt hebben.  
```{r chiSI1utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$SI1_UTAUT_agree[(data$SI1_UTAUT == 'Helemaal mee eens'| data$SI1_UTAUT == 'Mee eens'| data$SI1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$SI1_UTAUT_agree[(data$SI1_UTAUT == 'Neutraal'| data$SI1_UTAUT == 'Een beetje oneens'| data$SI1_UTAUT == 'Oneens'| data$SI1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$SI1_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& SI1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat veel mensen in de omgeving de CoronaMelder gebruiken vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & SI1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  


```{r chiSI2utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$SI2_UTAUT_agree[(data$SI2_UTAUT == 'Helemaal mee eens'| data$SI2_UTAUT == 'Mee eens'| data$SI2_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$SI2_UTAUT_agree[(data$SI2_UTAUT == 'Neutraal'| data$SI2_UTAUT == 'Een beetje oneens'| data$SI2_UTAUT == 'Oneens'| data$SI2_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$SI2_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& SI2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat veel mensen in de omgeving vinden dat hij/zij de CoronaMelder moet gebruiken vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & SI2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  


```{r chiBeliefscivicdutyusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_civicduty_agree[(data$Beliefs_civicduty == 'Helemaal mee eens'| data$Beliefs_civicduty == 'Mee eens'| data$Beliefs_civicduty == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_civicduty_agree[(data$Beliefs_civicduty == 'Neutraal'| data$Beliefs_civicduty == 'Een beetje oneens'| data$Beliefs_civicduty == 'Oneens'| data$Beliefs_civicduty == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_civicduty_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_civicduty_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat het gebruiken van de CoronaMelder je een goed burger maakt vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_civicduty_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  


```{r, echo=FALSE, tab.cap ="Sociale normen naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("SI1_UTAUT", 
                        "SI2_UTAUT", 
                        "Beliefs_civicduty")                     
graph_questionlabels = c("Veel mensen in mijn omgeving gebruiken de CoronaMelder app", 
                         "Mensen in mijn directe omgeving vinden dat ik de CoronaMelder app moet gebruiken", 
                         "Het gebruiken van de CoronaMelder maakt je een goed burger") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))

  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Voormalig gebruiker"))
    
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```


```{r echo=FALSE, results="asis"}
graph_variablenames = c("SI1_UTAUT", 
                        "SI2_UTAUT",
                        "Beliefs_civicduty")
graph_questionlabels = c("Veel mensen in mijn omgeving gebruiken de CoronaMelder", 
                         "Mensen in mijn directe omgeving vinden dat ik de CoronaMelder moet gebruiken",
                         "Het gebruiken van de CoronaMelder maakt je een goede burger")
# For each of these variables we would like to test if the current users and non users differ in the proportion that agrees with the statement. 
# First calculate a proportion for the variable. 
data$SI1_UTAUT_agree[(data$SI1_UTAUT == 'Helemaal mee eens'| data$SI1_UTAUT == 'Mee eens'| data$SI1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$SI1_UTAUT_agree[(data$SI1_UTAUT == 'Neutraal'| data$SI1_UTAUT == 'Een beetje oneens'| data$SI1_UTAUT == 'Oneens'| data$SI1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
#View(data[,c("SI1_UTAUT","SI1_UTAUT_agree")])
testtable = table(data$SI1_UTAUT_agree, data$user_status)
#chisq.test(testtable) 

#tab1 <- tableby(SI1_UTAUT_agree ~ user_status + geslacht + lftdcat + sted + belbezig, data=data_selected)
#summary(tab1)
```


#### Sociale invloeden over de tijd

```{r McNemarSI1utautovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$SI1_UTAUT_agree_cw[(data_currentwave_wavemin1$SI1_UTAUT_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$SI1_UTAUT_cw == 'Mee eens'| data_currentwave_wavemin1$SI1_UTAUT_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$SI1_UTAUT_agree_cw[(data_currentwave_wavemin1$SI1_UTAUT_cw == 'Neutraal'| data_currentwave_wavemin1$SI1_UTAUT_cw == 'Een beetje oneens'| data_currentwave_wavemin1$SI1_UTAUT_cw == 'Oneens'| data_currentwave_wavemin1$SI1_UTAUT_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$SI1_UTAUT_agree_wmin1[(data_currentwave_wavemin1$SI1_UTAUT_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$SI1_UTAUT_wmin1 == 'Mee eens'| data_currentwave_wavemin1$SI1_UTAUT_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$SI1_UTAUT_agree_wmin1[(data_currentwave_wavemin1$SI1_UTAUT_wmin1 == 'Neutraal'| data_currentwave_wavemin1$SI1_UTAUT_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$SI1_UTAUT_wmin1 == 'Oneens'| data_currentwave_wavemin1$SI1_UTAUT_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$SI1_UTAUT_agree_cw, data_currentwave_wavemin1$SI1_UTAUT_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (SI1_UTAUT_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (SI1_UTAUT_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat veel mensen in de omgeving de CoronaMelder gebruiken. 
```{r McNemarSI2utautovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$SI2_UTAUT_agree_cw[(data_currentwave_wavemin1$SI2_UTAUT_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$SI2_UTAUT_cw == 'Mee eens'| data_currentwave_wavemin1$SI2_UTAUT_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$SI2_UTAUT_agree_cw[(data_currentwave_wavemin1$SI2_UTAUT_cw == 'Neutraal'| data_currentwave_wavemin1$SI2_UTAUT_cw == 'Een beetje oneens'| data_currentwave_wavemin1$SI2_UTAUT_cw == 'Oneens'| data_currentwave_wavemin1$SI2_UTAUT_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$SI2_UTAUT_agree_wmin1[(data_currentwave_wavemin1$SI2_UTAUT_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$SI2_UTAUT_wmin1 == 'Mee eens'| data_currentwave_wavemin1$SI2_UTAUT_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$SI2_UTAUT_agree_wmin1[(data_currentwave_wavemin1$SI2_UTAUT_wmin1 == 'Neutraal'| data_currentwave_wavemin1$SI2_UTAUT_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$SI2_UTAUT_wmin1 == 'Oneens'| data_currentwave_wavemin1$SI2_UTAUT_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$SI2_UTAUT_agree_cw, data_currentwave_wavemin1$SI2_UTAUT_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (SI2_UTAUT_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (SI2_UTAUT_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat mensen in de directe omgeving vinden dat hij of zij de CoronaMelder moet gebruiken.
```{r McNemarbeliefscivicdutyovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_civicduty_agree_cw[(data_currentwave_wavemin1$Beliefs_civicduty_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_civicduty_cw == 'Mee eens'| data_currentwave_wavemin1$Beliefs_civicduty_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Beliefs_civicduty_agree_cw[(data_currentwave_wavemin1$Beliefs_civicduty_cw == 'Neutraal'| data_currentwave_wavemin1$Beliefs_civicduty_cw == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_civicduty_cw == 'Oneens'| data_currentwave_wavemin1$Beliefs_civicduty_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_civicduty_agree_wmin1[(data_currentwave_wavemin1$Beliefs_civicduty_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$Beliefs_civicduty_wmin1 == 'Mee eens'| data_currentwave_wavemin1$Beliefs_civicduty_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Beliefs_civicduty_agree_wmin1[(data_currentwave_wavemin1$Beliefs_civicduty_wmin1 == 'Neutraal'| data_currentwave_wavemin1$Beliefs_civicduty_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$Beliefs_civicduty_wmin1 == 'Oneens'| data_currentwave_wavemin1$Beliefs_civicduty_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_civicduty_agree_cw, data_currentwave_wavemin1$Beliefs_civicduty_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_civicduty_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_civicduty_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het gebruiken van de CoronaMelder je een goede burger maakt. 

```{r, echo=FALSE, fig.width=5.5, fig.height=3.5, dpi = 300, fig.cap="Sociale invloeden over de tijd, totaal percentage dat het minstens een beetje eens was met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("SI1_UTAUT", 
                        "SI2_UTAUT", 
                        "Beliefs_civicduty")                     
graph_questionlabels = c("Veel mensen in mijn omgeving gebruiken de CoronaMelder app", 
                         "Mensen in mijn directe omgeving vinden dat ik de CoronaMelder app moet gebruiken", 
                         "Het gebruiken van de CoronaMelder maakt je een goed burger") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

### Privacy en dataveiligheid 
Nog een factor die een rol kan spelen in de adoptie is de verwachting met betrekking tot de privacy en dataveiligheid. Een opvallend groot aandeel beoordeelt de foutieve stellingen dat de CoronaMelder de locatie bijhoudt (`r round((nrow(filter(data, (Beliefs_locationmonitoring == 'Zeker waar'| Beliefs_locationmonitoring == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%) en dat de CoronaMelder persoonsgegevens opslaat (`r round((nrow(filter(data, (Beliefs_identitymonitoring == 'Zeker waar'| Beliefs_identitymonitoring == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%) als waar. Daartegenover staat wel dat men het idee heeft dat er vertrouwelijk wordt omgegaan met de informatie (`r round((nrow(filter(data, (Beliefs_datasafety == 'Zeker waar'| Beliefs_datasafety == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%). 

Opvallend is dat `r round((nrow(filter(data, (Beliefs_surveillancestate1 == 'Zeker waar'| Beliefs_surveillancestate1 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`% denkt dat het waar is dat het gebruik van de CoronaMelder zorgt dat de overheid meer controle over de bevolking krijgt en dat `r round((nrow(filter(data, (Beliefs_surveillancestate2 == 'Zeker waar'| Beliefs_surveillancestate2 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`% denkt dat door het gebruiken van de CoronaMelder de technologische bedrijven meer macht krijgen. 


```{r privacy, echo=FALSE, fig.width=7, fig.height=3.5, fig.cap="Privacy overtuigingen", tab.cap="Privacy overtuigingen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_datasafety",
                        "Beliefs_locationmonitoring", 
                        "Beliefs_identitymonitoring",
                        "Beliefs_surveillancestate1",
                        "Beliefs_surveillancestate2")
graph_questionlabels = c("Alle informatie die ik geef in de CoronaMelder wordt vertrouwelijk behandeld",
                         "De CoronaMelder houdt mijn locatie bij", 
                         "De CoronaMelder slaat mijn naam of persoonsgegevens op",
                         "Het gebruik van de CoronaMelder zorgt ervoor dat de overheid meer controle over de bevolking krijgt",
                         "Het gebruik van de CoronaMelder zorgt ervoor dat technologische bedrijven meer macht krijgen"); 

# These questions have 5 answer categories: Zeker niet waar - Zeker waar en Weet ik niet. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Zeker waar", "Misschien waar", "Misschien niet waar", "Zeker niet waar"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out

```
#### Privacy en dataveiligheid naar gebruikersstatus
```{r chiBeliefsdatasafetyusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_datasafety_agree[(data$Beliefs_datasafety == 'Zeker waar'| data$Beliefs_datasafety == 'Misschien waar')] <- "Totaal waar"
data$Beliefs_datasafety_agree[(data$Beliefs_datasafety == 'Weet ik niet'| data$Beliefs_datasafety == 'Zeker niet waar'| data$Beliefs_datasafety == 'Misschien niet waar')] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_datasafety_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_datasafety_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat denkt dat het waar is dat de informatie in de CoronaMelder app strikt vertrouwelijk wordt gehouden, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_datasafety_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%). 


```{r chiBeliefslocationmonitoringusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_locationmonitoring_agree[(data$Beliefs_locationmonitoring == 'Zeker waar'| data$Beliefs_locationmonitoring == 'Misschien waar')] <- "Totaal waar"
data$Beliefs_locationmonitoring_agree[(data$Beliefs_locationmonitoring == 'Weet ik niet'| data$Beliefs_locationmonitoring == 'Zeker niet waar'| data$Beliefs_locationmonitoring == 'Misschien niet waar')] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_locationmonitoring_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_locationmonitoring_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat denkt dat de CoronaMelder de locatie van de gebruiker bijhoudt, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_locationmonitoring_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%). 


```{r chiBeliefsidentitymonitoringusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_identitymonitoring_agree[(data$Beliefs_identitymonitoring == 'Zeker waar'| data$Beliefs_identitymonitoring == 'Misschien waar')] <- "Totaal waar"
data$Beliefs_identitymonitoring_agree[(data$Beliefs_identitymonitoring == 'Weet ik niet'| data$Beliefs_identitymonitoring == 'Zeker niet waar'| data$Beliefs_identitymonitoring == 'Misschien niet waar')] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_identitymonitoring_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_identitymonitoring_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat denkt dat de CoronaMelder de naam of persoonsgegevens van de gebruiker bijhoudt, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_identitymonitoring_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%). 


```{r chiBeliefssurveillance1usernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_surveillancestate1_agree[(data$Beliefs_surveillancestate1 == 'Zeker waar'| data$Beliefs_surveillancestate1 == 'Misschien waar')] <- "Totaal waar"
data$Beliefs_surveillancestate1_agree[(data$Beliefs_surveillancestate1 == 'Weet ik niet'| data$Beliefs_surveillancestate1 == 'Zeker niet waar'| data$Beliefs_surveillancestate1 == 'Misschien niet waar')] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_surveillancestate1_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_surveillancestate1_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat denkt dat het gebruik van de CoronaMelder app ervoor zorgt dat de overheid meer controle over de bevolking krijgt, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_surveillancestate1_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%). 

```{r chiBeliefssurveillance2usernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_surveillancestate2_agree[(data$Beliefs_surveillancestate2 == 'Zeker waar'| data$Beliefs_surveillancestate2 == 'Misschien waar')] <- "Totaal waar"
data$Beliefs_surveillancestate2_agree[(data$Beliefs_surveillancestate2 == 'Weet ik niet'| data$Beliefs_surveillancestate2 == 'Zeker niet waar'| data$Beliefs_surveillancestate2 == 'Misschien niet waar')] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_surveillancestate2_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_surveillancestate2_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat denkt dat het gebruik van de CoronaMelder app ervoor zorgt dat technologische bedrijven (bv. Google en Apple) meer macht krijgen, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_surveillancestate2_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%). 


```{r, echo=FALSE, tab.cap ="Privacy en dataveiligheid naar gebruikersstatus. Aantal en totaal percentage waar (misschien waar, zeker waar)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_datasafety",
                        "Beliefs_locationmonitoring", 
                        "Beliefs_identitymonitoring",
                        "Beliefs_surveillancestate1",
                        "Beliefs_surveillancestate2")
graph_questionlabels = c("Alle informatie die ik geef in de CoronaMelder wordt vertrouwelijk behandeld",
                         "De CoronaMelder houdt mijn locatie bij", 
                         "De CoronaMelder slaat mijn naam of persoonsgegevens op",
                         "Het gebruik van de CoronaMelder app zorgt ervoor dat de overheid meer controle over de bevolking krijgt",
                         "Het gebruik van de CoronaMelder app zorgt ervoor dat technologische bedrijven (bv. Google en Apple) meer macht krijgen"); 


# Which values do we want to include in the table cells?
include_vars = c("Zeker waar", "Misschien waar")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Voormalig gebruiker"))
  
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```

#### Privacy en dataveiligheid over de tijd
```{r McNemarBeliefsdatasafetyovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_datasafety_agree_cw[(data_currentwave_wavemin1$Beliefs_datasafety_cw == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_datasafety_cw == 'Misschien waar')] <- "Totaal waar_cw"
data_currentwave_wavemin1$Beliefs_datasafety_agree_cw[(data_currentwave_wavemin1$Beliefs_datasafety_cw == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_datasafety_cw == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_datasafety_cw == 'Misschien niet waar')] <- "Weet niet, niet waar_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_datasafety_agree_wmin1[(data_currentwave_wavemin1$Beliefs_datasafety_wmin1 == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_datasafety_wmin1 == 'Misschien waar')] <- "Totaal waar_wmin1"
data_currentwave_wavemin1$Beliefs_datasafety_agree_wmin1[(data_currentwave_wavemin1$Beliefs_datasafety_wmin1 == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_datasafety_wmin1 == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_datasafety_wmin1 == 'Misschien niet waar')] <- "Weet niet, niet waar_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_datasafety_agree_cw, data_currentwave_wavemin1$Beliefs_datasafety_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table) 
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_datasafety_agree_cw == 'Totaal waar_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_datasafety_agree_wmin1 == 'Totaal waar_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf dat de stelling dat alle informatie die men geeft in de CoronaMelder vertrouwelijk wordt behandeld, waar is.  
```{r McNemarBeliefslocationmonitoringovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_locationmonitoring_agree_cw[(data_currentwave_wavemin1$Beliefs_locationmonitoring_cw == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_locationmonitoring_cw == 'Misschien waar')] <- "Totaal waar_cw"
data_currentwave_wavemin1$Beliefs_locationmonitoring_agree_cw[(data_currentwave_wavemin1$Beliefs_locationmonitoring_cw == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_locationmonitoring_cw == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_locationmonitoring_cw == 'Misschien niet waar')] <- "Weet niet, niet waar_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_locationmonitoring_agree_wmin1[(data_currentwave_wavemin1$Beliefs_locationmonitoring_wmin1 == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_locationmonitoring_wmin1 == 'Misschien waar')] <- "Totaal waar_wmin1"
data_currentwave_wavemin1$Beliefs_locationmonitoring_agree_wmin1[(data_currentwave_wavemin1$Beliefs_locationmonitoring_wmin1 == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_locationmonitoring_wmin1 == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_locationmonitoring_wmin1 == 'Misschien niet waar')] <- "Weet niet, niet waar_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_locationmonitoring_agree_cw, data_currentwave_wavemin1$Beliefs_locationmonitoring_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table) 
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Ook liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_locationmonitoring_agree_cw == 'Totaal waar_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_locationmonitoring_agree_wmin1 == 'Totaal waar_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf dat de stelling dat de CoronaMelder de locatie van de gebruiker bijhoudt, waar is.  
```{r McNemarBeliefsidenditymonitoringovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_identitymonitoring_agree_cw[(data_currentwave_wavemin1$Beliefs_identitymonitoring_cw == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_identitymonitoring_cw == 'Misschien waar')] <- "Totaal waar_cw"
data_currentwave_wavemin1$Beliefs_identitymonitoring_agree_cw[(data_currentwave_wavemin1$Beliefs_identitymonitoring_cw == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_identitymonitoring_cw == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_identitymonitoring_cw == 'Misschien niet waar')] <- "Weet niet, niet waar_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_identitymonitoring_agree_wmin1[(data_currentwave_wavemin1$Beliefs_identitymonitoring_wmin1 == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_identitymonitoring_wmin1 == 'Misschien waar')] <- "Totaal waar_wmin1"
data_currentwave_wavemin1$Beliefs_identitymonitoring_agree_wmin1[(data_currentwave_wavemin1$Beliefs_identitymonitoring_wmin1 == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_identitymonitoring_wmin1 == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_identitymonitoring_wmin1 == 'Misschien niet waar')] <- "Weet niet, niet waar_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_identitymonitoring_agree_cw, data_currentwave_wavemin1$Beliefs_identitymonitoring_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table) 
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Daarnaast liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_identitymonitoring_agree_cw == 'Totaal waar_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_identitymonitoring_agree_wmin1 == 'Totaal waar_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf dat de stelling dat de CoronaMelder namen of persoonsgegevens opslaat, waar is.  

```{r McNemarBeliefscontrolpopovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_surveillancestate1_agree_cw[(data_currentwave_wavemin1$Beliefs_surveillancestate1_cw == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_surveillancestate1_cw == 'Misschien waar')] <- "Totaal waar_cw"
data_currentwave_wavemin1$Beliefs_surveillancestate1_agree_cw[(data_currentwave_wavemin1$Beliefs_surveillancestate1_cw == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_surveillancestate1_cw == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_surveillancestate1_cw == 'Misschien niet waar')] <- "Weet niet, niet waar_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_surveillancestate1_agree_wmin1[(data_currentwave_wavemin1$Beliefs_surveillancestate1_wmin1 == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_surveillancestate1_wmin1 == 'Misschien waar')] <- "Totaal waar_wmin1"
data_currentwave_wavemin1$Beliefs_surveillancestate1_agree_wmin1[(data_currentwave_wavemin1$Beliefs_surveillancestate1_wmin1 == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_surveillancestate1_wmin1 == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_surveillancestate1_wmin1 == 'Misschien niet waar')] <- "Weet niet, niet waar_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_surveillancestate1_agree_cw, data_currentwave_wavemin1$Beliefs_surveillancestate1_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table) 
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Verder liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_surveillancestate1_agree_cw == 'Totaal waar_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_surveillancestate1_agree_wmin1 == 'Totaal waar_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf dat de stelling dat het gebruiken van de CoronaMelder ervoor zorgt dat de overheid meer controle over de bevolking krijgt, waar is.  

```{r McNemarBeliefscontroltechcompovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_surveillancestate2_agree_cw[(data_currentwave_wavemin1$Beliefs_surveillancestate2_cw == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_surveillancestate2_cw == 'Misschien waar')] <- "Totaal waar_cw"
data_currentwave_wavemin1$Beliefs_surveillancestate2_agree_cw[(data_currentwave_wavemin1$Beliefs_surveillancestate2_cw == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_surveillancestate2_cw == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_surveillancestate2_cw == 'Misschien niet waar')] <- "Weet niet, niet waar_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_surveillancestate2_agree_wmin1[(data_currentwave_wavemin1$Beliefs_surveillancestate2_wmin1 == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_surveillancestate2_wmin1 == 'Misschien waar')] <- "Totaal waar_wmin1"
data_currentwave_wavemin1$Beliefs_surveillancestate2_agree_wmin1[(data_currentwave_wavemin1$Beliefs_surveillancestate2_wmin1 == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_surveillancestate2_wmin1 == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_surveillancestate2_wmin1 == 'Misschien niet waar')] <- "Weet niet, niet waar_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_surveillancestate2_agree_cw, data_currentwave_wavemin1$Beliefs_surveillancestate2_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table) 
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Ook liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_surveillancestate2_agree_cw == 'Totaal waar_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_surveillancestate2_agree_wmin1 == 'Totaal waar_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf dat de stelling dat het gebruiken van de CoronaMelder ervoor zorgt dat technologische bedrijven (bv. Google en Apple) meer controle over de bevolking krijgt, waar is.  



```{r, echo=FALSE, fig.width=5.5, fig.height=3.5, dpi = 300, fig.cap="Privacy en dataveiligheid over de tijd, totaal percentage dat de stellingen minstens misschien waar vond (misschien waar, zeker waar)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_datasafety",
                        "Beliefs_locationmonitoring", 
                        "Beliefs_identitymonitoring")
graph_questionlabels = c("Alle informatie die ik geef in de CoronaMelder wordt vertrouwelijk behandeld",
                         "De CoronaMelder houdt mijn locatie bij", 
                         "De CoronaMelder slaat mijn naam of persoonsgegevens op"); 


# Which values do we want to include in the table cells?
include_vars = c("Zeker waar", "Misschien waar")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

```{r, echo=FALSE, fig.width=5.5, fig.height=3, dpi = 300, fig.cap="Controle van de overheid en macht van technologische bedrijven over de tijd, totaal percentage dat de stellingen minstens misschien waar vond (misschien waar, zeker waar)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_surveillancestate1",
                        "Beliefs_surveillancestate2")
graph_questionlabels = c("Het gebruik van de CoronaMelder app zorgt ervoor dat de overheid meer controle over de bevolking krijgt",
                         "Het gebruik van de CoronaMelder app zorgt ervoor dat technologische bedrijven (bv. Google en Apple) meer macht krijgen"); 


# Which values do we want to include in the table cells?
include_vars = c("Zeker waar", "Misschien waar")

# Which waves do we want to include in the table cells?
include_waves = c("w2", "w3", "w4")

# Labels for the waves
wave_labels = c("7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-1)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

## Verklarende modellen voor adoptie

Om te onderzoeken welke factoren samenhangen met het gebruik van de CoronaMelder zijn er drie verklarende modellen opgesteld met de variabelen uit deze vierde meting, namelijk 1) een model met algemene technologie adoptie variabelen op basis van de Unified Theory of Acceptance and Use of Technology (UTAUT), 2) een model met variabelen specifiek voor interventies gericht op gezondheid - op basis van het Health Belief Model (HBM), en 3) een model met variabelen specifiek voor de context van de huidige corona pandemie en speciek voor digitale contact tracing applicaties, zoals bijvoorbeeld vertrouwen in de overheidsaanpak, complottheorieën, en overtuigingen met betrekking tot de privacy. Een overzicht van alle predictievariabelen en model fit per model is te vinden in de Appendix (6.2 en 6.3).

### Verklarend model adoptie op basis van het UTAUT
Om te onderzoeken welke technologie adoptie variabelen samenhangen met CoronaMelder gebruik, is er een analyse uitgevoerd met de UTAUT voorspellers als onafhankelijke variabelen en CoronaMelder adoptie als afhankelijke variabele. Uit de analyse bleek dat verwachte inspanning (*β* = .23, *p* = .002), verwachte effectiviteit (*β* = .20, *p* < .001) en sociale invloed (*β * = .38, *p* < .001) positief samenhangen met CoronaMelder adoptie. Ook het gevoel van verplichting tot gebruik (d.w.z., hoe sterker het gevoel van verplichting, hoe hoger de CoronaMelder adoptie; *β* = .21, *p* < .001), en faciliterende omstandigheden (*β* = .20, *p* = .017) hebben een positief effect op CoronaMelder adoptie. Tot slot bleek uit deze analyse dat leeftijd een positief effect heeft op CoronaMelder adoptie (*β* = .07, *p* = .038), terwijl geslacht geen rol speelt. 

### Verklarend model adoptie op basis van het HBM
Daarnaast is onderzocht in hoeverre variabelen gerelateerd aan interventies gericht op gezondheid een rol spelen in het voorspellen van CoronaMelder adoptie. Hiervoor is een analyse uitgevoerd met onafhankelijke variabelen zoals in het HBM gespecifieerd, en CoronaMelder gebruik als afhankelijke variabele. Uit de analyse bleek dat gepercipieerde voordelen een positieve (*β* = .47, *p* < .001), en gepercipieerde barrières een negatieve invloed hebben (*β* = -.14, *p* < .001) op CoronaMelder adoptie. Daarnaast heeft de mate waarin men het gevoel heeft in staat te zijn om de CoronaMelder te gebruiken (m.a.w., self-efficacy), een positieve relatie met CoronaMelder gebruik (*β* = .31, *p* < .001). De perceptie van de vatbaarheid om besmet te raken met het coronavirus (perceived susceptibility) en hoe erg men het zou vinden om besmet te raken (perceveived severity) speelden geen rol, evenals leeftijd, geslacht, en de mate waarin men de CoronaMelder voorbij heeft zien komen in de media/het nieuws. 

### Verklarend model adoptie op basis van context-specifieke variabelen
Ook variabelen specifiek voor de context van de huidige corona pandemie zijn onderzocht. In deze analyse is bekeken in hoeverre deze context-specifieke variabelen samenhangen met CoronaMelder gebruik. Een factoranalyse is uitgevoerd om variabelen te clusteren die sterk met elkaar samenhingen. Uit de factoranalyse werden vier factoren onderscheiden: 
1) Maatschappelijk-gerelateerde overtuigingen(*α* = .83): de overtuiging dat de CoronaMelder bijdraagt aan Nederlandse economie en aan goed burgerschap, het vertrouwen dat men heeft in de overheid, de overtuiging dat risicogroepen worden beschermd, en dataveiligheid; 2) Privacy-gerelateerde overtuigingen (*α* = .74): de mate waarin men de overtuiging heeft dat de CoronaMelder de locatie bijhoudt en persoonsgegevens opslaat; 3) Angst-gerelateerde overtuigingen (*α* = .66): de mate waarin men bang is voor de CoronaMelder, en de mate waarin men bang is voor notificaties van de CoronaMelder; en 4) Overtuigingen over complottheorieën (*α* = .71): de mate waarin men de overtuiging heeft dat het coronavirus in een laboratorium is gemaakt, en de overtuiging dat de uitbraak van het coronavirus te maken heeft met de aanleg van 5G.
Uit de factoranalyse bleken de variabelen adequaatheid van de techniek, de kans om anderen te besmetten als men zelf besmet is, en de ernst van het besmetten van anderen als men zelf  besmet is, geen onderdeel uit te maken van één van de factoren. Deze variabelen zijn daarom los meegenomen in de analyse.
Uit de analyse bleek dat maatschappelijke overtuigingen de grootste voorspeller was van CoronaMelder adoptie (*b* = 1.29, *p* < .001). Overtuigingen over privacy-gerelateerde kwesties hebben een negatieve invloed op CoronaMelder adoptie (*b* = -.12, *p* = .003), evenals angst-gerelateerde overtuigingen (*b* = -.30, *p* < .001). Leeftijd heeft een klein negatief effect op CoronaMelder adoptie in deze analyse (*b* = -.09, *p* = .047). Overtuigingen over complottheorieën, adequaatheid van de techniek, de kans om anderen te besmetten als men zelf besmet is, en de ernst van het besmetten van anderen als men zelf  besmet is, bleken geen effect te hebben op CoronaMelder adoptie. 

## Effecten
### Meldingen en reacties op adviezen gegeven in de melding

#### Ontvangen meldingen en opvolging van de adviezen
In totaal hebben `r nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer') & (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))` deelnemers die de app nu gebruikten, of gebruikt hadden, minstens één melding gehad vanuit de app; dat is `r round(nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer') & (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))/nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer')))*100, digits = 1)`%. Een noot bij de resultaten in de onderstaande alineas is dat deze op een laag aantal waarnemingen gebaseerd zijn (n = `r nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer') & (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))`). 

Van de respondenten die ooit een melding van de CoronaMelder hebben ontvangen gaf `r round(nrow(filter(data, (Notification_behavior_test == 'Ja')))/nrow(filter(data, (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))*100, digits = 1)`% aan een coronatest te hebben aangevraagd na de melding. Daarnaast gaf `r round(nrow(filter(data, (Notification_behavior_quarantaine == 'Vaak' | Notification_behavior_quarantaine == 'Meestal' | Notification_behavior_quarantaine == 'Altijd')))/nrow(filter(data, (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))*100, digits = 1)`% aan dat hij of zij vaak, meestal of altijd zo lang thuis is gebleven als de melding adviseert. Slechts `r round(nrow(filter(data, (Notification_behavior_quarantaine == 'Nooit' | Notification_behavior_quarantaine == 'Zelden')))/nrow(filter(data, (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))*100, digits = 1)`% gaf aan nooit of zelden zo lang thuis te zijn gebleven als de melding adviseert. 


```{r notificationquarantaine, echo=FALSE, tab.cap="Thuis blijven zo lang als de melding adviseert"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Notification_behavior_quarantaine")
graph_questionlabels = c("Ben u nadat u deze melding(en) kreeg zo lang thuis gebleven als de melding adviseert?"); 

# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Altijd", "Meestal", "Vaak", "Regelmatig", "Soms", "Zelden", "Nooit"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- graph_questionlabels

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 5

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out

```
`r round(nrow(filter(data, (Notification_symptoms == 'Ja')))/nrow(filter(data, (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))*100, digits = 1)`% gaf aan binnen een week na het ontvangen van de melding symptomen te hebben gehad die bij een besmetting met het coronavirus pasten en `r round(nrow(filter(data, (Notification_symptoms == 'Nee')))/nrow(filter(data, (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))*100, digits = 1)`% gaf aan dat dit niet het geval was. 

Van de mensen die aangaven een of meerdere meldingen te hebben ontvangen gaf `r round(nrow(filter(data, (Notification_justified == 'Ja')))/nrow(filter(data, (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))*100, digits = 1)`% aan te denken dat hij/zij inderdaad in contact was geweest met iemand met het coronavirus. `r round(nrow(filter(data, (Notification_justified == 'Nee')))/nrow(filter(data, (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))*100, digits = 1)`% dacht van niet en de rest gaf aan dit niet meer te weten (`r round(nrow(filter(data, (Notification_justified == 'Weet ik niet (meer)')))/nrow(filter(data, (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))*100, digits = 1)`%). 

Er werd ook gevraagd of de respondent angstig werd na het ontvangen van de melding. `r round(nrow(filter(data, (Notification_fear == 'Een beetje mee eens' | Notification_fear == 'Mee eens' | Notification_fear == 'Helemaal mee eens')))/nrow(filter(data, (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))*100, digits = 1)`% gaf aan dat dit in meer of mindere mate het geval was; `r round(nrow(filter(data, (Notification_fear == 'Een beetje oneens' | Notification_fear == 'Oneens' | Notification_fear == 'Helemaal mee oneens')))/nrow(filter(data, (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))*100, digits = 1)`% gaf aan van niet en `r round(nrow(filter(data, (Notification_fear == 'Neutraal')))/nrow(filter(data, (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))*100, digits = 1)`% stond hier neutraal in. 

```{r notificationfear, echo=FALSE, tab.cap="Angstig na het ontvangen van een melding"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Notification_fear")
graph_questionlabels = c("Ik werd angstig toen ik de melding van de coronamelder app ontving"); 

# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- graph_questionlabels

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 5

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out

```


#### Intentie tot opvolgen adviezen gegeven in de melding
Aan de respondenten is gevraagd in hoeverre zij de intentie hebben om, na ontvangen van een melding, zich te houden aan de adviezen die in een melding van de CoronaMelder worden gegeven. Om dit te onderzoeken werd proefpersonen twee situaties voorgelegd (situatie waarin men wel of geen symptomen had) en werd een screenshot van de melding getoond. 

In figuur \@ref(fig:adherencenotificationsnosymp) is te zien dat respondenten over het algemeen de juiste intenties hebben wat betreft het opvolgen van geadviseerd gedrag wanneer men geen symptomen heeft. Zo zouden ongeveer twee op de drie thuisblijven zolang geadviseerd (`r round((nrow(filter(data, (AdherenceNotificationMeasuresNosymptoms_Quarantaine == 'Helemaal mee eens'| AdherenceNotificationMeasuresNosymptoms_Quarantaine == 'Mee eens'| AdherenceNotificationMeasuresNosymptoms_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), en geen bezoek ontvangen (`r round((nrow(filter(data, (AdherenceNotificationMeasuresNoSymptoms_Visits == 'Helemaal mee eens'| AdherenceNotificationMeasuresNoSymptoms_Visits == 'Mee eens'| AdherenceNotificationMeasuresNoSymptoms_Visits == 'Een beetje mee eens'))) /nrow(filter(data, (AdherenceNotificationMeasuresNoSymptoms_Visits == 'Helemaal mee oneens'| AdherenceNotificationMeasuresNoSymptoms_Visits == 'Oneens'| AdherenceNotificationMeasuresNoSymptoms_Visits == 'Een beetje oneens'| AdherenceNotificationMeasuresNoSymptoms_Visits == 'Ik zou de CoronaMelder app niet gebruiken'|AdherenceNotificationMeasuresNoSymptoms_Visits == 'Helemaal mee eens'| AdherenceNotificationMeasuresNoSymptoms_Visits == 'Mee eens'| AdherenceNotificationMeasuresNoSymptoms_Visits == 'Een beetje mee eens'| AdherenceNotificationMeasuresNoSymptoms_Visits == 'Neutraal'))))*100, digits = 1)`%). Ongeveer de helft geeft aan een coronatest aan te zullen vragen (`r round((nrow(filter(data, (AdherenceNotificationMeasuresNosymptoms_Test == 'Helemaal mee eens'| AdherenceNotificationMeasuresNosymptoms_Test == 'Mee eens'| AdherenceNotificationMeasuresNosymptoms_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) en rond een kwart gaf aan de huisarts te bellen (`r round((nrow(filter(data, (AdherenceNotificationMeasuresNosymptoms_CallGP == 'Helemaal mee eens'| AdherenceNotificationMeasuresNosymptoms_CallGP == 'Mee eens'| AdherenceNotificationMeasuresNosymptoms_CallGP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).

``` {r adherencenotificationsnosymp, echo=FALSE, fig.width=7, fig.height=2.5, fig.cap="Intentie tot opvolgen adviezen zonder symptomen", tab.cap="Intentie tot opvolgen adviezen zonder symptomen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresNosymptoms_Test", 
                        "AdherenceNotificationMeasuresNosymptoms_Quarantaine",
                        "AdherenceNotificationMeasuresNoSymptoms_Visits",
                        "AdherenceNotificationMeasuresNosymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 


# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. The following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])
```


``` {r adherencenotificationsnosymptab, echo=FALSE, fig.width=7, fig.height=2.5, fig.cap="Intentie tot opvolgen adviezen zonder symptomen", tab.cap="Intentie tot opvolgen adviezen zonder symptomen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresNosymptoms_Test", 
                        "AdherenceNotificationMeasuresNosymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresNoSymptoms_Visits", 
                        "AdherenceNotificationMeasuresNosymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- graph_questionlabels

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Figuur \@ref(fig:adherencenotificationssympt) laat zien dat respondenten over het algemeen ook de juiste intenties hebben wanneer men wel symptomen heeft. Van de respondenten met symptomen geeft `r round((nrow(filter(data, (AdherenceNotificationMeasuresSymptoms_Test == 'Helemaal mee eens'| AdherenceNotificationMeasuresSymptoms_Test == 'Mee eens'| AdherenceNotificationMeasuresSymptoms_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan te bellen voor een coronatest, geeft `r round((nrow(filter(data, (AdherenceNotificationMeasuresSymptoms_Quarantaine == 'Helemaal mee eens'| AdherenceNotificationMeasuresSymptoms_Quarantaine == 'Mee eens'| AdherenceNotificationMeasuresSymptoms_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan thuis te blijven zolang geadviseerd, en geeft `r round((nrow(filter(data, (AdherenceNotificationMeasuresSymptoms_Visits == 'Helemaal mee eens'| AdherenceNotificationMeasuresSymptoms_Visits == 'Mee eens'| AdherenceNotificationMeasuresSymptoms_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan geen bezoek te ontvangen na ontvangen van een melding. Toch geeft ook nog een substantieel deel aan de huisarts te zullen bellen (`r round((nrow(filter(data, (AdherenceNotificationMeasuresSymptoms_CallGP == 'Helemaal mee eens'| AdherenceNotificationMeasuresSymptoms_CallGP == 'Mee eens'| AdherenceNotificationMeasuresSymptoms_CallGP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).

```{r adherencenotificationssympt, echo=FALSE, fig.width=7, fig.height=2.5, fig.cap="Intentie tot opvolgen adviezen met symptomen", tab.cap="Intentie tot opvolgen adviezen met symptomen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresSymptoms_Test", 
                        "AdherenceNotificationMeasuresSymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresSymptoms_Visits", 
                        "AdherenceNotificationMeasuresSymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. The following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

##### Intentie tot opvolgen adviezen gegeven in de melding over de tijd - zonder symptomen
```{r McNemaradherencenotificationsintentiontestovertimenosympt, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_agree_cw, data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotificationMeasuresNosymptoms_Test_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotificationMeasuresNosymptoms_Test_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf de intentie te hebben om te bellen voor een test.
```{r McNemaradherencenotificationsintentionquarantaineovertimenosympt, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_agree_cw, data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Daarnaast liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotificationMeasuresNosymptoms_Quarantaine_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotificationMeasuresNosymptoms_Quarantaine_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf de intentie te hebben om thuis te blijven zo lang als de melding adviseert. 
```{r McNemaradherencenotificationsintentionvisitsovertimenosympt, echo=FALSE}
# First select only cases that did not have a missing on this variable in w3 (see report - items was added later)
data_currentwave_wavemin1_visitsnosymptcomplete = data_currentwave_wavemin1[!is.na(data_currentwave_wavemin1$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1),]
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_agree_cw[(data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_cw == 'Helemaal mee eens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_cw == 'Mee eens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_agree_cw[(data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_cw == 'Neutraal'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_cw == 'Een beetje oneens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_cw == 'Oneens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_agree_wmin1[(data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1 == 'Mee eens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_agree_wmin1[(data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1 == 'Neutraal'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1 == 'Oneens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_agree_cw, data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)

# NOTE: missing values in wmin1 because this question was not included for the entire duration of wave3. Therefore, sums up to 1301 instead of 1368. 
# if( sum(mcnemar.table) != nrow(data_currentwave_wavemin1_visitsnosymptcomplete)) stop('mcnemar table does not sum up to nrow')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet ook zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1_visitsnosymptcomplete, (AdherenceNotificationMeasuresNoSymptoms_Visits_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1_visitsnosymptcomplete)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1_visitsnosymptcomplete, (AdherenceNotificationMeasuresNoSymptoms_Visits_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1_visitsnosymptcomplete)))*100, digits = 1)`%) in het percentage dat aangaf de intentie te hebben om geen bezoek te ontvangen. Vanwege missende waarden op deze variabele in de vorige wave (3) is deze test met 1301 in plaats van 1368 waarnemingen gedaan. Om deze zelfde reden wijkt het percentage hier genoemd voor de huidige wave (71.9%) iets af van het percentage hierboven genoemd (71.7%).
```{r McNemarMcNemaradherencenotificationsintentiongpovertimenosympt, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_agree_cw, data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Tot slot liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotificationMeasuresNosymptoms_CallGP_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotificationMeasuresNosymptoms_CallGP_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf de intentie te hebben om de huisarts te bellen. 

```{r, echo=FALSE, fig.width=5.5, fig.height=4, dpi = 300, fig.cap="Intentie tot opvolgen adviezen zonder symptomen over de tijd, totaal percentage dat het minstens een beetje eens was met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresNosymptoms_Test", 
                        "AdherenceNotificationMeasuresNosymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresNoSymptoms_Visits", 
                        "AdherenceNotificationMeasuresNosymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 



# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

##### Intentie tot opvolgen adviezen gegeven in de melding over de tijd - met symptomen
```{r McNemaradherencenotificationsintentiontestovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_agree_cw, data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotificationMeasuresSymptoms_Test_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotificationMeasuresSymptoms_Test_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf de intentie te hebben om te bellen voor een test.
```{r McNemaradherencenotificationsintentionquarantaineovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_agree_cw, data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Daarnaast liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotificationMeasuresSymptoms_Quarantaine_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotificationMeasuresSymptoms_Quarantaine_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf de intentie te hebben om thuis te blijven zo lang als de melding adviseert. 
```{r McNemaradherencenotificationsintentionvisitsovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_agree_cw, data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet ook zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotificationMeasuresSymptoms_Visits_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotificationMeasuresSymptoms_Visits_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf de intentie te hebben om geen bezoek te ontvangen.
```{r McNemarMcNemaradherencenotificationsintentiongpovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_agree_cw, data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Tot slot liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotificationMeasuresSymptoms_CallGP_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotificationMeasuresSymptoms_CallGP_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf de intentie te hebben om de huisarts te bellen. 

```{r, echo=FALSE, fig.width=5.5, fig.height=4, dpi = 300, fig.cap="Intentie tot opvolgen adviezen met symptomen over de tijd, totaal percentage dat het minstens een beetje eens was met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresSymptoms_Test", 
                        "AdherenceNotificationMeasuresSymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresSymptoms_Visits", 
                        "AdherenceNotificationMeasuresSymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 



# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

#### Intentie tot opvolgen adviezen gegeven in de melding - alleen huidige gebruikers
Dezelfde bepalingen zijn ook gedaan in alleen de subsample (n = `r nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))`) die momenteel de CoronaMelder gebruikt. 


``` {r adherencenotificationsnosympcurrentusers, message=FALSE, echo=FALSE, fig.width=7, fig.height=2.2, fig.cap="Intentie tot opvolgen adviezen zonder symptomen - alleen huidige gebruikers", tab.cap="Intentie tot opvolgen adviezen zonder symptomen - alleen huidige gebruikers"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresNosymptoms_Test", 
                        "AdherenceNotificationMeasuresNosymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresNoSymptoms_Visits", 
                        "AdherenceNotificationMeasuresNosymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. 
# However, for without symptoms, nobody answered "Ik zou de CoronaMelder app niet gebruiken". Therefore, the following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

```


``` {r adherencenotificationsnosympcurrentuserstable, message=FALSE, echo=FALSE, fig.width=7, fig.height=2.2, fig.cap="Intentie tot opvolgen adviezen zonder symptomen - alleen huidige gebruikers", tab.cap="Intentie tot opvolgen adviezen zonder symptomen - alleen huidige gebruikers"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresNosymptoms_Test", 
                        "AdherenceNotificationMeasuresNosymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresNoSymptoms_Visits", 
                        "AdherenceNotificationMeasuresNosymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- graph_questionlabels

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


```{r adherencenotificationssymptcurrentusers, echo=FALSE, fig.width=7, fig.height=2.5, fig.cap="Intentie tot opvolgen adviezen met symptomen - alleen huidige gebruikers", tab.cap="Intentie tot opvolgen adviezen met symptomen - alleen huidige gebruikers"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresSymptoms_Test", 
                        "AdherenceNotificationMeasuresSymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresSymptoms_Visits", 
                        "AdherenceNotificationMeasuresSymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. The following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {

  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
    
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


##### Intentie tot opvolgen adviezen gegeven in de melding - alleen huidige gebruikers - over de tijd zonder symptomen

```{r Chisquareintentionadherencetestusersnosymptovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Test_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# THe following explanation holds for BI1a and BI1b: The fact that for some of the participants the user status changed between wave 1 and wave 2, we decided to perform a chi square in which we compare the proportion of Totaal eens_wmin1 versus Neutraal, niet mee eens_wmin1 for users of wave 1 with the proportion of Totaal eens_cw versus Neutraal, niet mee eens_cw for users of the current wave. For this we have to select, separately for each wave, the users (or non users). For these subsets we calculate counts with Totaal eens and Neutraal, etc. After that we concatenate these counts int a 2x2 table and perform a regular chi square on that.  
data_selected_cw = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik gebruik de CoronaMelder app op dit moment", ]

data_selected_wmin1 = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik gebruik de CoronaMelder app op dit moment", ]

# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$AdherenceNotificationMeasuresNosymptoms_Test_agree_cw), table(data_selected_wmin1$AdherenceNotificationMeasuresNosymptoms_Test_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```
Om te bepalen of de naleving van maatregelen, wanneer men geen symptomen heeft, bij de gebruikers verschilt tussen de huidige en de vorige wave is een chi kwadraat uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave gebruikers waren en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin de gebruikersstatus in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers in de huidige wave (`r round((nrow(filter(data_selected_cw, AdherenceNotificationMeasuresNosymptoms_Test_agree_cw == 'Totaal eens_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij zonder symptomen zou bellen om een test aan te vragen, vergeleken met het percentage gebruikers uit de vorige wave dat in de vorige wave aangaf het hiermee eens te zijn (`r round((nrow(filter(data_selected_wmin1, AdherenceNotificationMeasuresNosymptoms_Test_agree_wmin1 == 'Totaal eens_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%).
```{r Chisquareintentionadherencequarantineusersnosymptovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# THe following explanation holds for BI1a and BI1b: The fact that for some of the participants the user status changed between wave 1 and wave 2, we decided to perform a chi square in which we compare the proportion of Totaal eens_wmin1 versus Neutraal, niet mee eens_wmin1 for users of wave 1 with the proportion of Totaal eens_cw versus Neutraal, niet mee eens_cw for users of the current wave. For this we have to select, separately for each wave, the users (or non users). For these subsets we calculate counts with Totaal eens and Neutraal, etc. After that we concatenate these counts int a 2x2 table and perform a regular chi square on that.  
data_selected_cw = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik gebruik de CoronaMelder app op dit moment", ]

data_selected_wmin1 = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik gebruik de CoronaMelder app op dit moment", ]

# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$AdherenceNotificationMeasuresNosymptoms_Quarantaine_agree_cw), table(data_selected_wmin1$AdherenceNotificationMeasuresNosymptoms_Quarantaine_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```
Om te bepalen of de naleving van maatregelen, wanneer men geen symptomen heeft, bij de gebruikers verschilt tussen de huidige en de vorige wave is een chi kwadraat uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave gebruikers waren en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin de gebruikersstatus in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers in de huidige wave (`r round((nrow(filter(data_selected_cw, AdherenceNotificationMeasuresNosymptoms_Quarantaine_agree_cw == 'Totaal eens_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij zonder symptomen in quarantaine zou blijven zo lang als de melding adviseert, vergeleken met het percentage gebruikers uit de vorige wave dat in de vorige wave aangaf het hiermee eens te zijn (`r round((nrow(filter(data_selected_wmin1, AdherenceNotificationMeasuresNosymptoms_Quarantaine_agree_wmin1 == 'Totaal eens_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%).
```{r Chisquareintentionadherencevisitsusersnosymptovertime, echo=FALSE}
# First select only cases that did not have a missing on this variable for the previous wave (see report - items was added later)
data_currentwave_wavemin1_visitsnosymptcomplete = data_currentwave_wavemin1[!is.na(data_currentwave_wavemin1$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1),]
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_agree_cw[(data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_cw == 'Helemaal mee eens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_cw == 'Mee eens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_agree_cw[(data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_cw == 'Neutraal'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_cw == 'Een beetje oneens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_cw == 'Oneens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_agree_wmin1[(data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1 == 'Mee eens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_agree_wmin1[(data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1 == 'Neutraal'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1 == 'Oneens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1_visitsnosymptcomplete$AdherenceNotificationMeasuresNoSymptoms_Visits_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# THe following explanation holds for BI1a and BI1b: The fact that for some of the participants the user status changed between wave 1 and wave 2, we decided to perform a chi square in which we compare the proportion of Totaal eens_wmin1 versus Neutraal, niet mee eens_wmin1 for users of wave 1 with the proportion of Totaal eens_cw versus Neutraal, niet mee eens_cw for users of the current wave. For this we have to select, separately for each wave, the users (or non users). For these subsets we calculate counts with Totaal eens and Neutraal, etc. After that we concatenate these counts int a 2x2 table and perform a regular chi square on that.  
data_selected_cw = data_currentwave_wavemin1_visitsnosymptcomplete[data_currentwave_wavemin1_visitsnosymptcomplete$Behavior_UTAUT_cw == "Ik gebruik de CoronaMelder app op dit moment", ]

data_selected_wmin1 = data_currentwave_wavemin1_visitsnosymptcomplete[data_currentwave_wavemin1_visitsnosymptcomplete$Behavior_UTAUT_wmin1 == "Ik gebruik de CoronaMelder app op dit moment", ]

# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$AdherenceNotificationMeasuresNoSymptoms_Visits_agree_cw), table(data_selected_wmin1$AdherenceNotificationMeasuresNoSymptoms_Visits_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```
Om te bepalen of de naleving van maatregelen, wanneer men geen symptomen heeft, bij de gebruikers verschilt tussen de huidige en de vorige wave is een chi kwadraat uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave gebruikers waren en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin de gebruikersstatus in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers in de huidige wave (`r round((nrow(filter(data_selected_cw, AdherenceNotificationMeasuresNoSymptoms_Visits_agree_cw == 'Totaal eens_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij zonder symptomen geen bezoek zou ontvangen vergeleken met het percentage gebruikers uit de vorige wave dat in de vorige wave aangaf het hiermee eens te zijn (`r round((nrow(filter(data_selected_wmin1, AdherenceNotificationMeasuresNoSymptoms_Visits_agree_wmin1 == 'Totaal eens_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%). Vanwege missende waarden op deze variabele in de vorige wave (3) is deze test met een lager aantal waarnemingen (de deelnemers die deze vraag in wave 3 en 4 hebben ingevuld) gedaan. Om deze zelfde reden wijkt het percentage hier genoemd voor de huidige wave (91%) iets af van het percentage hierboven genoemd (90.5%).
```{r ChisquareintentionadherenceGPusersnosymptovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresNosymptoms_CallGP_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# THe following explanation holds for BI1a and BI1b: The fact that for some of the participants the user status changed between wave 1 and wave 2, we decided to perform a chi square in which we compare the proportion of Totaal eens_wmin1 versus Neutraal, niet mee eens_wmin1 for users of wave 1 with the proportion of Totaal eens_cw versus Neutraal, niet mee eens_cw for users of the current wave. For this we have to select, separately for each wave, the users (or non users). For these subsets we calculate counts with Totaal eens and Neutraal, etc. After that we concatenate these counts int a 2x2 table and perform a regular chi square on that.  
data_selected_cw = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik gebruik de CoronaMelder app op dit moment", ]

data_selected_wmin1 = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik gebruik de CoronaMelder app op dit moment", ]

# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$AdherenceNotificationMeasuresNosymptoms_CallGP_agree_cw), table(data_selected_wmin1$AdherenceNotificationMeasuresNosymptoms_CallGP_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```
Om te bepalen of de naleving van maatregelen, wanneer men geen symptomen heeft, bij de gebruikers verschilt tussen de huidige en de vorige wave is een chi kwadraat uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave gebruikers waren en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin de gebruikersstatus in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers in de huidige wave (`r round((nrow(filter(data_selected_cw, AdherenceNotificationMeasuresNosymptoms_CallGP_agree_cw == 'Totaal eens_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij zonder symptomen de huisarts zou bellen, vergeleken met het percentage gebruikers uit de vorige wave dat in de vorige wave aangaf het hiermee eens te zijn (`r round((nrow(filter(data_selected_wmin1, AdherenceNotificationMeasuresNosymptoms_CallGP_agree_wmin1 == 'Totaal eens_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%).

```{r, echo=FALSE, fig.width=5.5, fig.height=4, dpi = 300, fig.cap="Intentie tot opvolgen adviezen zonder symptomen over de tijd, alleen huidige gebruikers, totaal percentage dat het minstens een beetje eens was met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresNosymptoms_Test", 
                        "AdherenceNotificationMeasuresNosymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresNoSymptoms_Visits", 
                        "AdherenceNotificationMeasuresNosymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 


# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars & (eval(parse(text=paste('Behavior_UTAUT', include_waves[wave_idx], sep="_")))) == 'Ik gebruik de CoronaMelder app op dit moment')) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) & (eval(parse(text=paste('Behavior_UTAUT', include_waves[wave_idx], sep="_")))) == 'Ik gebruik de CoronaMelder app op dit moment'))
    }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```


##### Intentie tot opvolgen adviezen gegeven in de melding - alleen huidige gebruikers - over de tijd met symptomen
```{r Chisquareintentionadherencetestuserssymptovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Test_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# THe following explanation holds for BI1a and BI1b: The fact that for some of the participants the user status changed between wave 1 and wave 2, we decided to perform a chi square in which we compare the proportion of Totaal eens_wmin1 versus Neutraal, niet mee eens_wmin1 for users of wave 1 with the proportion of Totaal eens_cw versus Neutraal, niet mee eens_cw for users of the current wave. For this we have to select, separately for each wave, the users (or non users). For these subsets we calculate counts with Totaal eens and Neutraal, etc. After that we concatenate these counts int a 2x2 table and perform a regular chi square on that.  
data_selected_cw = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik gebruik de CoronaMelder app op dit moment", ]

data_selected_wmin1 = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik gebruik de CoronaMelder app op dit moment", ]

# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$AdherenceNotificationMeasuresSymptoms_Test_agree_cw), table(data_selected_wmin1$AdherenceNotificationMeasuresSymptoms_Test_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```
Om te bepalen of de naleving van maatregelen, wanneer men symptomen heeft, bij de gebruikers verschilt tussen de huidige en de vorige wave is een chi kwadraat uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave gebruikers waren en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin de gebruikersstatus in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers in de huidige wave (`r round((nrow(filter(data_selected_cw, AdherenceNotificationMeasuresSymptoms_Test_agree_cw == 'Totaal eens_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij zonder symptomen zou bellen om een test aan te vragen, vergeleken met het percentage gebruikers uit de vorige wave dat in de vorige wave aangaf het hiermee eens te zijn (`r round((nrow(filter(data_selected_wmin1, AdherenceNotificationMeasuresSymptoms_Test_agree_wmin1 == 'Totaal eens_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%).
```{r Chisquareintentionadherencequarantineuserssymptovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# THe following explanation holds for BI1a and BI1b: The fact that for some of the participants the user status changed between wave 1 and wave 2, we decided to perform a chi square in which we compare the proportion of Totaal eens_wmin1 versus Neutraal, niet mee eens_wmin1 for users of wave 1 with the proportion of Totaal eens_cw versus Neutraal, niet mee eens_cw for users of the current wave. For this we have to select, separately for each wave, the users (or non users). For these subsets we calculate counts with Totaal eens and Neutraal, etc. After that we concatenate these counts int a 2x2 table and perform a regular chi square on that.  
data_selected_cw = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik gebruik de CoronaMelder app op dit moment", ]

data_selected_wmin1 = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik gebruik de CoronaMelder app op dit moment", ]

# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$AdherenceNotificationMeasuresSymptoms_Quarantaine_agree_cw), table(data_selected_wmin1$AdherenceNotificationMeasuresSymptoms_Quarantaine_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```
Om te bepalen of de naleving van maatregelen, wanneer men symptomen heeft, bij de gebruikers verschilt tussen de huidige en de vorige wave is een chi kwadraat uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave gebruikers waren en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin de gebruikersstatus in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers in de huidige wave (`r round((nrow(filter(data_selected_cw, AdherenceNotificationMeasuresSymptoms_Quarantaine_agree_cw == 'Totaal eens_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij zonder symptomen in quarantaine zou blijven zo lang als de melding adviseert, vergeleken met het percentage gebruikers uit de vorige wave dat in de vorige wave aangaf het hiermee eens te zijn (`r round((nrow(filter(data_selected_wmin1, AdherenceNotificationMeasuresSymptoms_Quarantaine_agree_wmin1 == 'Totaal eens_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%).
```{r Chisquareintentionadherencevisitsuserssymptovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_Visits_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# THe following explanation holds for BI1a and BI1b: The fact that for some of the participants the user status changed between wave 1 and wave 2, we decided to perform a chi square in which we compare the proportion of Totaal eens_wmin1 versus Neutraal, niet mee eens_wmin1 for users of wave 1 with the proportion of Totaal eens_cw versus Neutraal, niet mee eens_cw for users of the current wave. For this we have to select, separately for each wave, the users (or non users). For these subsets we calculate counts with Totaal eens and Neutraal, etc. After that we concatenate these counts int a 2x2 table and perform a regular chi square on that.  
data_selected_cw = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik gebruik de CoronaMelder app op dit moment", ]

data_selected_wmin1 = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik gebruik de CoronaMelder app op dit moment", ]

# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$AdherenceNotificationMeasuresSymptoms_Visits_agree_cw), table(data_selected_wmin1$AdherenceNotificationMeasuresSymptoms_Visits_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```
Om te bepalen of de naleving van maatregelen, wanneer men symptomen heeft, bij de gebruikers verschilt tussen de huidige en de vorige wave is een chi kwadraat uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave gebruikers waren en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin de gebruikersstatus in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers in de huidige wave (`r round((nrow(filter(data_selected_cw, AdherenceNotificationMeasuresSymptoms_Visits_agree_cw == 'Totaal eens_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij zonder symptomen geen bezoek zou ontvangen vergeleken met het percentage gebruikers uit de vorige wave dat in de vorige wave aangaf het hiermee eens te zijn (`r round((nrow(filter(data_selected_wmin1, AdherenceNotificationMeasuresSymptoms_Visits_agree_wmin1 == 'Totaal eens_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%).
```{r ChisquareintentionadherenceGPuserssymptovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_agree_cw[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$AdherenceNotificationMeasuresSymptoms_CallGP_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# THe following explanation holds for BI1a and BI1b: The fact that for some of the participants the user status changed between wave 1 and wave 2, we decided to perform a chi square in which we compare the proportion of Totaal eens_wmin1 versus Neutraal, niet mee eens_wmin1 for users of wave 1 with the proportion of Totaal eens_cw versus Neutraal, niet mee eens_cw for users of the current wave. For this we have to select, separately for each wave, the users (or non users). For these subsets we calculate counts with Totaal eens and Neutraal, etc. After that we concatenate these counts int a 2x2 table and perform a regular chi square on that.  
data_selected_cw = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik gebruik de CoronaMelder app op dit moment", ]

data_selected_wmin1 = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik gebruik de CoronaMelder app op dit moment", ]

# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$AdherenceNotificationMeasuresSymptoms_CallGP_agree_cw), table(data_selected_wmin1$AdherenceNotificationMeasuresSymptoms_CallGP_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```
Om te bepalen of de naleving van maatregelen, wanneer men symptomen heeft, bij de gebruikers verschilt tussen de huidige en de vorige wave is een chi kwadraat uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave gebruikers waren en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin de gebruikersstatus in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers in de huidige wave (`r round((nrow(filter(data_selected_cw, AdherenceNotificationMeasuresSymptoms_CallGP_agree_cw == 'Totaal eens_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij zonder symptomen de huisarts zou bellen, vergeleken met het percentage gebruikers uit de vorige wave dat in de vorige wave aangaf het hiermee eens te zijn (`r round((nrow(filter(data_selected_wmin1, AdherenceNotificationMeasuresSymptoms_CallGP_agree_wmin1 == 'Totaal eens_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%).
                         

```{r, echo=FALSE, fig.width=5.5, fig.height=4, dpi = 300, fig.cap="Intentie tot opvolgen adviezen met symptomen over de tijd, alleen huidige gebruikers, totaal percentage dat het minstens een beetje eens was met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresSymptoms_Test", 
                        "AdherenceNotificationMeasuresSymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresSymptoms_Visits", 
                        "AdherenceNotificationMeasuresSymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 


# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars & (eval(parse(text=paste('Behavior_UTAUT', include_waves[wave_idx], sep="_")))) == 'Ik gebruik de CoronaMelder app op dit moment')) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) & (eval(parse(text=paste('Behavior_UTAUT', include_waves[wave_idx], sep="_")))) == 'Ik gebruik de CoronaMelder app op dit moment'))
    }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```


#### Verklarende factoren opvolging adviezen gegeven in melding

##### Zelfeffectiviteit opvolging adviezen
Om de zelfeffectiviteit in kaart te brengen werd gevraagd in welke mate men dacht in staat te zijn om de adviezen uit de melding op te volgen. Men acht zichzelf goed in staat om te bellen voor een test (`r round((nrow(filter(data, (HBM_selfefficacy_Test == 'Helemaal mee eens'| HBM_selfefficacy_Test == 'Mee eens'| HBM_selfefficacy_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), zo lang thuis te blijven als wordt geadviseerd (`r round((nrow(filter(data, (HBM_selfefficacy_Quarantaine == 'Helemaal mee eens'| HBM_selfefficacy_Quarantaine == 'Mee eens'| HBM_selfefficacy_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), geen bezoek te ontvangen (`r round((nrow(filter(data, (HBM_selfefficacy_Visits == 'Helemaal mee eens'| HBM_selfefficacy_Visits == 'Mee eens'| HBM_selfefficacy_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) en de huisarts te bellen (`r round((nrow(filter(data, (HBM_selfefficacy_GP == 'Helemaal mee eens'| HBM_selfefficacy_GP == 'Mee eens'| HBM_selfefficacy_GP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).


```{r adherencenotificationsselfefficacy, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Eigen effectiviteit om adviezen op te volgen", tab.cap="Eigen effectiviteit om adviezen op te volgen. Ik ben in staat om ..."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_selfefficacy_Test", 
                        "HBM_selfefficacy_Quarantaine", 
                        "HBM_selfefficacy_Visits",
                        "HBM_selfefficacy_GP")
graph_questionlabels = c("... te bellen voor een test", 
                         "... zo lang thuis te blijven als wordt geadviseerd", 
                         "... geen bezoek te ontvangen",
                         "... de huisarts te bellen"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle("Ik ben in staat om...") + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out

```

###### Zelfeffectiviteit opvolging adviezen over de tijd
```{r McNemaradherencenotificationsselfefficacyovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_selfefficacy_Test_agree_cw[(data_currentwave_wavemin1$HBM_selfefficacy_Test_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_Test_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_Test_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_selfefficacy_Test_agree_cw[(data_currentwave_wavemin1$HBM_selfefficacy_Test_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_selfefficacy_Test_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_selfefficacy_Test_cw == 'Oneens'| data_currentwave_wavemin1$HBM_selfefficacy_Test_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_selfefficacy_Test_agree_wmin1[(data_currentwave_wavemin1$HBM_selfefficacy_Test_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_Test_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_Test_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_selfefficacy_Test_agree_wmin1[(data_currentwave_wavemin1$HBM_selfefficacy_Test_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_selfefficacy_Test_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_selfefficacy_Test_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_selfefficacy_Test_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_selfefficacy_Test_agree_cw, data_currentwave_wavemin1$HBM_selfefficacy_Test_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_selfefficacy_Test_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_selfefficacy_Test_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat men in staat is om te bellen voor een test.
```{r McNemarHBMselfefficacyquarantaineovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_agree_cw[(data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_agree_cw[(data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_cw == 'Oneens'| data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_agree_wmin1[(data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_agree_wmin1[(data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_agree_cw, data_currentwave_wavemin1$HBM_selfefficacy_Quarantaine_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Daarnaast liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_selfefficacy_Quarantaine_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_selfefficacy_Quarantaine_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat men in staat is om thuis te blijven zo lang als de melding adviseert. 
```{r McNemarHBMselfefficacyvisitsovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_selfefficacy_Visits_agree_cw[(data_currentwave_wavemin1$HBM_selfefficacy_Visits_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_Visits_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_Visits_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_selfefficacy_Visits_agree_cw[(data_currentwave_wavemin1$HBM_selfefficacy_Visits_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_selfefficacy_Visits_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_selfefficacy_Visits_cw == 'Oneens'| data_currentwave_wavemin1$HBM_selfefficacy_Visits_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_selfefficacy_Visits_agree_wmin1[(data_currentwave_wavemin1$HBM_selfefficacy_Visits_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_Visits_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_Visits_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_selfefficacy_Visits_agree_wmin1[(data_currentwave_wavemin1$HBM_selfefficacy_Visits_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_selfefficacy_Visits_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_selfefficacy_Visits_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_selfefficacy_Visits_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_selfefficacy_Visits_agree_cw, data_currentwave_wavemin1$HBM_selfefficacy_Visits_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet ook zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_selfefficacy_Visits_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_selfefficacy_Visits_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat men in staat is om geen bezoek te ontvangen.
```{r McNemarHBMselfefficacygpovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_selfefficacy_GP_agree_cw[(data_currentwave_wavemin1$HBM_selfefficacy_GP_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_GP_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_GP_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_selfefficacy_GP_agree_cw[(data_currentwave_wavemin1$HBM_selfefficacy_GP_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_selfefficacy_GP_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_selfefficacy_GP_cw == 'Oneens'| data_currentwave_wavemin1$HBM_selfefficacy_GP_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_selfefficacy_GP_agree_wmin1[(data_currentwave_wavemin1$HBM_selfefficacy_GP_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_GP_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_selfefficacy_GP_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_selfefficacy_GP_agree_wmin1[(data_currentwave_wavemin1$HBM_selfefficacy_GP_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_selfefficacy_GP_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_selfefficacy_GP_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_selfefficacy_GP_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_selfefficacy_GP_agree_cw, data_currentwave_wavemin1$HBM_selfefficacy_GP_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Tot slot liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_selfefficacy_GP_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_selfefficacy_GP_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat men in staat is om de huisarts te bellen. 

```{r, echo=FALSE, fig.width=5.5, fig.height=4, dpi = 300, fig.cap="Zelfeffectiviteit om adviezen op te volgen over de tijd, totaal percentage dat het minstens een beetje eens is met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_selfefficacy_Test", 
                        "HBM_selfefficacy_Quarantaine", 
                        "HBM_selfefficacy_Visits",
                        "HBM_selfefficacy_GP")
graph_questionlabels = c("Ik ben in staat om te bellen voor een test", 
                         "Ik ben in staat om zo lang thuis te blijven als wordt geadviseerd", 
                         "Ik ben in staat om geen bezoek te ontvangen",
                         "Ik ben in staat om de huisarts te bellen"); 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank())

ggdraw(theplot)

```


##### Gepercipieerde persoonlijke voor- en nadelen van opvolgen adviezen
Uit het Health Belief Model is bekend dat de mate waarin men verwacht dat een gedrag persoonlijke voor- of nadelen heeft een rol kan spelen in de adoptie van het gedrag. Voor een aantal gedragingen omtrent de opvolging van adviezen zijn deze voor- en nadelen uitgevraagd. Het blijkt dat ongeveer de helft van de respondenten deze persoonlijke voordelen inziet (bellen voor een test: `r round((nrow(filter(data, (HBM_perceivedbenefits_Test == 'Helemaal mee eens'| HBM_perceivedbenefits_Test == 'Mee eens'| HBM_perceivedbenefits_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; thuisblijven zolang geadviseerd is: `r round((nrow(filter(data, (HBM_perceivedbenefits_Quarantaine == 'Helemaal mee eens'| HBM_perceivedbenefits_Quarantaine == 'Mee eens'| HBM_perceivedbenefits_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; geen bezoek ontvangen: `r round((nrow(filter(data, (HBM_perceivedbenefits_Visits == 'Helemaal mee eens'| HBM_perceivedbenefits_Visits == 'Mee eens'| HBM_perceivedbenefits_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; de huisarts bellen: `r round((nrow(filter(data, (HBM_perceivedbenefits_GP == 'Helemaal mee eens'| HBM_perceivedbenefits_GP == 'Mee eens'| HBM_perceivedbenefits_GP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), zie figuur \@ref(fig:HBMbenefits). Een aanzienlijke groep staat neutraal tegenover de voordelen om adviezen op te volgen (bellen voor een test: `r round((nrow(filter(data, (HBM_perceivedbenefits_Test == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; thuisblijven zolang geadviseerd is: `r round((nrow(filter(data, (HBM_perceivedbenefits_Quarantaine == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; geen bezoek ontvangen: `r round((nrow(filter(data, (HBM_perceivedbenefits_Visits == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; de huisarts bellen: `r round((nrow(filter(data, (HBM_perceivedbenefits_GP == 'Neutraal'))) /nrow(data))*100, digits = 1)`%).

```{r HBMbenefits, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Persoonlijke voordelen om adviezen op te volgen", tab.cap="Persoonlijke voordelen om adviezen op te volgen"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_perceivedbenefits_Test", 
                        "HBM_perceivedbenefits_Quarantaine", 
                        "HBM_perceivedbenefits_Visits",
                        "HBM_perceivedbenefits_GP")
graph_questionlabels = c("... te bellen voor een test", 
                         "... zo lang thuis te blijven als wordt geadviseerd", 
                         "... geen bezoek te ontvangen",
                         "... de huisarts te bellen"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle("Het heeft voor mij persoonlijke voordelen om...") + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Ook met betrekking tot persoonlijke nadelen van het opvolgen van de adviezen blijkt een groot aandeel neutraal te zijn (bellen voor een test: `r round((nrow(filter(data, (HBM_barriers_Test == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; thuisblijven zolang geadviseerd is: `r round((nrow(filter(data, (HBM_barriers_Quarantaine == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; geen bezoek ontvangen: `r round((nrow(filter(data, (HBM_barriers_Visits == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; de huisarts bellen: `r round((nrow(filter(data, (HBM_barriers_GP == 'Neutraal'))) /nrow(data))*100, digits = 1)`%). Er zit variatie in de mate waarin men het eens is met de stellingen of bepaalde acties persoonlijke nadelen hebben. Het percentage mensen dat het eens is met nadelige gevolgen is het grootst voor thuisblijven (`r round((nrow(filter(data, (HBM_barriers_Quarantaine == 'Helemaal mee eens'| HBM_barriers_Quarantaine == 'Mee eens'| HBM_barriers_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) en het niet kunnen ontvangen van bezoek (`r round((nrow(filter(data, (HBM_barriers_Visits == 'Helemaal mee eens'| HBM_barriers_Visits == 'Mee eens'| HBM_barriers_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Het bellen voor een test (`r round((nrow(filter(data, (HBM_barriers_Test == 'Helemaal mee eens'| HBM_barriers_Test == 'Mee eens'| HBM_barriers_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) of de huisarts bellen (`r round((nrow(filter(data, (HBM_barriers_GP == 'Helemaal mee eens'| HBM_barriers_GP == 'Mee eens'| HBM_barriers_GP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) wordt als minder nadelig gezien (zie figuur \@ref(fig:HBMbarriers)).


```{r HBMbarriers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Persoonlijke nadelen om adviezen op te volgen", tab.cap="Persoonlijke nadelen om adviezen op te volgen"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_barriers_Test", 
                        "HBM_barriers_Quarantaine", 
                        "HBM_barriers_Visits",
                        "HBM_barriers_GP")
graph_questionlabels = c("... te bellen voor een test", 
                         "... zo lang thuis te blijven als wordt geadviseerd", 
                         "... geen bezoek te ontvangen",
                         "... de huisarts te bellen"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle("Het heeft voor mij persoonlijke nadelen om...") + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

###### Gepercipieerde persoonlijke voordelen van opvolgen adviezen over de tijd
```{r McNemarHBMbenefitstestovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_perceivedbenefits_Test_agree_cw[(data_currentwave_wavemin1$HBM_perceivedbenefits_Test_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Test_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Test_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_perceivedbenefits_Test_agree_cw[(data_currentwave_wavemin1$HBM_perceivedbenefits_Test_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_perceivedbenefits_Test_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Test_cw == 'Oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Test_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_perceivedbenefits_Test_agree_wmin1[(data_currentwave_wavemin1$HBM_perceivedbenefits_Test_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Test_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Test_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_perceivedbenefits_Test_agree_wmin1[(data_currentwave_wavemin1$HBM_perceivedbenefits_Test_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_perceivedbenefits_Test_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Test_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Test_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_perceivedbenefits_Test_agree_cw, data_currentwave_wavemin1$HBM_perceivedbenefits_Test_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_perceivedbenefits_Test_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_perceivedbenefits_Test_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het bellen voor een test persoonlijke voordelen heeft.
```{r McNemarHBMbenefitsquarantaineovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_agree_cw[(data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_agree_cw[(data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_cw == 'Oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_agree_wmin1[(data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_agree_wmin1[(data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_agree_cw, data_currentwave_wavemin1$HBM_perceivedbenefits_Quarantaine_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Daarnaast liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_perceivedbenefits_Quarantaine_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_perceivedbenefits_Quarantaine_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het persoonlijke voordelen heeft om thuis te blijven zo lang als de melding adviseert. 
```{r McNemarHBMbenefitsvisitsovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_agree_cw[(data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_agree_cw[(data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_cw == 'Oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_agree_wmin1[(data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_agree_wmin1[(data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_agree_cw, data_currentwave_wavemin1$HBM_perceivedbenefits_Visits_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet ook zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_perceivedbenefits_Visits_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_perceivedbenefits_Visits_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het persoonlijke voordelen heeft om geen bezoek te ontvangen.
```{r McNemarHBMbenefitsgpovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_perceivedbenefits_GP_agree_cw[(data_currentwave_wavemin1$HBM_perceivedbenefits_GP_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_GP_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_GP_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_perceivedbenefits_GP_agree_cw[(data_currentwave_wavemin1$HBM_perceivedbenefits_GP_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_perceivedbenefits_GP_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_GP_cw == 'Oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_GP_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_perceivedbenefits_GP_agree_wmin1[(data_currentwave_wavemin1$HBM_perceivedbenefits_GP_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_GP_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_perceivedbenefits_GP_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_perceivedbenefits_GP_agree_wmin1[(data_currentwave_wavemin1$HBM_perceivedbenefits_GP_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_perceivedbenefits_GP_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_GP_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_perceivedbenefits_GP_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_perceivedbenefits_GP_agree_cw, data_currentwave_wavemin1$HBM_perceivedbenefits_GP_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Tot slot liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_perceivedbenefits_GP_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_perceivedbenefits_GP_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het persoonlijke voordelen heeft om de huisarts te bellen. 

```{r, echo=FALSE, fig.width=5.5, fig.height=4, dpi = 300, fig.cap="Gepercipieerde persoonlijke voordelen van opvolgen adviezen over tijd, totaal percentage dat het minstens een beetje eens is met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_perceivedbenefits_Test", 
                        "HBM_perceivedbenefits_Quarantaine", 
                        "HBM_perceivedbenefits_Visits",
                        "HBM_perceivedbenefits_GP")
graph_questionlabels = c("Het heeft voor mij persoonlijke voordelen om te bellen voor een test", 
                         "Het heeft voor mij persoonlijke voordelen om zo lang thuis te blijven als wordt geadviseerd", 
                         "Het heeft voor mij persoonlijke voordelen om geen bezoek te ontvangen",
                         "Het heeft voor mij persoonlijke voordelen om de huisarts te bellen"); 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank())

ggdraw(theplot)

```

###### Gepercipieerde persoonlijke nadelen van opvolgen adviezen over de tijd
```{r McNemarHBMbarrierstestovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_barriers_Test_agree_cw[(data_currentwave_wavemin1$HBM_barriers_Test_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_barriers_Test_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_barriers_Test_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_barriers_Test_agree_cw[(data_currentwave_wavemin1$HBM_barriers_Test_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_barriers_Test_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_barriers_Test_cw == 'Oneens'| data_currentwave_wavemin1$HBM_barriers_Test_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_barriers_Test_agree_wmin1[(data_currentwave_wavemin1$HBM_barriers_Test_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_barriers_Test_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_barriers_Test_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_barriers_Test_agree_wmin1[(data_currentwave_wavemin1$HBM_barriers_Test_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_barriers_Test_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_barriers_Test_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_barriers_Test_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_barriers_Test_agree_cw, data_currentwave_wavemin1$HBM_barriers_Test_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_barriers_Test_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_barriers_Test_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het bellen voor een test persoonlijke nadelen heeft.
```{r McNemarHBMbarriersquarantaineovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_barriers_Quarantaine_agree_cw[(data_currentwave_wavemin1$HBM_barriers_Quarantaine_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_barriers_Quarantaine_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_barriers_Quarantaine_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_barriers_Quarantaine_agree_cw[(data_currentwave_wavemin1$HBM_barriers_Quarantaine_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_barriers_Quarantaine_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_barriers_Quarantaine_cw == 'Oneens'| data_currentwave_wavemin1$HBM_barriers_Quarantaine_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_barriers_Quarantaine_agree_wmin1[(data_currentwave_wavemin1$HBM_barriers_Quarantaine_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_barriers_Quarantaine_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_barriers_Quarantaine_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_barriers_Quarantaine_agree_wmin1[(data_currentwave_wavemin1$HBM_barriers_Quarantaine_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_barriers_Quarantaine_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_barriers_Quarantaine_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_barriers_Quarantaine_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_barriers_Quarantaine_agree_cw, data_currentwave_wavemin1$HBM_barriers_Quarantaine_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet ook zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_barriers_Quarantaine_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_barriers_Quarantaine_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het persoonlijke nadelen heeft om thuis te blijven zo lang als de melding adviseert. 
```{r McNemarHBMbarriersvisitsovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_barriers_Visits_agree_cw[(data_currentwave_wavemin1$HBM_barriers_Visits_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_barriers_Visits_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_barriers_Visits_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_barriers_Visits_agree_cw[(data_currentwave_wavemin1$HBM_barriers_Visits_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_barriers_Visits_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_barriers_Visits_cw == 'Oneens'| data_currentwave_wavemin1$HBM_barriers_Visits_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_barriers_Visits_agree_wmin1[(data_currentwave_wavemin1$HBM_barriers_Visits_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_barriers_Visits_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_barriers_Visits_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_barriers_Visits_agree_wmin1[(data_currentwave_wavemin1$HBM_barriers_Visits_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_barriers_Visits_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_barriers_Visits_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_barriers_Visits_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_barriers_Visits_agree_cw, data_currentwave_wavemin1$HBM_barriers_Visits_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Daarnaast liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_barriers_Visits_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_barriers_Visits_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het persoonlijke nadelen heeft om geen bezoek te ontvangen.
```{r McNemarHBMbarriersgpovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$HBM_barriers_GP_agree_cw[(data_currentwave_wavemin1$HBM_barriers_GP_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_barriers_GP_cw == 'Mee eens'| data_currentwave_wavemin1$HBM_barriers_GP_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$HBM_barriers_GP_agree_cw[(data_currentwave_wavemin1$HBM_barriers_GP_cw == 'Neutraal'| data_currentwave_wavemin1$HBM_barriers_GP_cw == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_barriers_GP_cw == 'Oneens'| data_currentwave_wavemin1$HBM_barriers_GP_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$HBM_barriers_GP_agree_wmin1[(data_currentwave_wavemin1$HBM_barriers_GP_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$HBM_barriers_GP_wmin1 == 'Mee eens'| data_currentwave_wavemin1$HBM_barriers_GP_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$HBM_barriers_GP_agree_wmin1[(data_currentwave_wavemin1$HBM_barriers_GP_wmin1 == 'Neutraal'| data_currentwave_wavemin1$HBM_barriers_GP_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$HBM_barriers_GP_wmin1 == 'Oneens'| data_currentwave_wavemin1$HBM_barriers_GP_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$HBM_barriers_GP_agree_cw, data_currentwave_wavemin1$HBM_barriers_GP_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
Tot slot liet de McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_barriers_GP_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (HBM_barriers_GP_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het persoonlijke nadelen heeft om de huisarts te bellen. 

```{r, echo=FALSE, fig.width=5.5, fig.height=4, dpi = 300, fig.cap="Gepercipieerde persoonlijke nadelen van opvolgen adviezen over tijd, totaal percentage dat het minstens een beetje eens is met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_barriers_Test", 
                        "HBM_barriers_Quarantaine", 
                        "HBM_barriers_Visits",
                        "HBM_barriers_GP")

graph_questionlabels = c("Het heeft voor mij persoonlijke nadelen om te bellen voor een test", 
                         "Het heeft voor mij persoonlijke nadelen om zo lang thuis te blijven als wordt geadviseerd", 
                         "Het heeft voor mij persoonlijke nadelen om geen bezoek te ontvangen",
                         "Het heeft voor mij persoonlijke nadelen om de huisarts te bellen"); 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank())

ggdraw(theplot)

```

##### Verplichting tot opvolgen adviezen
Er is onderzocht in hoeverre respondenten zich verplicht voelen om de adviezen uit meldingen van de CoronaMelder op te volgen, en of dit leidt tot irritatie. Hieruit blijkt dat `r round((nrow(filter(data, (AdherenceNotification_voluntariness1 == 'Helemaal mee eens'| AdherenceNotification_voluntariness1 == 'Mee eens'| AdherenceNotification_voluntariness1 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% zich verplicht voelt om het advies uit de melding op te volgen, `r round((nrow(filter(data, (AdherenceNotification_voluntariness2 == 'Helemaal mee eens'| AdherenceNotification_voluntariness2 == 'Mee eens'| AdherenceNotification_voluntariness2 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% vindt dat het advies uit de melding hun vrijheid om zelf te kiezen wat zij doen bedreigt, `r round((nrow(filter(data, (AdherenceNotification_AffectAnger == 'Helemaal mee eens'| AdherenceNotification_AffectAnger == 'Mee eens'| AdherenceNotification_AffectAnger == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% boos wordt van het advies gegeven in de melding, en `r round((nrow(filter(data, (AdherenceNotification_AffectIrritation == 'Helemaal mee eens'| AdherenceNotification_AffectIrritation == 'Mee eens'| AdherenceNotification_AffectIrritation == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aangeeft dat het advies gegeven in de melding hen irriteert.

```{r verplichtingadviezen, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Verplichting om adviezen op te volgen", tab.cap="Verplichting om adviezen op te volgen"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotification_voluntariness1", 
                        "AdherenceNotification_voluntariness2", 
                        "AdherenceNotification_AffectAnger",
                        "AdherenceNotification_AffectIrritation")
graph_questionlabels = c("Ik voel me verplicht om het advies uit de melding op te volgen", 
                         "Het advies uit de melding bedreigt mijn vrijheid om zelf te kiezen wat ik doe", 
                         "Het advies gegeven in de melding maakt me boos",
                         "Het advies gegeven in de melding irriteert mij"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) 

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```
#### Verplichting tot opvolging adviezen over de tijd
```{r McNemarAdherenceNotification_voluntariness1overtime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotification_voluntariness1_agree_cw[(data_currentwave_wavemin1$AdherenceNotification_voluntariness1_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotification_voluntariness1_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotification_voluntariness1_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotification_voluntariness1_agree_cw[(data_currentwave_wavemin1$AdherenceNotification_voluntariness1_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotification_voluntariness1_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotification_voluntariness1_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotification_voluntariness1_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotification_voluntariness1_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotification_voluntariness1_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotification_voluntariness1_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotification_voluntariness1_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotification_voluntariness1_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotification_voluntariness1_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotification_voluntariness1_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotification_voluntariness1_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotification_voluntariness1_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$AdherenceNotification_voluntariness1_agree_cw, data_currentwave_wavemin1$AdherenceNotification_voluntariness1_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotification_voluntariness1_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotification_voluntariness1_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat men zich verplicht voelt om het advies uit de melding op te volgen.

```{r McNemarAdherenceNotification_voluntariness2overtime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotification_voluntariness2_agree_cw[(data_currentwave_wavemin1$AdherenceNotification_voluntariness2_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotification_voluntariness2_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotification_voluntariness2_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotification_voluntariness2_agree_cw[(data_currentwave_wavemin1$AdherenceNotification_voluntariness2_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotification_voluntariness2_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotification_voluntariness2_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotification_voluntariness2_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotification_voluntariness2_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotification_voluntariness2_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotification_voluntariness2_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotification_voluntariness2_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotification_voluntariness2_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotification_voluntariness2_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotification_voluntariness2_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotification_voluntariness2_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotification_voluntariness2_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$AdherenceNotification_voluntariness2_agree_cw, data_currentwave_wavemin1$AdherenceNotification_voluntariness2_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotification_voluntariness2_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotification_voluntariness2_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het advies uit de melding zijn/haar vrijheid om zelf te kiezen wat hij/zij doet, bedreigt.

```{r McNemarAdherenceNotification_AffectAngerovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotification_AffectAnger_agree_cw[(data_currentwave_wavemin1$AdherenceNotification_AffectAnger_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotification_AffectAnger_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotification_AffectAnger_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotification_AffectAnger_agree_cw[(data_currentwave_wavemin1$AdherenceNotification_AffectAnger_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotification_AffectAnger_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotification_AffectAnger_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotification_AffectAnger_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotification_AffectAnger_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotification_AffectAnger_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotification_AffectAnger_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotification_AffectAnger_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotification_AffectAnger_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotification_AffectAnger_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotification_AffectAnger_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotification_AffectAnger_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotification_AffectAnger_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$AdherenceNotification_AffectAnger_agree_cw, data_currentwave_wavemin1$AdherenceNotification_AffectAnger_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotification_AffectAnger_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotification_AffectAnger_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het advies uit de melding hem/haar boos maakt. 

```{r McNemarAdherenceNotification_AffectIrritationovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_agree_cw[(data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_cw == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_agree_cw[(data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_cw == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_cw == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_cw == 'Oneens'| data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_cw == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_wmin1 == 'Mee eens'| data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_agree_wmin1[(data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_wmin1 == 'Neutraal'| data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_wmin1 == 'Oneens'| data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_wmin1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_agree_cw, data_currentwave_wavemin1$AdherenceNotification_AffectIrritation_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotification_AffectIrritation_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (AdherenceNotification_AffectIrritation_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling dat het advies uit de melding hem/haar irriteert. 


```{r, echo=FALSE, fig.width=5.5, fig.height=4, dpi = 300, fig.cap="Verplichting tot het houden aan de adviezen de tijd, totaal percentage dat het minstens een beetje eens was met de stellingen (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotification_voluntariness1", 
                        "AdherenceNotification_voluntariness2", 
                        "AdherenceNotification_AffectAnger",
                        "AdherenceNotification_AffectIrritation")
graph_questionlabels = c("Ik voel me verplicht om het advies uit de melding op te volgen", 
                         "Het advies uit de melding bedreigt mijn vrijheid om zelf te kiezen wat ik doe", 
                         "Het advies gegeven in de melding maakt me boos",
                         "Het advies gegeven in de melding irriteert mij"); 
# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w2", "w3", "w4")

# Labels for the waves
wave_labels = c("7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-1)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```


#### Verklarend model voor opvolging adviezen gegeven in melding
*Situatie zonder symptomen.* Participanten werd gevraagd in hoeverre zij de intentie hadden om de adviezen uit de app op te volgen na het zien van een melding van de CoronaMelder, waarbij de situatie werd voorgelegd dat zijzelf geen symptomen hadden. Voor deze analyse zijn drie gedragsmaatregelen samengenomen tot één afhankelijke variabele, namelijk ‘bellen om een coronatest aan te vragen’, ‘zo lang thuisblijven als de melding adviseert’, en ‘geen bezoek ontvangen’.
 	Zelfeffectiviteit is de grootste voorspeller van het naleven van de gedragsmaatregelen (*β* = .21, *p* < .001), waarbij een hogere zelfeffectiviteit leidt tot een sterkere naleving van de gedragsmaatregelen. Ook de mate waarin men zichzelf ontvankelijk acht voor besmetting met het coronavirus speelde een significante en positieve rol (*β* = .176, *p* = .002). De overige variabelen (d.w.z., gepercipieerde voordelen, gepercipieerde barrières, gepercipieerde ernst van een besmetting met het coronavirus, leeftijd en geslacht) hadden geen significante invloed op de naleving van de gedragsmaatregelen.
 	
*Situatie met symptomen.* Net als in de situatie zonder symptomen werd aan participanten gevraagd in hoeverre zij de intentie hadden om de adviezen uit de app op te volgen na het zien van een melding van de CoronaMelder, maar dit keer in een situatie met symptomen. Wederom was zelfeffectiviteit de grootste voorspeller van naleving van de gedragsmaatregelen (*β* = .41, *p* < .001). Daarnaast bleek gepercipieerde ernst een significante en positieve rol te spelen (*β* = .14, *p* = .017). De overige variabelen (d.w.z., gepercipieerde voordelen, gepercipieerde barrières, gepercipieerde ontvankelijkheid voor een besmetting met het coronavirus, leeftijd en geslacht) hadden geen significante invloed op de naleving van de gedragsmaatregelen. Een overzicht van alle predictievariabelen en model fit per model is te vinden in de Appendix (6.2 en 6.3).




### Intentie tot doorgeven GGD-sleutel na positieve test
Als iemand positief is getest op het coronavirus kan men dit daarna via de app laten weten door de GGD-sleutel door te geven aan de GGD medewerker. Dan waarschuwt de app weer mensen bij wie de positief geteste persoon in de buurt is geweest. Van de respondenten heeft `r round((nrow(filter(data, (Intention_reportinfection == 'Helemaal mee eens'| Intention_reportinfection == 'Mee eens'| Intention_reportinfection == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%  de intentie om de GGD-sleutel door te geven. 

```{r, echo=FALSE, fig.width=7, fig.height=2.5, fig.cap="Intentie tot doorgeven GGD-sleutel", tab.cap="Intentie tot doorgeven GGD-sleutel"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_reportinfection")
graph_questionlabels = c("Als ik besmet ben, ben ik van plan om dit door te geven via de CoronaMelder app"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. The following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette_nonuse, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Intentie tot doorgeven GGD-sleutel na positieve test over de tijd
``` {r McNemarsharekeyovertime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Intention_reportinfection_agree_cw[(data_currentwave_wavemin1$Intention_reportinfection_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$Intention_reportinfection_cw == 'Mee eens'| data_currentwave_wavemin1$Intention_reportinfection_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Intention_reportinfection_agree_cw[(data_currentwave_wavemin1$Intention_reportinfection_cw == 'Neutraal'| data_currentwave_wavemin1$Intention_reportinfection_cw == 'Een beetje oneens'| data_currentwave_wavemin1$Intention_reportinfection_cw == 'Oneens'| data_currentwave_wavemin1$Intention_reportinfection_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$Intention_reportinfection_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Intention_reportinfection_agree_wmin1[(data_currentwave_wavemin1$Intention_reportinfection_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$Intention_reportinfection_wmin1 == 'Mee eens'| data_currentwave_wavemin1$Intention_reportinfection_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Intention_reportinfection_agree_wmin1[(data_currentwave_wavemin1$Intention_reportinfection_wmin1 == 'Neutraal'| data_currentwave_wavemin1$Intention_reportinfection_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$Intention_reportinfection_wmin1 == 'Oneens'| data_currentwave_wavemin1$Intention_reportinfection_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$Intention_reportinfection_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Intention_reportinfection_agree_cw, data_currentwave_wavemin1$Intention_reportinfection_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table)
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Intention_reportinfection_agree_cw == 'Totaal eens_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Intention_reportinfection_agree_wmin1 == 'Totaal eens_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf het eens te zijn met de stelling om een positieve testuitslag door te geven via de CoronaMelder app.

```{r, echo=FALSE, fig.width=5.5, fig.height=2.5, dpi = 300, fig.cap="Intentie tot doorgeven GGD-sleutel na positieve test over tijd, totaal percentage dat het minstens een beetje eens is met de stelling (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_reportinfection")
graph_questionlabels = c("Als ik besmet ben, ben ik van plan om dit door te geven via de CoronaMelder app"); 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank())

ggdraw(theplot)

```

#### Intentie tot doorgeven GGD-sleutel na positieve test - alleen huidige gebruikers
Dezelfde bepalingen zijn ook gedaan in alleen de subsample (n = `r nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))`) die momenteel de CoronaMelder gebruikt. Van deze subsample van respondenten die momenteel de CoronaMelder gebruikt had `r round((nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')&(Intention_reportinfection == 'Helemaal mee eens'| Intention_reportinfection == 'Mee eens'| Intention_reportinfection == 'Een beetje mee eens'))) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`% de  intentie om de GGD sleutel door te geven na een positieve test.  

``` {r sharekeyscurrentusers, echo=FALSE, fig.width=7, fig.height=2.5, fig.cap="Intentie tot doorgeven GGD-sleutel na positieve test - alleen huidige gebruikers", tab.cap="Intentie tot doorgeven GGD-sleutel na positieve test - alleen huidige gebruikers"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_reportinfection")
graph_questionlabels = c("Als ik besmet ben, ben ik van plan om dit door te geven via de CoronaMelder app"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. 
# However, for without symptoms, nobody answered "Ik zou de CoronaMelder app niet gebruiken". Therefore, the following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


#### Intentie tot doorgeven GGD-sleutel na positieve test over de tijd - alleen gebruikers
```{r Chisquarereportinfectionovertimeusers, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Intention_reportinfection_agree_cw[(data_currentwave_wavemin1$Intention_reportinfection_cw == 'Helemaal mee eens'| data_currentwave_wavemin1$Intention_reportinfection_cw == 'Mee eens'| data_currentwave_wavemin1$Intention_reportinfection_cw == 'Een beetje mee eens')] <- "Totaal eens_cw"
data_currentwave_wavemin1$Intention_reportinfection_agree_cw[(data_currentwave_wavemin1$Intention_reportinfection_cw == 'Neutraal'| data_currentwave_wavemin1$Intention_reportinfection_cw == 'Een beetje oneens'| data_currentwave_wavemin1$Intention_reportinfection_cw == 'Oneens'| data_currentwave_wavemin1$Intention_reportinfection_cw == 'Helemaal mee oneens'| data_currentwave_wavemin1$Intention_reportinfection_cw == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Intention_reportinfection_agree_wmin1[(data_currentwave_wavemin1$Intention_reportinfection_wmin1 == 'Helemaal mee eens'| data_currentwave_wavemin1$Intention_reportinfection_wmin1 == 'Mee eens'| data_currentwave_wavemin1$Intention_reportinfection_wmin1 == 'Een beetje mee eens')] <- "Totaal eens_wmin1"
data_currentwave_wavemin1$Intention_reportinfection_agree_wmin1[(data_currentwave_wavemin1$Intention_reportinfection_wmin1 == 'Neutraal'| data_currentwave_wavemin1$Intention_reportinfection_wmin1 == 'Een beetje oneens'| data_currentwave_wavemin1$Intention_reportinfection_wmin1 == 'Oneens'| data_currentwave_wavemin1$Intention_reportinfection_wmin1 == 'Helemaal mee oneens'| data_currentwave_wavemin1$Intention_reportinfection_wmin1 == 'Ik zou de CoronaMelder app niet gebruiken')] <- "Neutraal, niet mee eens_wmin1"

# THe following explanation holds for BI1a and BI1b: The fact that for some of the participants the user status changed between wave 1 and wave 2, we decided to perform a chi square in which we compare the proportion of Totaal eens_wmin1 versus Neutraal, niet mee eens_wmin1 for users of wave 1 with the proportion of Totaal eens_cw versus Neutraal, niet mee eens_cw for users of the current wave. For this we have to select, separately for each wave, the users (or non users). For these subsets we calculate counts with Totaal eens and Neutraal, etc. After that we concatenate these counts int a 2x2 table and perform a regular chi square on that.  
data_selected_cw = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_cw == "Ik gebruik de CoronaMelder app op dit moment", ]

data_selected_wmin1 = data_currentwave_wavemin1[data_currentwave_wavemin1$Behavior_UTAUT_wmin1 == "Ik gebruik de CoronaMelder app op dit moment", ]

# Convert into a table that can be used for the chi square test
chisq.table = rbind(table(data_selected_cw$Intention_reportinfection_agree_cw), table(data_selected_wmin1$Intention_reportinfection_agree_wmin1))
rownames(chisq.table) <- c('cw', 'wmin1')

# Convert into a table that can be used for the chi square test
chisqtest = chisq.test(chisq.table) 
```
Om te bepalen of de intentie tot het doorgeven van de GGD-sleutel bij de gebruikers verschilt tussen de huidige en de vorige wave is een chi kwadraat uitgevoerd. Een complexiteit in deze analyse is dat sommige deelnemers in de vorige wave gebruikers waren en in de huidige niet (meer), of andersom. Om deze reden is in deze test een vergelijking gemaakt waarin de gebruikersstatus in beide waves is meegenomen. De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers in de huidige wave (`r round((nrow(filter(data_selected_cw, Intention_reportinfection_agree_cw == 'Totaal eens_cw')) /nrow(data_selected_cw))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij de intentie heeft om in de CoronaMelder door te geven als hij/zij besmet is, vergeleken met het percentage gebruikers uit de vorige wave dat in de vorige wave aangaf het hiermee eens te zijn (`r round((nrow(filter(data_selected_wmin1, Intention_reportinfection_agree_wmin1 == 'Totaal eens_wmin1')) /nrow(data_selected_wmin1))*100, digits = 1)`%). 

```{r, echo=FALSE, fig.width=5.5, fig.height=2.5, dpi = 300, fig.cap="Intentie tot doorgeven GGD-sleutel na positieve test over tijd, alleen huidige gebruikers, totaal percentage dat het minstens een beetje eens is met de stelling (een beetje mee eens, mee eens, helemaal mee eens)."}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_reportinfection")
graph_questionlabels = c("Als ik besmet ben, ben ik van plan om dit door te geven via de CoronaMelder app"); 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars & (eval(parse(text=paste('Behavior_UTAUT', include_waves[wave_idx], sep="_")))) == 'Ik gebruik de CoronaMelder app op dit moment')) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) & (eval(parse(text=paste('Behavior_UTAUT', include_waves[wave_idx], sep="_")))) == 'Ik gebruik de CoronaMelder app op dit moment'))
    }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank()) 

ggdraw(theplot)

```

### Onbeoogde effecten: schijnveiligheid
Een gevoel van schijnveiligheid zou kunnen optreden bij de adoptie van de CoronaMelder, wat ervoor zou kunnen zorgen dat andere maatregelen minder nodig worden geacht. Uit de antwoorden op de stelling of men zich minder aan andere maatregelen kan houden bij het gebruik van de CoronaMelder, blijkt dat slechts een klein aandeel denkt dat dit het geval is. Het aandeel dat op deze vraag 'zeker waar' of 'misschien waar' antwoordt, is `r round((nrow(filter(data, (Beliefs_falsesecurity1 == 'Zeker waar'| Beliefs_falsesecurity1 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%. Een aanzienlijk percentage denkt dat het gebruiken van de CoronaMelder het risico op een besmetting met het coronavirus verlaagt (`r round((nrow(filter(data, (Beliefs_falsesecurity2 == 'Zeker waar'| Beliefs_falsesecurity2 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%).

```{r falsesecurity, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Schijnveiligheid", tab.cap="Schijnveiligheid"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_falsesecurity1",
                        "Beliefs_falsesecurity2")
graph_questionlabels = c("Als ik de CoronaMelder gebruik, hoef ik me minder aan de andere maatregelen te houden",
                         "Als ik de CoronaMelder gebruik, verlaag ik mijn risico op een besmetting met het coronavirus"); 

# These questions have 5 answer categories: Zeker niet waar - Zeker waar en Weet ik niet. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Zeker waar", "Misschien waar", "Misschien niet waar", "Zeker niet waar"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Schijnveiligheid over de tijd
```{r McNemarfalsesecurity1overtime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_falsesecurity1_agree_cw[(data_currentwave_wavemin1$Beliefs_falsesecurity1_cw == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_falsesecurity1_cw == 'Misschien waar')] <- "Totaal waar_cw"
data_currentwave_wavemin1$Beliefs_falsesecurity1_agree_cw[(data_currentwave_wavemin1$Beliefs_falsesecurity1_cw == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_falsesecurity1_cw == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_falsesecurity1_cw == 'Misschien niet waar')] <- "Weet niet, niet waar_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_falsesecurity1_agree_wmin1[(data_currentwave_wavemin1$Beliefs_falsesecurity1_wmin1 == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_falsesecurity1_wmin1 == 'Misschien waar')] <- "Totaal waar_wmin1"
data_currentwave_wavemin1$Beliefs_falsesecurity1_agree_wmin1[(data_currentwave_wavemin1$Beliefs_falsesecurity1_wmin1 == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_falsesecurity1_wmin1 == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_falsesecurity1_wmin1 == 'Misschien niet waar')] <- "Weet niet, niet waar_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_falsesecurity1_agree_cw, data_currentwave_wavemin1$Beliefs_falsesecurity1_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table) 
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_falsesecurity1_agree_cw == 'Totaal waar_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_falsesecurity1_agree_wmin1 == 'Totaal waar_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf dat de stelling dat als de CoronaMelder wordt gebruikt, men zich minder hoeft te houden aan andere maatregelen, waar is.  
```{r McNemarfalsesecurity2overtime, echo=FALSE}
# First calculate a proportion for the variable for the current wave. 
data_currentwave_wavemin1$Beliefs_falsesecurity2_agree_cw[(data_currentwave_wavemin1$Beliefs_falsesecurity2_cw == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_falsesecurity2_cw == 'Misschien waar')] <- "Totaal waar_cw"
data_currentwave_wavemin1$Beliefs_falsesecurity2_agree_cw[(data_currentwave_wavemin1$Beliefs_falsesecurity2_cw == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_falsesecurity2_cw == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_falsesecurity2_cw == 'Misschien niet waar')] <- "Weet niet, niet waar_cw"

# Calculate a proportion for the variable for the previous wave. 
data_currentwave_wavemin1$Beliefs_falsesecurity2_agree_wmin1[(data_currentwave_wavemin1$Beliefs_falsesecurity2_wmin1 == 'Zeker waar'| data_currentwave_wavemin1$Beliefs_falsesecurity2_wmin1 == 'Misschien waar')] <- "Totaal waar_wmin1"
data_currentwave_wavemin1$Beliefs_falsesecurity2_agree_wmin1[(data_currentwave_wavemin1$Beliefs_falsesecurity2_wmin1 == 'Weet ik niet'| data_currentwave_wavemin1$Beliefs_falsesecurity2_wmin1 == 'Zeker niet waar'| data_currentwave_wavemin1$Beliefs_falsesecurity2_wmin1 == 'Misschien niet waar')] <- "Weet niet, niet waar_wmin1"

# Convert into a table that can be used for the chi square test
mcnemar.table = table(data_currentwave_wavemin1$Beliefs_falsesecurity2_agree_cw, data_currentwave_wavemin1$Beliefs_falsesecurity2_agree_wmin1)
mcnemartest = mcnemar.test(mcnemar.table) 
if( sum(mcnemar.table) != nrow(data)) stop('mcnemar table does not sum up to 1594')
```
De McNemar toets (X²(`r mcnemartest$parameter`) = `r round(mcnemartest$statistic, digits = 2)`, p `r ifelse(mcnemartest$p.value < 0.001, "<0.001", paste("=", round(mcnemartest$p.value, digits = 3)))`) liet zien dat er `r if(mcnemartest$p.value > 0.05){"g"}`een significant verschil was tussen de huidige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_falsesecurity2_agree_cw == 'Totaal waar_cw'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) en de vorige meting (`r round((nrow(filter(data_currentwave_wavemin1, (Beliefs_falsesecurity2_agree_wmin1 == 'Totaal waar_wmin1'))) /nrow(filter(data_currentwave_wavemin1)))*100, digits = 1)`%) in het percentage dat aangaf dat de stelling dat de CoronaMelder ervoor zorgt dat de kans op besmetting verlaagt, waar is.  

NB: Er is een wijziging doorgevoerd in de vraagstelling. De vraag "Als ik de CoronaMelder app gebruik, verlaag ik mijn risico op een besmetting met het coronavirus", werd in wave 1 (19 oktober t/m 1 november 2020) gesteld als "De CoronaMelder zorgt ervoor dat ik niet besmet raak met het coronavirus".

```{r, echo=FALSE, fig.width=5.5, fig.height=3, dpi = 300, fig.cap="Schijnveiligheid over tijd, totaal percentage dat de stellingen minstens misschien waar vindt (misschien waar, zeker waar)."}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_falsesecurity1",
                        "Beliefs_falsesecurity2")
graph_questionlabels = c("Als ik de CoronaMelder gebruik, hoef ik me minder aan de andere maatregelen te houden",
                         "Als ik de CoronaMelder app gebruik, verlaag ik mijn risico op een besmetting met het coronavirus"); 

# Which values do we want to include in the table cells?
include_vars = c("Zeker waar", "Misschien waar")

# Which waves do we want to include in the table cells?
include_waves = c("w1", "w2", "w3", "w4")

# Labels for the waves
wave_labels = c("19 okt-1 nov 2020", "7 dec-20 dec 2020", "18 jan-31 jan 2021", "15 mrt-28 mrt 2021")


#### No changes should be needed after this point ####

data_overtime = data.frame(matrix(ncol = 3, nrow = length(graph_variablenames)*length(include_waves)))
colnames(data_overtime) <- c("wave", "variable", "perc_positiveanswer")

for(wave_idx in 1:length(include_waves)) {

  for(variable_idx in 1:length(graph_variablenames)) {
    idx = (wave_idx-1)*length(graph_variablenames)+variable_idx
    data_overtime[idx,"variable"] = graph_questionlabels[variable_idx]
    data_overtime[idx,"wave"] = include_waves[wave_idx]
    
    data_overtime[idx,"perc_positiveanswer"] = nrow(filter(data_allwaves, (eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_")))) %in% include_vars)) / nrow(filter(data_allwaves, !is.na(eval(parse(text=paste(graph_variablenames[variable_idx], include_waves[wave_idx], sep="_"))))))
  }
}

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_overtime$variable <- factor(data_overtime$variable,levels = graph_questionlabels)

# Create the plot
# data_ends <- data_overtime %>% filter(wave == include_waves[-1])

theplot <- ggplot(data_overtime, aes(x = wave, y = perc_positiveanswer, group = variable)) +
  geom_line(aes(color = variable), size=1) +
  geom_point() +
  theme_bw() + 
  labs(x = "", y = "", fill = "") +
  scale_color_manual(values=brewer.pal(8, "Dark2"), labels=stringr::str_wrap(graph_questionlabels, width = 80)) +
  scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1), limits=c(0,1)) +
  scale_x_discrete(labels=wave_labels, expand=c(1,-2.5)) +
  theme(legend.position = "top", legend.direction = "vertical", legend.title = element_blank())

ggdraw(theplot)

```



```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```

# Conclusies en aanbevelingen
## Intenties en werkelijk gebruik
Van alle respondenten waren meer dan 9 op de 10 (`r round(((nrow(filter(data, Awareness == 'Heel erg bekend')) + nrow(filter(data, Awareness == 'Bekend')) + nrow(filter(data, Awareness == 'Redelijk bekend'))+ nrow(filter(data, Awareness == 'Een beetje bekend')))/nrow(data)*100), digits = 1)`%) in meer of mindere mate bekend met de CoronaMelder en dit percentage week niet significant af van de vorige meting. Daarnaast gaf bijna een derde (`r round(nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))/nrow(data)*100, digits = 1)`%) aan dat hij/zij de CoronaMelder op dit moment gebruikt. 

Het aandeel dat de CoronaMelder in het verleden heeft gebruikt, maar op dit moment niet meer, is gestegen van 1.6% in de eerste meting 1.5 week na de lancering naar `r round(nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer'))/nrow(data)*100, digits = 1)`% in de huidige meting. Van de gehele Nederlandse bevolking is niet bekend hoeveel mensen de app weer verwijderd hebben. Daarnaast is, net als in de vorige wave, de overgrote meerderheid (`r round((nrow(filter(data, (BI1b_UTAUT == 'Helemaal mee eens'| BI1b_UTAUT == 'Mee eens'| BI1b_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`%) van de huidige gebruikers van plan om de app de komende twee maanden te blijven gebruiken. Dit komt overeen met onze verwachtingen op basis van het feit dat het in principe geen moeite kost om de app te blijven gebruiken als deze eenmaal geïnstalleerd is, aangezien deze op de achtergrond draait. Wel laat literatuur op het gebied van eHealth zien dat zaken als een hoog energieverbruik, stress dat wordt verergerd door het gebruik van de app, of een teleurstellende ervaring (bv. onterechte meldingen) ertoe kunnen leiden dat mensen de app zullen deïnstalleren (Thorneloe et al., 2020). Dit zouden redenen voor deïnstallatie kunnen zijn. 

Van de respondenten die de CoronaMelder nog nooit hebben gebruikt, gaf `r round((nrow(filter(data, (BI1a_UTAUT == 'Helemaal mee eens'| BI1a_UTAUT == 'Mee eens'| BI1a_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`% aan van plan te zijn om de app te gaan gebruiken in de komende twee maanden, tegenover 18% in de eerste meting. Dat de intentie gedaald is, suggereert dat een deel van de respondenten die de intentie had om de CoronaMelder te gebruiken, deze intentie nu hebben omgezet naar daadwerkelijk gebruik. Daarnaast heeft een deel hiervan niet meer de intentie om de CoronaMelder te gaan gebruiken. Er blijft een verschil bestaan tussen intentie en werkelijk gebruik, wat ook in de literatuur terugkomt en wellicht te wijten is aan de intention-behavior gap (Sheeran & Webb, 2016), een bekend fenomeen waarbij maar een deel van de mensen met een intentie om bepaald gedrag te vertonen, ook daadwerkelijk dat gedrag gaat uitvoeren. Het aandeel dat neutraal staat tegenover de intentie om de CoronaMelder te gebruiken is gedaald van 24.5% in de eerste meting 1.5 week na de lancering naar `r round((nrow(filter(data, (BI1a_UTAUT == 'Neutraal') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`% in de huidige meting. Deze (kleine) groep niet gebruikers met de intentie om de CoronaMelder app te gaan gebruiken en degenen die hier neutraal in staan zouden met de juiste informatievoorziening en een *cue to action* mogelijk gestimuleerd kunnen worden om de app in gebruik te nemen. De hierboven genoemde verschuivingen suggereren echter ook dat het het verder stimuleren van adoptie betekent dat degenen die expliciet aangeven geen intentie te hebben de CoronaMelder te gebruiken zullen moeten worden overtuigd wil men de adoptie verder verhogen.  

## Demografie
Net als in de vorige metingen, hangen opleidingsniveau en netto maandinkomen samen met de gebruikersstatus. Hoger opgeleiden gebruiken de CoronaMelder vaker dan lager opgeleiden, en hetzelfde patroon is zichtbaar met betrekking tot maandinkomen. Dit laatste komt overeen met bevindingen van von Wyl et al. (2020), die in Zwitserland ook een positieve relatie tussen inkomen van het huishouden en adoptie intentie vaststelden. Tenslotte was er, net als in het merendeel van de gevonden literatuur, geen significant verschil in gebruik van de CoronaMelder op basis van geslacht. 

## Algemene opvattingen over het coronavirus
Er doen veel waar- maar ook onwaarheden de ronde met betrekking tot het coronavirus. De respondenten werd gevraagd in hoeverre ze dachten dat het waar is dat het coronavirus een biologisch wapen is, en dat het met (de aanleg van) het 5G netwerk te maken heeft. `r round((nrow(filter(data, (Beliefs_Conspiracy1 == 'Zeker waar'| Beliefs_Conspiracy1 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`% dacht dat het het coronavirus (misschien of zeker) een biologisch wapen is en `r round((nrow(filter(data, (Beliefs_Conspiracy2 == 'Zeker waar'| Beliefs_Conspiracy2 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`% dat er een verband met 5G is. Hoewel deze percentages niet hoger zijn vergeleken met de vorige meting zijn het relatief hoge percentages, dus het is belangrijk om dit soort misconcepties te weerleggen. Vergelijkbare cijfers (15% biologisch wapen, 4% 5G) kwamen ook voort uit een onderzoek van Ipsos in samenwerking met Nieuwsuur (Ipsos, 2020).

Hoewel het aantal mensen dat gelooft in complottheorieën over het algemeen mee lijkt te vallen, is het wel opvallend hoe groot hier de verschillen zijn tussen de groep huidige gebruikers en de groep niet gebruikers. Zo denkt `r round((nrow(filter(data, (user_status == 'Gebruiker'& Beliefs_Conspiracy1_agree == 'Totaal waar'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`% van de gebruikers en `r round((nrow(filter(data, (user_status == 'Niet gebruiker' & Beliefs_Conspiracy1_agree == 'Totaal waar'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`% van de niet gebruikers dat het coronavirus een biologisch wapen is. Deze overtuigingen zouden kunnen voortkomen uit onduidelijkheden die bestaan rondom het coronavirus in het algemeen, zoals bijvoorbeeld de oorsprong ervan. De cijfers uit dit onderzoek benadrukken het belang van het corrigeren van mogelijke misvattingen. Wat zou kunnen helpen om deze te weerleggen is om de bevolking niet alleen op de hoogte te houden van de actuele stand van zaken (zoals aantal infecties per dag), maar om ook duidelijk te communiceren over feiten en misvattingen over het virus.

## Gezondheidsmotivatie en risicoperceptie
In de bestaande literatuur vonden we gemengde resultaten (de Wit et al., 2020), waarbij de waargenomen ernst van het virus en het risico om het virus op te lopen in een deel van de onderzoeken als voorspellers werden gezien van intentie om een contact tracing app te gaan gebruiken (Rheault & Musulan, 2020; Strycharz et al., 2020; Wnuk et al., 2020), en dit in andere onderzoeken niet het geval was (Kaspar, 2020; Walrave et al., 2020). In het huidige onderzoek zien we waargenomen ernst en risico wel samenhangen met gebruik: niet gebruikers waren het significant minder vaak eens met stellingen die betrekking hadden op het verwachte risico om zelf besmet te raken met het coronavirus, en het risico om vervolgens anderen te besmetten. Ook met stellingen betreffende de gemeende ernst van het zelf krijgen en anderen besmetten waren de niet gebruikers het minder vaak eens. Er is er een significante daling te zien in de risicoperceptie (de kans) om het coronavirus zelf op te lopen, de inschatting van de ernst van een besmetting, en hoe erg met het vindt om anderen te besmetten. In de verklarende modellen was de risicoperceptie geen significante predictor van gebruik van de CoronaMelder.  
 
## Verwachte effectiviteit
Een factor die in de verklarende modellen voor adoptie een significante samenhang met gebruik had is de verwachte effectiviteit. Eerder onderzoek wees al uit dat de overtuiging dat de CoronaMelder bijdraagt aan de bestrijding van het coronavirus een belangrijke motivatie is voor de adoptie (Jansen-Kosterink et al., 2020; Proszowska et al., 2020). Nederlanders lijken volgens eerdere studies sceptisch tegenover de effectiviteit van de CoronaMelder te staan, met name in de leeftijdscategorie 31-49. In de studie van Jansen-Kosterink et al (2020) was voor 13% van de deelnemers twijfels over de effectiviteit van de app een belangrijke reden om deze niet te installeren. 

In de huidige studie is ongeveer de helft van de respondenten van mening dat de CoronaMelder effectief is ter bestrijding van het coronavirus (`r round((nrow(filter(data, (PE1_UTAUT == 'Helemaal mee eens'| PE1_UTAUT == 'Mee eens'| PE1_UTAUT == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) en ter bescherming van kwetsbare mensen (`r round((nrow(filter(data, (Beliefs_Protectriskgroups == 'Helemaal mee eens'| Beliefs_Protectriskgroups == 'Mee eens'| Beliefs_Protectriskgroups == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Deze percentages liggen aanzienlijk hoger bij gebruikers (bijdrage bestrijding: `r round((nrow(filter(data, (user_status == 'Gebruiker'& PE1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`%; beschermen risicogroepen: `r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_Protectriskgroups_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%), in vergelijking tot niet gebruikers (bijdrage bestrijding: `r round((nrow(filter(data, (user_status == 'Niet gebruiker' & PE1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%; beschermen risicogroepen: `r round((nrow(filter(data, (user_status == 'Niet gebruiker' & Beliefs_Protectriskgroups_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%). De verwachte effectiviteit lijkt dus een belangrijke factor om op in te spelen om de niet gebruikers over te halen tot adoptie. Daarnaast staat nog een flink aandeel (rond een kwart) neutraal tegenover de stellingen over de verwachte effectiviteit. 

Over de tijd is te zien dat de verwachte effectiviteit varieert maar ten opzichte van de eerste meting 1.5 week (53.4% eens) na de lancering is er een daling te zien in het percentage respondenten dat het min of meer eens is met de stelling dat het gebruiken van de CoronaMelder bijdraagt aan het bestrijden van het coronavirus (huidige meting: `r round((nrow(filter(data, (PE1_UTAUT == 'Helemaal mee eens'| PE1_UTAUT == 'Mee eens'| PE1_UTAUT == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% eens). Gezien het belang van deze factor en de dalende lijn is  belangrijk om de effectiviteit van de CoronaMelder en de meerwaarde van de app te (blijven) communiceren. Daarbij is het geadviseerd om te focussen op succesverhalen, bijvoorbeeld als mensen door de CoronaMelder (eerder) ontdekken dat ze het coronavirus hebben opgelopen. 

Het percentage dat verwacht dat de CoronaMelder effectief is bij het beschermen van mensen met een kwetsbare gezondheid is zeer licht afgenomen (`r round((nrow(filter(data, (Beliefs_Protectriskgroups == 'Helemaal mee eens'| Beliefs_Protectriskgroups == 'Mee eens'| Beliefs_Protectriskgroups == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) ten opzichte van de vorige meting waardoor het weer iets dichter in de buurt komt van het niveau in de eerste meting 1.5 week na de lancering (48.8%). Als de effectiviteit van de CoronaMelder voor de kwetsbaren groter wordt geacht, zou de communicatiestrategie de focus kunnen leggen op het helpen van anderen. Uit een eerdere wetenschappelijke studie bleek ook dat het communiceren van maatschappelijke voordelen een betere voorspeller was van adoptie intentie dan het communiceren van de persoonlijke voordelen, en dan het communiceren van een combinatie van de persoonlijke en maatschappelijke voordelen (Trang et al., 2020). Daarnaast zien we bij de risicoperceptie ook dat respondenten het erger vinden om andere mensen te besmetten, dan om zelf besmet te raken.

Over het algemeen heeft men de inschatting dat een (zeer) hoge adoptie nodig is om bij te dragen aan het tegengaan van de verspreiding van het coronavirus. De meesten gaven aan dat 76 tot 90% de CoronaMelder moet gebruiken om effectief te zijn (`r round(nrow(filter(data, Beliefs_ResponseefficasyOther == '76-90%'))/nrow(data)*100, digits = 1)`%). Daarnaast gaf een aanzienlijk percentage aan niet te weten bij welk percentage adoptie de CoronaMelder bijdraagt (`r round(nrow(filter(data, Beliefs_ResponseefficasyOther == 'Weet ik niet'))/nrow(data)*100, digits = 1)`%). De beperkte verwachte effectiviteit kan mogelijk verklaard worden doordat men denkt dat een hoge adoptie vereist is en men op hetzelfde moment denkt/weet dat de adoptie momenteel niet op dit niveau zit (zie ook de sectie over sociale factoren). Indien duidelijker wordt gecommuniceerd dat de effectiviteit van de CoronaMelder afhankelijk is van het aantal mensen dat deze app installeert, maar dat er ook al een bijdrage is bij een lagere adoptie, is men wellicht sterker bereid om de app te installeren.

## CoronaMelder in de media
Het is interessant om te weten in hoeverre mediaberichtgeving en de toon van deze berichten verband houdt met adoptie van de CoronaMelder. Ruim 8 op de 10 respondenten (`r round((nrow(filter(data, (Media == 'Vaak'| Media == 'Soms'| Media == 'Af en toe'))) /nrow(data))*100, digits = 1)`%) gaf aan de CoronaMelder af en toe, soms of vaak in de media en/of het nieuws hebben gehoord. Van dit percentage geeft een relatief laag percentage (`r round((nrow(filter(data, (MediaValence == 'Heel erg negatief'| MediaValence == 'Negatief'| MediaValence == 'Een beetje negatief'))) /nrow(filter(data, (Media == 'Vaak'| Media == 'Soms'| Media == 'Af en toe'))))*100, digits = 1)`%) aan dat de berichten overwegend negatief van toon waren. Daarnaast gaf `r round((nrow(filter(data, (MediaValence == 'Heel erg positief'| MediaValence == 'Positief'| MediaValence == 'Een beetje positief'))) /nrow(filter(data, (Media == 'Vaak'| Media == 'Soms'| Media == 'Af en toe'))))*100, digits = 1)`% aan dat deze berichten in de media over het algemeen positief van toon waren. Interessant is dat de gebruikers significant vaker aangeven dat de berichten positief van toon waren dan de niet gebruikers. Enerzijds kan het zijn dat de niet gebruikers meer zijn blootgesteld aan negatief nieuws dan aan positief nieuws over de CoronaMelder dan gebruikers, en dat dit heeft geleid tot de keuze om de CoronaMelder niet te installeren. Anderzijds kan het ook zijn dat confirmation bias hier een rol in speelt: de neiging van mensen om te zoeken naar informatie die de eigen overtuigingen en opvattingen bevestigen. De niet gebruikers stonden wellicht al negatief over de CoronaMelder, en zoeken selectief naar negatieve informatie om deze overtuigingen te bevestigen. Uit deze data kan niet worden geconcludeerd of de negatieve berichtgeving heeft geleid tot het afzien van adoptie, of dat men vooraf aan het zien van mediaberichtgeving al een sterke negatieve overtuiging had.

## Vertrouwen in adequaatheid techniek
Een overgroot deel (`r round((nrow(filter(data, (Beliefs_technologyperformance == 'Zeker waar'| Beliefs_technologyperformance == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%) van de respondenten gelooft dat de techniek (bluetooth) die gebruikt wordt in de CoronaMelder inderdaad kan aangeven wie er in de buurt is geweest van een persoon die besmet is. Dit getal lag significant lager bij respondenten die de app nog nooit gebruikt hadden dan bij respondenten die de app gebruikten. Ook onder niet gebruikers ligt dit getal wel nog boven de 7 op de 10 (`r round((nrow(filter(data, (user_status == 'Niet gebruiker' & Beliefs_technologyperformance_agree == 'Totaal waar'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%) respondenten, dus over het algemeen lijkt men het vertrouwen te hebben dat de techniek adequaat is. Deze factor is stabiel (hoog) over de tijd.   

## Privacy 
De verklarende modellen lieten zien dat overtuigingen omtrent privacy een significante samenhang met gebruik hadden. Zorgen over privacy kwamen in onze literatuurstudie (de Wit et al., 2020) ook terug als een van de grootste redenen om contact tracing apps niet te gebruiken (Biddle et al., 2020; Horstmann et al., 2020; Jansen-Kosterink et al., 2020; Joo & Shin, 2020; Kukuk, 2020; Proszowska et al., 2020; Rheault & Musulan, 2020; Simko et al., 2020; Zhang et al., 2020). Ook bij de respondenten van het huidige onderzoek lijkt dit dus een rol te spelen: het merendeel van de huidige gebruikers (`r round((nrow(filter(data, (user_status == 'Gebruiker'& Beliefs_datasafety_agree == 'Totaal waar'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`%) van de CoronaMelder is van mening dat informatie in de CoronaMelder app strikt vertrouwelijk wordt gehouden, terwijl minder dan 6 op de 10 (`r round((nrow(filter(data, (user_status == 'Niet gebruiker' & Beliefs_datasafety_agree == 'Totaal waar'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%) het hiermee eens onder de niet gebruikers. Over de hele populatie is het percentage dat het eens is met deze stelling licht afgenomen tussen de huidige (`r round((nrow(filter(data, (Beliefs_datasafety == 'Zeker waar'| Beliefs_datasafety == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%) en de vorige, derde, meting (68.7%)

Tegelijkertijd bestaan er ook wat misverstanden over de techniek van de CoronaMelder: bijna 6 op de 10 van de huidige gebruikers (`r round((nrow(filter(data, (user_status == 'Gebruiker'& Beliefs_locationmonitoring_agree == 'Totaal waar'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`%) denkt dat de CoronaMelder de locatie van de gebruiker bijhoudt, terwijl 7 op de 10 (`r round((nrow(filter(data, (user_status == 'Niet gebruiker' & Beliefs_locationmonitoring_agree == 'Totaal waar'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%) van de niet gebruikers dit denkt. We zien een soortgelijk patroon wanneer het gaat om het bijhouden van de naam of persoonsgegevens van de gebruiker, waarbij ruim 3 op de 10 (`r round((nrow(filter(data, (user_status == 'Gebruiker'& Beliefs_identitymonitoring_agree == 'Totaal waar'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`%) huidige gebruikers (onterecht) denkt dat dit het geval is, en meer dan de helft (`r round((nrow(filter(data, (user_status == 'Niet gebruiker' & Beliefs_identitymonitoring_agree == 'Totaal waar'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%) van de niet gebruikers. Het aantal mensen dat deze misverstanden heeft is redelijk constant gebleven tussen de eerste en vierde meting. Een eerder onderzoek onder de Nederlandse bevolking gaf ook al aan dat er veel misverstanden zijn over zowel de werking van de app, als over de manier waarop gegevens worden verzameld en verwerkt (Proszowska et al., 2020).

Tot slot zijn in deze meting vragen gesteld over de mate van controle die de overheid zou kunnen krijgen, en de mate van macht die technologische bedrijven (zoals Google en Apple) zouden kunnen krijgen door de CoronaMelder. Hierbij geeft 4 op de 10 van de gebruikers (`r round((nrow(filter(data, (user_status == 'Gebruiker'& Beliefs_surveillancestate1_agree == 'Totaal waar'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`%) aan dat de CoronaMelder volgens hen zorgt voor meer controle vanuit de overheid, terwijl bijna 6 op de 10 van de niet gebruikers (`r round((nrow(filter(data, (user_status == 'Niet gebruiker' & Beliefs_surveillancestate1_agree == 'Totaal waar'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%) dit denkt. Van de gebruikers denkt een kwart (`r round((nrow(filter(data, (user_status_intention == 'Gebruiker'& Beliefs_surveillancestate2_agree == 'Totaal waar'))) /nrow(filter(data, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) en van de niet gebruikers de helft (`r round((nrow(filter(data, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_surveillancestate2_agree == 'Totaal waar'))) /nrow(filter(data, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%) dat het gebruiken van de CoronaMelder zorgt dat technologische bedrijven meer macht krijgen. Voor beide stellingen ligt het percentage van de niet gebruikers dat het hiermee eens is aanzienlijk hoger dan het percentage gebruikers. Dit duidt erop dat zorgen over de mogelijke gevolgen voor de (machts)positie van de overheid en technologische bedrijven meespeelt in de keuze om de CoronaMelder wel of niet te gebruiken. 

## Maatschappelijke gevolgen
Iets meer dan een kwart van de respondenten (`r round((nrow(filter(data, (Beliefs_benefiteconomic == 'Helemaal mee eens'| Beliefs_benefiteconomic == 'Mee eens'| Beliefs_benefiteconomic == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) heeft de overtuiging dat de CoronaMelder de Nederlandse economie zal helpen. Ook hier was een groot verschil zichtbaar tussen huidige gebruikers (`r round((nrow(filter(data, (user_status == 'Gebruiker'& Beliefs_benefiteconomic_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`%% eens) en niet gebruikers (`r round((nrow(filter(data, (user_status == 'Niet gebruiker' & Beliefs_benefiteconomic_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`% eens). De mogelijk positieve bijdrage aan het herstellen van de economie werd ook in de literatuur genoemd als reden om een contact tracing app te gaan gebruiken (Rheault & Musulan, 2020). Het is hierbij wel raadzaam om ervoor te waken dat er geen beloftes gemaakt worden die de CoronaMelder niet kan waarmaken, zoals dat de app alleen (zonder aanvullende maatregelen) ervoor zou kunnen zorgen dat de economie zich zal kunnen herstellen. De eerdere (tussen de eerste en tweede meting) lichte daling in de hoeveelheid respondenten die het met deze stelling eens was kan wellicht verklaard worden door de duur van de crisis, wat met zich meebrengt dat veel midden-en-kleinbedrijven op financieel vlak de gevolgen van deze crisis zullen merken. Men heeft zodoende niet (meer) het vertrouwen dat de CoronaMelder een oplossing is voor dit inmiddels grote probleem. 

## Gebruiksvriendelijkheid en zelfeffectiviteit
Factoren die in het verklarend model een significante samenhang met gebruik lieten zien zijn de inspanningsverwachting, ook wel de gebruiksvriendelijkheid, en de zelfeffectiviteit, de mate waarin men denkt in staat te zijn de CoronaMelder te gebruiken. 
Opvallend is dat een aanzienlijk deel van de mensen die de CoronaMelder nog niet gebruikt (`r round((nrow(filter(data, (EE1b_UTAUT == 'Helemaal mee eens'| EE1b_UTAUT == 'Mee eens'| EE1b_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`%), denkt dat het veel tijd en energie kost om deze te gaan gebruiken en een groot deel (`r round((nrow(filter(data, (EE1b_UTAUT == 'Neutraal') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`%) hier neutraal in staat. Daar staat tegenover dat van de mensen die de CoronaMelder al gebruiken, slechts `r round((nrow(filter(data, (EE1a_UTAUT == 'Helemaal mee eens'| EE1a_UTAUT == 'Mee eens'| EE1a_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`% aangaf dat dit inderdaad het geval was. De app blijkt dus in de praktijk makkelijker te installeren en gebruiken dan men in eerste instantie verwacht. Op het gebied van de (verwachte) gebruiksvriendelijkheid zien we een soortgelijk verschil tussen gebruikers (`r round((nrow(filter(data, (EE2a_UTAUT == 'Helemaal mee eens'| EE2a_UTAUT == 'Mee eens'| EE2a_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`%%) en niet gebruikers (`r round((nrow(filter(data, (EE2b_UTAUT == 'Helemaal mee eens'| EE2b_UTAUT == 'Mee eens'| EE2b_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`%) die de CoronaMelder als (verwacht) gebruiksvriendelijk beoordelen. Ook is te zien dat gebruikers (`r round((nrow(filter(data, (user_status == 'Gebruiker')&(HBM_selfefficacy_CoronaMelder == 'Helemaal mee eens'| HBM_selfefficacy_CoronaMelder == 'Mee eens'| HBM_selfefficacy_CoronaMelder == 'Een beetje mee eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`%) zich vaker in staat achten om de CoronaMelder te gebruiken dan niet gebruikers (`r round((nrow(filter(data, (user_status == 'Niet gebruiker')&(HBM_selfefficacy_CoronaMelder == 'Helemaal mee eens'| HBM_selfefficacy_CoronaMelder == 'Mee eens'| HBM_selfefficacy_CoronaMelder == 'Een beetje mee eens'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%). 

Ook eerder onderzoek wijst uit dat als men het gevoel heeft dat men weet hoe de app te gebruiken (een hoge zelfeffectiviteit), de adoptie intenties groter zijn (Walrave et al., 2020). Bij de niet gebruikers kan dit dus een drempel zijn voor installeren. In de communicatie naar de niet gebruikers is het daarom goed om in te spelen op de zelfeffectiviteit en het gemak waarmee de CoronaMelder geïnstalleerd en gebruikt kan worden.

## Technologie gerelateerde belemmeringen
Van de respondenten die de CoronaMelder nog niet gebruikten, gaven bijna 7 op de 10 (`r round((nrow(filter(data, (user_status == 'Niet gebruiker' & FC1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%) aan dat zij beschikken over een smartphone met internet waarmee de CoronaMelder te gebruiken is. Daarentegen gaf (`r round((nrow(filter(data, (user_status == 'Niet gebruiker' & (FC1_UTAUT == 'Een beetje oneens'| FC1_UTAUT == 'Oneens'| FC1_UTAUT == 'Helemaal mee oneens')))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%) aan het hiermee niet eens te zijn en de rest antwoorde neutraal. 

terwijl de rest het hier mee oneens was of hier neutraal op antwoorde. Dit is niet met alleen communicatie op te lossen aangezien de mensen het het oneens zijn met deze stelling mogelijkerwijs niet over de middelen beschikken om de app te kunnen installeren en gebruiken. Ook in onze literatuurstudie kwam een gebrek aan geschikte apparatuur voor als reden om de app niet te kunnen installeren (Horstmann et al., 2020; von Wyl et al., 2020). In Singapore is dit opgelost door een token te ontwikkelen, een op zichzelf staand apparaat wat dezelfde functionaliteiten biedt als de contact tracing app, maar dan zonder een smartphone nodig te hebben. Dit zou ook zorgen omtrent privacy kunnen wegnemen, zeker als deze zorgen gaan over het gebruik van een persoonlijke smartphone voor contact tracing. Het nadeel van deze oplossing is echter dat er (in ieder geval in Singapore) geen gebruik wordt gemaakt van het door Apple en Google ontwikkelde platform (waar de CoronaMelder wel op gebaseerd is), en hiermee zou ook bijvoorbeeld internationale contact tracing in de toekomst lastig kunnen worden bij gebrek aan een gezamenlijk protocol.

Daarnaast gaf slechts 6 op de 10 (`r round((nrow(filter(data, (user_status == 'Niet gebruiker' & FC2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%) niet gebruikers aan het eens te zijn met de stelling dat zij genoeg technische kennis hebben om de CoronaMelder te installeren. Ook dit kwam terug in een andere studie (Blom et al., 2020), en zowel het gebrek aan de juiste middelen als aan de benodigde kennis blijkt vaker voor te komen bij mensen die tot de risicogroepen behoren, bijvoorbeeld ouderen (Blom et al., 2020). Dit zou wel verholpen kunnen worden door mensen hulp te bieden bij het installeren van de app, ze te wijzen op de beschikbare manieren om deze hulp te verkrijgen, of om een beroep te doen op naasten om elkaar te helpen bij het installeren, en bijvoorbeeld tweedehands (maar voldoende recente) smartphones te doneren.

## Persoonlijke voor- en nadelen van gebruik
Nog twee factoren die in de verklarende modellen voor adoptie een significante samenhang met gebruik hadden waren de gepercipieerde voor- en nadelen van gebruik. Over het algemeen ligt het percentage respondenten dat voordelen (`r round((nrow(filter(data, (HBM_perceivedbenefits_CoronaMelder == 'Helemaal mee eens'| HBM_perceivedbenefits_CoronaMelder == 'Mee eens'| HBM_perceivedbenefits_CoronaMelder == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) en nadelen (`r round((nrow(filter(data, (HBM_barriers_CoronaMelder == 'Helemaal mee eens'| HBM_barriers_CoronaMelder == 'Mee eens'| HBM_barriers_CoronaMelder == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) van het gebruik ziet relatief laag. Hier zit een substantieel verschil tussen de gebruikers (voordelen: `r round((nrow(filter(data, (user_status == 'Gebruiker'& HBM_perceivedbenefits_CoronaMelder_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`% eens; nadelen: `r round((nrow(filter(data, (user_status == 'Gebruiker'& HBM_barriers_CoronaMelder_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`% eens) en niet gebruikers (voordelen: `r round((nrow(filter(data, (user_status == 'Niet gebruiker' & HBM_perceivedbenefits_CoronaMelder_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`% eens; nadelen: `r round((nrow(filter(data, (user_status == 'Niet gebruiker' & HBM_barriers_CoronaMelder_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`% eens). Er is over de vier metingen een zeer lichte daling in de persoonlijke voordelen te zien (met name tussen de eerste en tweede meting).  

Voor deze variabelen zijn er twee mogelijke aanpakken mogelijk. Aan de ene kant is een optie om de perceptie van de voor-en nadelen te beïnvloeden via communicatiecampagnes. Aan de andere kant is het een optie om daadwerkelijk wijzigingen aan de app maken waardoor deze meer en grotere voordelen voor de gebruiker heeft.  

In eerder onderzoek werden verscheidene (directe of indirecte) gepercipieerde persoonlijke voordelen geïdentificeerd. Hieronder valt bijvoorbeeld het veilig houden van jezelf en anderen, de kans op risicovol gedrag verminderen, de economie herstellen, en de potentiële versoepeling van andere maatregelen wanneer het reproductiecijfer daalt (Biddle et al., 2020; Rheault & Musulan, 2020). Ook kan men verschillende nadelen aan het gebruik van de CoronaMelder verbinden, zoals de hierna genoemde zorgen over privacy, de maatschappelijke en ethische gevolgen op langere termijn, of angst.


## Verplichting tot gebruik
Het gevoel van verplichting om de CoronaMelder te moeten gebruiken is een belangrijk punt in de evaluatie. In de huidige meting wordt door `r round((nrow(filter(data, (user_status == 'Gebruiker'& Beliefs_voluntariness_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`% van de huidig gebruikers aangegeven dat zij het gebruik in meer of mindere mate als verplichting ervoeren terwijl dit bij `r round((nrow(filter(data, (user_status == 'Niet gebruiker' & Beliefs_voluntariness_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`% van de niet gebruikers zo is. Over de hele populatie is het gevoel van verplichting is wel afgenomen. In de eerste meting begin november, 1.5 week na de lancering van de CoronaMelder was dit 26.1% terwijl dit in de huidige meting nog `r round((nrow(filter(data, (Beliefs_voluntariness == 'Helemaal mee eens'| Beliefs_voluntariness == 'Mee eens'| Beliefs_voluntariness == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% was.    

Er is verder doorgevraagd om te onderzoeken wat de aard is van deze gevoelens van verplichting en waar deze gevoelens van verplichting vandaan komen. Er zijn maar weinig gebruikers zijn die het eens waren met de stelling dat zij zich niet vrij voelen om te kiezen of ze de app gebruiken (`r round((nrow(filter(data, (user_status == 'Gebruiker'& Beliefs_voluntariness2_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`%). Daarnaast waren de gebruikers het ook minder vaak eens met de stellingen dat het hen irriteert (`r round((nrow(filter(data, (user_status == 'Gebruiker'& Beliefs_AffectIrritation_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`%) of boos maakt (`r round((nrow(filter(data, (user_status == 'Gebruiker'& Beliefs_AffectAnger_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat er wordt aangedrongen op het gebruiken van de CoronaMelder, vergeleken met de niet gebruikers (`r round((nrow(filter(data, (user_status == 'Niet gebruiker' & Beliefs_AffectIrritation_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`% irritatie, `r round((nrow(filter(data, (user_status == 'Niet gebruiker' & Beliefs_AffectAnger_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`% boos). Het lijkt er dus op dat gebruikers ofwel niet het gevoel hebben dat op gebruik wordt aangedrongen, of zij ervaren dit aandringen niet als irritant.

Een mogelijke verklaring voor gevoelens van verplichting is dat het gebruiken van de CoronaMelder voelt als een maatschappelijke verplichting. Aan degenen die aangaven het eens te zijn dat men zich verplicht voelt om de CoronaMelder te gebruiken gaf `r round((nrow(filter(data, (Beliefs_voluntariness_civic == 'Helemaal mee eens'| Beliefs_voluntariness_civic == 'Mee eens'| Beliefs_voluntariness_civic == 'Een beetje mee eens'))) /nrow(filter(data, (Beliefs_voluntariness == "Een beetje mee eens"| Beliefs_voluntariness == "Mee eens"| Beliefs_voluntariness == "Helemaal mee eens"))))*100, digits = 1)`% aan dat het gebruiken van de CoronaMelder wordt gezien als een maatschappelijke verplichting. Verder geeft in totaal `r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_civicduty_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`% van de gebruikers aan dat het gebruiken van de CoronaMelder je een goed burger maakt, en `r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_Protectriskgroups_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`% van de gebruikers is het eens met de stelling dat de CoronaMelder helpt om mensen met een kwetsbare gezondheid te beschermen. Daarnaast verwacht ongeveer de helft van de gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_benefiteconomic_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat het gebruiken van de CoronaMelder de Nederlandse economie helpt. Dit zijn tevens allemaal stellingen (goed burger, mensen met kwetsbare gezondheid beschermen, economie helpen) waar de niet gebruikers het in veel mindere mate mee eens waren dan de gebruikers, dus er lijkt een overkoepelend maatschappelijk belang te zijn wat waarschijnlijk bij de gebruikers een grote rol heeft gespeeld bij het besluit om de CoronaMelder te gaan gebruiken.

Aan degenen die aangaven het eens te zjn dat men zich verplicht voelt om de CoronaMelder te gebruiken is ook gevraagd vanuit welke bron deze verplichting gevoeld werd. Een relatief laag percentage (in ieder geval vergeleken met de `r round((nrow(filter(data, (Beliefs_voluntariness_civic == 'Helemaal mee eens'| Beliefs_voluntariness_civic == 'Mee eens'| Beliefs_voluntariness_civic == 'Een beetje mee eens'))) /nrow(filter(data, (Beliefs_voluntariness == "Een beetje mee eens"| Beliefs_voluntariness == "Mee eens"| Beliefs_voluntariness == "Helemaal mee eens"))))*100, digits = 1)`% die het ziet als maatschappelijke verplichting) geeft aan het in meer of mindere mate eens te zijn dat de werkgever/opdrachtgever (`r round((nrow(filter(data, (Beliefs_voluntariness_employer == 'Helemaal mee eens'| Beliefs_voluntariness_employer == 'Mee eens'| Beliefs_voluntariness_employer == 'Een beetje mee eens'))) /nrow(filter(data, (Beliefs_voluntariness_employer == "Een beetje mee eens"| Beliefs_voluntariness_employer == "Mee eens"| Beliefs_voluntariness_employer == "Helemaal mee eens" | Beliefs_voluntariness_employer == "Neutraal" | Beliefs_voluntariness_employer == "Een beetje oneens" | Beliefs_voluntariness_employer == "Oneens"| Beliefs_voluntariness_employer == "Helemaal mee oneens"))))*100, digits = 1)`%), de school/opleiding (`r round((nrow(filter(data, (Beliefs_voluntariness_school == 'Helemaal mee eens'| Beliefs_voluntariness_school == 'Mee eens'| Beliefs_voluntariness_school == 'Een beetje mee eens'))) /nrow(filter(data, (Beliefs_voluntariness_school == "Een beetje mee eens"| Beliefs_voluntariness_school == "Mee eens"| Beliefs_voluntariness_school == "Helemaal mee eens" | Beliefs_voluntariness_school == "Neutraal" | Beliefs_voluntariness_school == "Een beetje oneens" | Beliefs_voluntariness_school == "Oneens"| Beliefs_voluntariness_school == "Helemaal mee oneens"))))*100, digits = 1)`%) of de overheid (`r round((nrow(filter(data, (Beliefs_voluntariness_government == 'Helemaal mee eens'| Beliefs_voluntariness_government == 'Mee eens'| Beliefs_voluntariness_government == 'Een beetje mee eens'))) /nrow(filter(data, (Beliefs_voluntariness_government == "Een beetje mee eens"| Beliefs_voluntariness_government == "Mee eens"| Beliefs_voluntariness_government == "Helemaal mee eens" | Beliefs_voluntariness_government == "Neutraal" | Beliefs_voluntariness_government == "Een beetje oneens" | Beliefs_voluntariness_government == "Oneens"| Beliefs_voluntariness_government == "Helemaal mee oneens"))))*100, digits = 1)`%) de respondent verplicht om de CoronaMelder te gebruiken.

## Affectieve reacties
De niet gebruikers staan angstiger (`r round((nrow(filter(data, (user_status == 'Niet gebruiker' & Beliefs_fear_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%% eens) tegenover de CoronaMelder dan de gebruikers (`r round((nrow(filter(data, (user_status == 'Gebruiker'& Beliefs_fear_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`% eens). Angst zou dus een barrière kunnen zijn voor gebruik. Deze factor was ook een van de variabelen die significant samenhing met gebruik in de verklarende modellen. Het is mogelijk dat deze angst gerelateerd is aan de onjuiste opvattingen over de CoronaMelder en met name ook het coronavirus, zoals dat het virus een biologisch wapen is. Bij de groep niet gebruikers zal de angst omtrent de CoronaMelder mogelijk kunnen worden weggenomen om adoptie intenties te bevorderen. Deze angst staat waarschijnlijk los van de angst voor het coronavirus: angst voor een corona uitbraak, en angst om het coronavirus zelf te krijgen, hing volgens een eerdere studie juist positief samen met app adoptie (Jansen-Kosterink et al., 2020). 

De afname in angst die de afgelopen metingen te zien was lijkt gestabiliseerd: er is geen verschil tussen de huidige (vierde) en de vorige (derde) meting.  

## Sociale invloeden
Een factor die in de verklarende modellen voor gebruik een significante samenhang met gebruik had was de sociale invloed. 

Net als bij de vorige metingen, denken de meeste respondenten dat 26%-50% van de bevolking de CoronaMelder gebruikt, namelijk `r round((nrow(filter(data, (Beliefs_AppAdoption == '26-50%'))) /nrow(data))*100, digits = 1)`% tijdens de huidige meting. Echter staat dit in contrast met de mate waarin men denkt dat mensen in hun eigen direct omgeving de CoronaMelder gebruiken. Net als in de vorige meting zijn zeer weinig mensen het eens met de stelling dat veel mensen in de directe omgeving de CoronaMelder gebruiken (`r round((nrow(filter(data, (SI1_UTAUT == 'Helemaal mee eens'| SI1_UTAUT == 'Mee eens'| SI1_UTAUT == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Op deze stelling heeft ook ongeveer `r round((nrow(filter(data, (SI1_UTAUT == 'Neutraal'))) /nrow(data))*100, digits = 1)`% ‘neutraal’ geantwoord, wat zou kunnen samenhangen met het feit dat men het niet van anderen weet. Het gebruik van de CoronaMelder is relatief onzichtbaar vergeleken met bijvoorbeeld de mondkapjes maatregel, wat ervoor zorgt dat men alleen van het gebruik van anderen te weten komt door erover te praten. Als daar geen aanleiding voor is (bijvoorbeeld aandacht in de media of het ontvangen van een melding) is het niet waarschijnlijk dat men er over praat. Dit leidt ertoe dat mensen zich denken te bevinden in een sociale groep waarin niet veel anderen de CoronaMelder gebruiken, terwijl dit niet de realiteit hoeft te zijn. Ook de eigen inschatting van hoe belangrijk anderen in hun directe omgeving het vinden dat de respondent de CoronaMelder gebruikt, is weinig positief (`r round((nrow(filter(data, (SI2_UTAUT == 'Helemaal mee eens'| SI2_UTAUT == 'Mee eens'| SI2_UTAUT == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% eens), met ook hier een groot aantal ‘neutraal’ antwoorden (`r round((nrow(filter(data, (SI2_UTAUT == 'Neutraal'))) /nrow(data))*100, digits = 1)`%). Opvallend is verder dat de antwoorden op deze stellingen  over de tijd stabiel laag zijn. Belangrijk om ook bij deze factoren in de gaten te houden is het grote verschil tussen gebruikers (descriptieve norm: `r round((nrow(filter(data, (user_status == 'Gebruiker'& SI1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`% eens; injunctieve norm: `r round((nrow(filter(data, (user_status == 'Gebruiker'& SI2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`% eens) en niet gebruikers (descriptieve norm: `r round((nrow(filter(data, (user_status == 'Niet gebruiker' & SI1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`% eens; injunctieve norm: `r round((nrow(filter(data, (user_status == 'Niet gebruiker' & SI2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`% eens), waardoor deze invloeden dus sterk samenhangen met gebruik en er mogelijk ruimte voor verbetering is. 

Communicatiestrategieën zouden kunnen inzetten op het verbeteren van de sociale norm. Studies naar de CoronaMelder vonden dat descriptieve normen een rol spelen bij adoptie intentie. Als men het idee heeft dat in de persoonlijke omgeving de CoronaMelder wordt geïnstalleerd, is men geneigd dit zelf ook te doen (Proszowska et al., 2020; Strycharz et al., 2020). Omgekeerd heeft onderzoek ook uitgewezen dat een barrière van adoptie is dat men niet gelooft dat anderen de app zullen installeren (Proszowska et al., 2020; Zhang et al., 2020). Het verbeteren van de zowel de descriptieve, als de injunctieve norm (dat mensen in de directe omgeving het gebruik van de CoronaMelder op prijs stellen), verdienen aandacht.

## Vertrouwen in de overheid

Een belangrijk verschil tussen huidige gebruikers van de CoronaMelder en de respondenten die de app nog nooit gebruikt hadden is het vertrouwen in de aanpak van de overheid om het coronavirus onder controle te houden. Terwijl `r round((nrow(filter(data, (user_status == 'Gebruiker'& Beliefs_TrustGovernment_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`% van de gebruikers aangaf dit vertrouwen te hebben, had slechts `r round((nrow(filter(data, (user_status == 'Niet gebruiker' & Beliefs_TrustGovernment_agree == 'Totaal eens'))) /nrow(filter(data, (user_status == 'Niet gebruiker'))))*100, digits = 1)`% van de niet gebruikers dit. Ook uit de literatuurstudie bleek dat vertrouwen in de overheid (in algemene zin) een voorspeller is van de intentie om de CoronaMelder te gaan gebruiken (Proszowska et al., 2020; Strycharz et al., 2020). Dit zou te maken kunnen hebben met de zorgen omtrent privacy, die af kunnen nemen wanneer het vertrouwen in de overheid groter is (Biddle et al., 2020). Overigens blijkt dit vertrouwen in de overheid op dit moment relatief laag te zijn voor veel West-Europese landen (Altmann et al., 2020). Het zou dus kunnen helpen om te werken aan dit vertrouwen van de Nederlandse bevolking in de manier waarop de overheid met het coronavirus omgaat. Het is echter niet gemakkelijk om dit te doen, aangezien er zoveel nog niet bekend is over het virus en de effectiviteit van de verschillende maatregelen.

## Zijn gebruikers in het algemeen meer adherent aan de corona gedragsregels?
Uit literatuuronderzoek bleek dat gedrag ten aanzien van de overige maatregelen tegen het coronavirus ook een voorspeller van (intentie tot) adoptie van een contact tracing app is (von Wyl et al., 2020; Kaspar, 2020). We zien, net als bij de eerste meting, dat gebruikers van de CoronaMelder ook de intentie vertonen om zich vaker dan niet gebruikers aan maatregelen te houden zoals handen wassen, afstand houden, drukke plekken vermijden en thuis blijven bij klachten. Deze verschillen zijn echter niet heel groot, en over het algemeen vertoont een groot deel van de respondenten de intentie om zich aan de maatregelen te houden, hoewel dit aantal wel enigszins gedaald is ten opzichte van de vorige meting. Er waren vrijwel geen verschillen in zelfgerapporteerde adherentie aan de andere maatregelen tussen gebruikers en niet gebruikers: in deze meting verschilde alleen het percentage dat hoogfrequent de handen waste tussen gebruikers en niet gebruikers.  

## Beoogde effecten
###  Opvolging adviezen gegeven in een melding van de CoronaMelder 
Slechts een klein aantal respondenten (n = `r nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer') & (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))`) die de CoronaMelder gebruikt hadden of op dit moment gebruikten, had daadwerkelijk ooit een melding vanuit de app ontvangen. Dit moet men bij onderstaande bevindingen voor gerapporteerd gedrag in aanmerking nemen. 

Van de respondenten die ooit een melding van de CoronaMelder hebben ontvangen gaf `r round(nrow(filter(data, (Notification_behavior_test == 'Ja')))/nrow(filter(data, (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))*100, digits = 1)`% aan een coronatest te hebben aangevraagd na de melding. Daarnaast gaf `r round(nrow(filter(data, (Notification_behavior_quarantaine == 'Vaak' | Notification_behavior_quarantaine == 'Meestal' | Notification_behavior_quarantaine == 'Altijd')))/nrow(filter(data, (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))*100, digits = 1)`% aan dat hij of zij vaak, meestal of altijd zo lang thuis is gebleven als de melding adviseert. Hoewel het aantal waarnemingen laag was, zijn ze wel in lijn met ander recent onderzoek (met een hoger aantal waarnemingen) naar de opvolging van de adviezen gegeven in de melding (Ebbers et al., 2021). Tezamen suggereert dit wel dat er een flinke discrepantie tussen het gedrag en de intenties is. Het huidig onderzoek laat namelijk zien dat bij gebruikers van de CoronaMelder de intenties om de adviezen op te volgen hoog zijn. 

#### Intenties om adviezen uit de app op te volgen bij gebruikers wanneer men (hypothetisch) geen symptomen heeft
Het blijkt dat men de juiste intenties heeft wat betreft het opvolgen van geadviseerd gedrag. Zo geeft de ruime meerderheid van de gebruikers die (hypothetisch) een waarschuwing van de CoronaMelder ontvangt en géén symptomen heeft aan thuis te blijven (`r round((nrow(filter(data, (user_status == 'Gebruiker')&(AdherenceNotificationMeasuresNosymptoms_Quarantaine == 'Helemaal mee eens'| AdherenceNotificationMeasuresNosymptoms_Quarantaine == 'Mee eens'| AdherenceNotificationMeasuresNosymptoms_Quarantaine == 'Een beetje mee eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`%), geen bezoek te ontvangen (`r round((nrow(filter(data, (user_status == 'Gebruiker')&(AdherenceNotificationMeasuresNoSymptoms_Visits == 'Helemaal mee eens'| AdherenceNotificationMeasuresNoSymptoms_Visits == 'Mee eens'| AdherenceNotificationMeasuresNoSymptoms_Visits == 'Een beetje mee eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`%), of een coronatest laten doen (`r round((nrow(filter(data, (user_status == 'Gebruiker')&(AdherenceNotificationMeasuresNosymptoms_Test == 'Helemaal mee eens'| AdherenceNotificationMeasuresNosymptoms_Test == 'Mee eens'| AdherenceNotificationMeasuresNosymptoms_Test == 'Een beetje mee eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`%). Het percentage respondenten dat zonder symptomen toch een test zou laten doen is (nogmaals) aanzienlijk gestegen. Dit zou nog steeds een gevolg van het veranderde testbeleid sinds 1 december kunnen zijn, waarbij het mogelijk gemaakt werd om ook zonder symptomen een test te doen. Mogelijk raken steeds meer gebruikers op de hoogte van deze beleidsverandering. Toch is het percentage nog steeds lager dan als men hypothetisch wel symptomen heeft. Hier kan dus verder op ingezet worden. 
 
De mate waarin gebruikers de intentie hebben om de overige adviezen op te volgen wanneer men geen symptomen heeft, zijn niet veranderd over de tijd. Opvallend is daarbij dat, net als bij de vorige meting, nog steeds een aanzienlijk deel (`r round((nrow(filter(data, (user_status == 'Gebruiker')&(AdherenceNotificationMeasuresNosymptoms_CallGP == 'Helemaal mee eens'| AdherenceNotificationMeasuresNosymptoms_CallGP == 'Mee eens'| AdherenceNotificationMeasuresNosymptoms_CallGP == 'Een beetje mee eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`%) van de gebruikers de huisarts zou bellen. Dit zou te maken kunnen hebben met dat men mogelijk huiverig is voor de consequenties van het coronavirus, en graag extra (specialistische) hulp inschakelt. Het is raadzaam om vanuit de GGD nadrukkelijk te communiceren dat het niet de bedoeling is om de huisarts te bellen bij geen of milde klachten, om zo de druk op de huisartsen te verminderen.
 
#### Intenties om adviezen uit de app op te volgen bij gebruikers wanneer men (hypothetisch) wel symptomen heeft
Wanneer gebruikers (hypothetisch) wel symptomen hebben, zou `r round((nrow(filter(data, (user_status == 'Gebruiker')&(AdherenceNotificationMeasuresSymptoms_Test == 'Helemaal mee eens'| AdherenceNotificationMeasuresSymptoms_Test == 'Mee eens'| AdherenceNotificationMeasuresSymptoms_Test == 'Een beetje mee eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`% bellen voor een coronatest, zou ook `r round((nrow(filter(data, (user_status == 'Gebruiker')&(AdherenceNotificationMeasuresSymptoms_Quarantaine == 'Helemaal mee eens'| AdherenceNotificationMeasuresSymptoms_Quarantaine == 'Mee eens'| AdherenceNotificationMeasuresSymptoms_Quarantaine == 'Een beetje mee eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`% thuis blijven zolang de melding adviseert, en zou `r round((nrow(filter(data, (user_status == 'Gebruiker')&(AdherenceNotificationMeasuresSymptoms_Visits == 'Helemaal mee eens'| AdherenceNotificationMeasuresSymptoms_Visits == 'Mee eens'| AdherenceNotificationMeasuresSymptoms_Visits == 'Een beetje mee eens'))) /nrow(filter(data, (user_status == 'Gebruiker'))))*100, digits = 1)`% geen bezoek ontvangen. De gebruikers lijken dus de juiste intentie te hebben wat betreft de opvolging van de adviezen uit de app. Deze intenties zijn stabiel hoog over de tijd. 

In een eerdere studie uitgezet in de VS, Frankrijk, het Verenigd Koninkrijk en Italië, hadden 9 op de 10 respondenten de intenties om thuis te blijven als de melding dit adviseert (Altmann et al., 2020). In een ander onderzoek onder Duitse respondenten ligt dit percentage echter veel lager: slechts een derde zou in quarantaine gaan als de app dit adviseert (Blom et al., 2020). Er lijken dus verschillen op te treden tussen landen, maar wellicht is dit verschil ook te verklaren door het moment waarop de vraag gesteld is (d.w.z., aan het begin van de pandemie zoals bij Altmann et al. (2020), of na de eerste piek van besmettingen, zoals bij Blom et al. (2020).). Data van het RIVM wijzen inderdaad uit dat het draagvlak verandert bij verlenging van de maatregelen, maar ook bij een daling in het aantal besmettingen zoals in juni het geval was (RIVM, 2020). Gezien de stabiliteit van de intenties over de tijd lijkt dat hier niet het geval te zijn.   

#### Voor- en nadelen van opvolgen adviezen
Het verklarend model voor de intentie tot opvolging van de adviezen in geval van symptomen liet zien dat de zelfeffectiviteit een belangrijke verklarende factor is. De overgrote meerderheid rapporteert al een hoge zelfeffectiviteit: men acht zichzelf goed in staat om te bellen voor een test (`r round((nrow(filter(data, (HBM_selfefficacy_Test == 'Helemaal mee eens'| HBM_selfefficacy_Test == 'Mee eens'| HBM_selfefficacy_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), zo lang thuis te blijven als wordt geadviseerd (`r round((nrow(filter(data, (HBM_selfefficacy_Quarantaine == 'Helemaal mee eens'| HBM_selfefficacy_Quarantaine == 'Mee eens'| HBM_selfefficacy_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), geen bezoek te ontvangen (`r round((nrow(filter(data, (HBM_selfefficacy_Visits == 'Helemaal mee eens'| HBM_selfefficacy_Visits == 'Mee eens'| HBM_selfefficacy_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) en de huisarts te bellen (`r round((nrow(filter(data, (HBM_selfefficacy_GP == 'Helemaal mee eens'| HBM_selfefficacy_GP == 'Mee eens'| HBM_selfefficacy_GP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Er is hier dus relatief weinig ruimte voor verbetering.  

Andere redenen voor iemand om zich niet aan de adviezen te houden, en dus een verklaring voor de discrepantie tussen de (goede) intenties en het daadwerkelijk gedrag, zouden gerelateerd kunnen zijn aan de persoonlijke nadelen die men verwacht van het opvolgen van de adviezen. Daarnaast ziet lang niet iedereen de voordelen in van deze adviezen. Het percentage mensen dat het eens is met nadelige gevolgen is het grootst voor thuisblijven (`r round((nrow(filter(data, (HBM_barriers_Quarantaine == 'Helemaal mee eens'| HBM_barriers_Quarantaine == 'Mee eens'| HBM_barriers_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) en het niet kunnen ontvangen van bezoek (`r round((nrow(filter(data, (HBM_barriers_Visits == 'Helemaal mee eens'| HBM_barriers_Visits == 'Mee eens'| HBM_barriers_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Het bellen voor een test (`r round((nrow(filter(data, (HBM_barriers_Test == 'Helemaal mee eens'| HBM_barriers_Test == 'Mee eens'| HBM_barriers_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) of de huisarts bellen (`r round((nrow(filter(data, (HBM_barriers_GP == 'Helemaal mee eens'| HBM_barriers_GP == 'Mee eens'| HBM_barriers_GP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) wordt als minder nadelig gezien. Het blijkt dat ongeveer de helft van de respondenten persoonlijke voordelen inziet van de adviezen (bellen voor een test: `r round((nrow(filter(data, (HBM_perceivedbenefits_Test == 'Helemaal mee eens'| HBM_perceivedbenefits_Test == 'Mee eens'| HBM_perceivedbenefits_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; thuisblijven zolang geadviseerd is: `r round((nrow(filter(data, (HBM_perceivedbenefits_Quarantaine == 'Helemaal mee eens'| HBM_perceivedbenefits_Quarantaine == 'Mee eens'| HBM_perceivedbenefits_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; geen bezoek ontvangen: `r round((nrow(filter(data, (HBM_perceivedbenefits_Visits == 'Helemaal mee eens'| HBM_perceivedbenefits_Visits == 'Mee eens'| HBM_perceivedbenefits_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; de huisarts bellen: `r round((nrow(filter(data, (HBM_perceivedbenefits_GP == 'Helemaal mee eens'| HBM_perceivedbenefits_GP == 'Mee eens'| HBM_perceivedbenefits_GP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Eerder onderzoek toonde aan dat de gepercipieerde voordelen de belangrijkste voorspeller is van adoptie van een contact tracing app onder Nederlanders (Proszowska et al., 2020). Het is aannemelijk dat de gepercipieerde voordelen ook een belangrijke rol spelen bij de intentie tot de opvolging van adviezen. De gepercipieerde voor- en nadelen schommelen over de afgelopen metingen enigszins. Ten opzichte van de vorige meting zijn alleen de gepercipieerde voordelen van thuis blijven zeer licht gedaald. Het is aan te raden om op de communicatie op de persoonlijke voordelen te richten. --> NOG updaten nav. analyses Nadine.   

#### Verplichting tot opvolgen adviezen
Er is onderzocht in hoeverre respondenten zich verplicht voelen tot het opvolgen van de meldingen van de CoronaMelder, en in hoeverre dit leidt tot negatieve emoties zoals boosheid en irritatie. Ruim 3 op de 4 respondenten (`r round((nrow(filter(data, (AdherenceNotification_voluntariness1 == 'Helemaal mee eens'| AdherenceNotification_voluntariness1 == 'Mee eens'| AdherenceNotification_voluntariness1 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) voelt zich verplicht om een melding op te volgen en ongeveer een kwart (`r round((nrow(filter(data, (AdherenceNotification_voluntariness2 == 'Helemaal mee eens'| AdherenceNotification_voluntariness2 == 'Mee eens'| AdherenceNotification_voluntariness2 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) vindt dat het advies hun vrijheid bedreigt om zelf te bepalen wat ze doen. Het advies gegeven in de melding roept echter slechts bij een laag percentage irritaties (`r round((nrow(filter(data, (AdherenceNotification_AffectIrritation == 'Helemaal mee eens'| AdherenceNotification_AffectIrritation == 'Mee eens'| AdherenceNotification_AffectIrritation == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) of boosheid (`r round((nrow(filter(data, (AdherenceNotification_AffectAnger == 'Helemaal mee eens'| AdherenceNotification_AffectAnger == 'Mee eens'| AdherenceNotification_AffectAnger == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) op.

###  Intenties om de GGD-sleutel door te geven
De huidige studie biedt inzicht in de intentie van respondenten om de GGD-sleutel door te geven bij een positieve test. Een eerdere studie wees uit dat 38% welwillend was om het testresultaat door te geven wanneer deze positief is (Blom et al., 2020). In de huidige studie ligt dit percentage hoger (`r round((nrow(filter(data, (Intention_reportinfection == 'Helemaal mee eens'| Intention_reportinfection == 'Mee eens'| Intention_reportinfection == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% voor de hele sample, `r round((nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')&(Intention_reportinfection == 'Helemaal mee eens'| Intention_reportinfection == 'Mee eens'| Intention_reportinfection == 'Een beetje mee eens'))) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`% bij alleen de gebruikers). De intenties tot het doorgeven van de GGD-sleutel zijn dus zoals beoogd is. Er moet hierbij rekening gehouden worden met het feit dat niet iedereen deze intentie om zal zetten tot daadwerkelijk gedrag. In de communicatie naar positief getesten zal het belang van de GGD-sleutel doorgeven moeten worden benadrukt. 

## Onbeoogde effecten: Schijnveiligheid  
Een gevoel van schijnveiligheid zou kunnen optreden bij de adoptie van de CoronaMelder, wat ervoor zou kunnen zorgen dat andere maatregelen minder nodig worden geacht. Bij diverse Coronamaatregelen, zoals de mondkapjes, is de zorg uitgesproken dat er wellicht schijnveiligheid op zou kunnen treden: door het gebruik van de CoronaMelder zou men kunnen denken dat het niet meer nodig is om andere belangrijke maatregelen, zoals het houden van 1.5 meter afstand, toe te blijven passen. In het algemeen is de theorie (risico compensatie theorie) die achter deze verwachting ligt echter al meerdere malen ontkracht (bv. Pless, 2016).

Uit de antwoorden op de stelling of men zich minder aan andere maatregelen kan houden bij het gebruik van de CoronaMelder, blijkt dat slechts een klein aandeel denkt dat dit het geval is. Het aandeel dat op deze vraag ‘zeker waar’ of ‘misschien waar’ antwoordt, is `r round((nrow(filter(data, (Beliefs_falsesecurity1 == 'Zeker waar'| Beliefs_falsesecurity1 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%. 
 
Daarnaast beoordeelden bijna drie op de tien (`r round((nrow(filter(data, (Beliefs_falsesecurity2 == 'Zeker waar'| Beliefs_falsesecurity2 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%) van de respondenten de stelling dat de CoronaMelder zorgt voor een verlaagd risico om besmet te worden als misschien of zeker waar, en geeft `r round((nrow(filter(data, (Beliefs_falsesecurity2 == 'Weet ik niet'))) /nrow(data))*100, digits = 1)`% aan dit niet te weten. Dit percentage zijn enigszins zorgelijk. Tegelijkertijd zijn er op dit moment geen aanwijzingen dat de gebruikers zich minder aan de algemene maatregelen houden. Zo verschillen gebruikers en niet gebruikers niet of nauwelijks in hun zelfgerapporteerde adherentie aan de algemene maatregelen; gebruikers geven juist marginaal vaker aan dat ze hun handen frequent wassen. Daarnaast hebben gebruikers juist vaker de intentie om zich aan de algemene maatregelen te houden dan niet gebruikers. Gezien deze bevindingen lijkt het niet waarschijnlijk dat risicocompensatie plaats vindt. Dit blijft wel een belangrijk punt van aandacht en het is te adviseren om duidelijk te communiceren dat het risico op besmetting met het coronavirus niet kleiner wordt door het gebruik van de CoronaMelder.
 
 
```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
``` 
 
# Referenties
Altmann, S., Milsom, L., Zillessen, H., Blasone, R., Gerdon, F., Bach, R., Kreuter, F., Nosenzo, D., Toussaert, S., &     Abeler, J. (2020). Acceptability of app-based contact tracing for COVID-19: Cross-country survey evidence (Preprint). JMIR MHealth and UHealth, 8(8), e19857. https://doi.org/10.2196/19857

Biddle, N., Edwards, B., Gray, M., Hiscox, M., McEachern, S., & Sollis, K. (2020). Data trust and data privacy in the COVID-19 period.

Blom, A. G., Wenz, A., Cornesse, C., Rettig, T., Fikel, M., Friedel, S., Juhl, S., Lehrer, R., Möhring, K., Naumann, E., Reifenscheid, M., & Krieger, U. (2020). Barriers to the Large-Scale Adoption of the COVID-19 Contact-Tracing App in Germany.

de Wit, J., van der Waal, N., & van der Laan, L. N. (2020). Een rapid review van de literatuur omtrent de adoptie en effectiviteit van contact tracing apps.

Ebbers, W. (2021). Wat volgt er na een melding van de coronamelder? Eindrapportage van de evaluatie van 'CoronaMelder-app meldingen van een kans op besmetting'. Erasmus University Rotterdam. 

Horstmann, K., Buecker, S., Krasko, J., & Kritzler, S. (2020). Who does or does not use the “Corona-Warn-App” and why? PsyArXiv. https://doi.org/10.31234/OSF.IO/E9FU3

Ipsos (2020). Complottheorieën over het coronavirus. Verkregen van https://www.ipsos.com/nl-nl/complottheorieen-over-het-coronavirus op 7 december 2020.

Jansen-Kosterink, S. M., Humuz, M., den Ouden, M., & Van Velsen, L. (2020). Predictors to use mobile apps for monitoring COVID-19 symptoms and contact tracing: A survey among Dutch citizens. MedRxiv.

Joo, J., & Shin, M. M. (2020). Resolving the tension between full utilization of contact tracing app services and user stress as an effort to control the COVID-19 pandemic. Service Business, 1–18.

Kaspar, K. (2020). Motivations for social distancing and app use as complementary measures to combat the COVID-19 pandemic: Quantitative survey study. Journal of Medical Internet Research, 22(8), e21613. https://doi.org/10.2196/21613

Kukuk, L. (2020). Analyzing adoption of contact tracing apps using UTAUT. University of Twente.

Pless, B. (2016). Risk compensation: Revisited and rebutted. Safety, 2(3), 16. https://doi.org/10.3390/safety2030016

Proszowska, D., Jansen, G., & De Vries, P. (2020). COVID-19 en de “intelligente lockdown" in de ogen van de burgers: Deel 3: Meningen over de corona-app. https://coronapapers.nl/uploads/media_item/media_item/146/86/Rapport-Lockdown-in-de-ogen-van-burgers-deel-3-Corona-app-1603965497.pdf

Rheault, L., & Musulan, A. (2020). Explaining Support for COVID-19 Cell Phone Contact Tracing.

RIVM (2020). Gedragswetenschappelijk onderzoek COVID-19. Verkregen van  https://www.rivm.nl/gedragsonderzoek/maatregelen-welbevinden/draagvlak op 7 december 2020.

Sheeran, P., & Webb, T. L. (2016). The intention--behavior gap. Social and Personality Psychology Compass, 10(9), 503–518.

Simko, L., Calo, R., Roesner, F., & Kohno, T. (2020). COVID-19 Contact Tracing and Privacy: Studying Opinion and Preferences. ArXiv Preprint ArXiv:2005.06056.

Strycharz, Bol, Buijzen, Helberger & de Vresse (2020). Preliminary Report: Technological Solutions in a Covid-19 Exit strategy. Societal conditions. Verkregen van https://www.uva-icds.net/wp-content/uploads/2020/10/Report_wave1.pdf op 8 december 2020.

Thorneloe, R., Epton, T., Fynn, W., Daly, M., Stanulewicz, N., Kassianos, A., Shorter, G., Moll, S.-J., Campbell, M., Sodergren, S. C., Chapman, S., Sutherland, L., Armitage, C., Arden, M., Chater, A., Byrne-Davis, L., & Hart, J. (2020). Scoping Review of Mobile Phone App Uptake and Engagement To Inform Digital Contact Tracing Tools for Covid-19. https://doi.org/10.31234/osf.io/qe9b6

Trang, S., Trenz, M., Weiger, W. H., Tarafdar, M., & Cheung, C. M. K. (2020). One app to trace them all? Examining app specifications for mass acceptance of contact-tracing apps. European Journal of Information Systems. https://doi.org/10.1080/0960085X.2020.1784046

von Wyl, V., Hoeglinger, M., Sieber, C., Kaufmann, M., Moser, A., Serra-Burriel, M., Ballouz, T., Menges, D., Frei, A., & Puhan, M. (2020). Are COVID-19 proximity tracing apps working under real-world conditions? Indicator development and assessment of drivers for app (non-) use. MedRxiv.

Walrave, M., Waeterloos, C., & Ponnet, K. (2020). Tracing the COVID-19 Virus: A Health Belief Model Approach to the Adoption of a Contact Tracing App. (Preprint). JMIR Public Health and Surveillance, 6, 1–10. https://doi.org/10.2196/20572

Wnuk, A., Oleksy, T., & Maison, D. (2020). The acceptance of Covid-19 tracking technologies: The role of perceived threat, lack of control, and ideological beliefs. PLOS ONE, 15(9), 1–16.

Zhang, B., Kreps, S., & McMurry, N. (2020). Americans’ perceptions of privacy and surveillance in the COVID-19 Pandemic. https://doi.org/10.31219/osf.io/9wz3y


```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```



# Appendix
## Additionele resultaten: Demografie naar gebruikersstatus - Paarsgewijze vergelijkingen
Vergelijking subgroepen met ruwe p-waarden en FDR-gecorrigeerde p-waarden. 
```{r , echo=FALSE}
### Determine all pairwise comparisons for the demgraphic variables the chi square indicated that the variable was not independent from user status. 
# Educational level (oplmet_simplified)
data_selected = data_currentvsneveruser
data_selected$oplmet_simplified = droplevels(data_selected$oplmet_simplified)
chisq.table = table(data_selected$oplmet_simplified, data_selected$user_status)
Matriz = chisq.table
pairwiseNominalIndependence(Matriz,
                            fisher = FALSE,
                            gtest  = FALSE,
                            chisq  = TRUE,
                            method = "fdr")
# Net income (nettocat_simplified)
data_selected = data_currentvsneveruser
data_selected$nettocat_simplified = droplevels(data_selected$nettocat_simplified)
chisq.table = table(data_selected$nettocat_simplified, data_selected$user_status)
Matriz = chisq.table
pairwiseNominalIndependence(Matriz,
                            fisher = FALSE,
                            gtest  = FALSE,
                            chisq  = TRUE,
                            method = "fdr")
```
```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```
 
## Tabellen predictie analyses 

```{r include = FALSE}
##### Load packages
# For importing SPSS files
library(foreign)
library(plyr)
library(car)
library(lavaan)
library(dplyr)
library(naniar)
library(semTools)# to calculate reliability
library(semPlot)
library(psy) # to calculate alpha
library(lmtest) # for logistic regression
library(aod)# for logistic regression
library(pscl)
library(ggplot2)
library(Hmisc)
library(psych) # factor analysis
library(GPArotation) # factor analysis
library(nFactors)
library(scales)
library(DescTools) # For pseudo r2

# For tables
library(flextable)
library(arsenal)
library(data.table)

# Load dataset of wave 4 and remove missing values
## Wave 4
data_wave4_in <- read.spss('L_Corona_app_wave4_3p.sav', to.data.frame=TRUE, use.missings=FALSE, use.value.labels=FALSE)
## Filter out the respondents that did not complete the entire survey 
data_wave4_filter <- data_wave4_in[!is.na(data_wave4_in$duur),]
```

```{r SelectingData, include = FALSE}
# Create a dataset with only the current users and never users for all analyses in which these groups are compared. 
data_wave4 <- subset(data_wave4_filter, Behavior_UTAUT != 2)

# We only want to analyse users for the adherence analyses
data_wave4_adherence <- subset(data_wave4_filter, Behavior_UTAUT == 1)

#View(data_wave4_adherence[,c("Behavior_UTAUT","AdherenceNotificationMeasuresSymptoms_Test","AdherenceNotificationMeasuresSymptoms_Quarantaine", "AdherenceNotificationMeasuresSymptoms_Visits")])

## Wave 4
data_wave4_adherenceS <- subset(data_wave4_adherence, AdherenceNotificationMeasuresSymptoms_Test != 8 & AdherenceNotificationMeasuresSymptoms_Quarantaine != 8 & AdherenceNotificationMeasuresSymptoms_Visits != 8 & AdherenceNotificationMeasuresSymptoms_CallGP != 8)

#View(data_wave4_adherenceS[,c("Behavior_UTAUT","AdherenceNotificationMeasuresSymptoms_Test","AdherenceNotificationMeasuresSymptoms_Quarantaine", "AdherenceNotificationMeasuresSymptoms_Visits", "AdherenceNotificationMeasuresSymptoms_CallGP")])

data_wave4_adherenceNS <- subset(data_wave4_adherence, AdherenceNotificationMeasuresNosymptoms_Test != 8 & AdherenceNotificationMeasuresNosymptoms_Quarantaine != 8 & AdherenceNotificationMeasuresNoSymptoms_Visits != 8 & AdherenceNotificationMeasuresNosymptoms_CallGP != 8)

#View(data_wave4_adherenceNS[,c("Behavior_UTAUT","AdherenceNotificationMeasuresNosymptoms_Test","AdherenceNotificationMeasuresNosymptoms_Quarantaine", "AdherenceNotificationMeasuresNoSymptoms_Visits")])

# Lookup table for variable names to map them into descriptions (for the table)
var_lookup <- data.frame(variable = c('PE_UTAUT', 'SI_UTAUT', 'FC_UTAUT', 'EE_UTAUT', 'lftdcat', 'geslacht', 'PSus_HBM', 'PSev_HBM', 'HBM_selfefficacy_CoronaMelder', 'HBM_barriers_CoronaMelder', 'HBM_perceivedbenefits_CoronaMelder', 'Adherence_Selfefficacy', 'Adherence_Benefits', 'Adherence_Barriers', 'Beliefs_voluntariness', 'Beliefs_fear', 'Beliefs_notificationfear', 'Beliefs_benefiteconomic', 'Beliefs_civicduty', 'Beliefs_TrustGovernment', 'Beliefs_Protectriskgroups', 'Beliefs_falsesecurityx', 'Beliefs_Conspiracyx', 'Beliefs_monitoringx', 'Beliefs_technologyperformance_dummy', 'Beliefs_fear_dummy', 'Beliefs_notificationfear_dummy', 'Beliefs_benefiteconomic_dummy', 'Beliefs_civicduty_dummy', 'Beliefs_TrustGovernment_dummy', 'Beliefs_Protectriskgroups_dummy', 'HBM_PSus_other2', 'HBM_PSev_other2', 'Media_dummy', 'Beliefs_society', 'Beliefs_fears', 'Beliefs_monitoring', 'Beliefs_conspiracy', 'Beliefs_technologyperformance_5p'), vardesc = c('Verwachte effectiviteit', 'Sociale invloeden', 'Faciliterende omstandigheden', 'Inspanningsverwachting', 'Leeftijd', 'Geslacht', 'Waargenomen vatbaarheid', 'Waargenomen ernst', 'Zelfeffectiviteit', 'Barrières voor gebruik', 'Persoonlijke voordelen van gebruik', 'Zelfeffectiviteit (opvolging)', 'Persoonlijke voordelen opvolging adviezen', 'Barrières (opvolging)', 'Verplichting tot gebruik', 'Angst voor CoronaMelder', 'Angst voor meldingen', 'Maatschappelijke gevolgen', 'Goede burger', 'Vertrouwen in de overheid', 'Risicogroepen beschermen', 'Schijnveiligheid', 'Complottheorieën', 'Surveillance', 'Adequaatheid techniek', 'Angst voor CoronaMelder', 'Angst voor meldingen', 'Maatschappelijke gevolgen', 'Goede burger', 'Vertrouwen in de overheid', 'Risicogroepen beschermen', 'Risico om anderen te besmetten', 'Ernst van anderen besmetten', 'Media', 'Maatschappelijk-gerelateerde overtuigingen', 'Angst-gerelateerde overtuigingen', 'Privacy-gerelateerde overtuigingen', 'Overtuigingen over complottheorieën', 'Adequaatheid techniek'))

```

```{r Preparation, include = FALSE}
#List of recodings that must be performed before runnng the analysis. Some variables need to be reverse coded.
data_wave4$Behavior_UTAUT_r = car::recode(data_wave4$Behavior_UTAUT, '1=1; 3=0')
#View(data_wave4[,c("Behavior_UTAUT_r","Behavior_UTAUT")])
data_wave4$EE1a_UTAUT_r = car::recode(data_wave4$EE1a_UTAUT, '1=7; 2=6; 3=5; 4=4; 5=3; 6=2; 7=1') #Higher values represent less effort expectancy (i.e., more ease of use)
data_wave4$EE1b_UTAUT_r = car::recode(data_wave4$EE1b_UTAUT, '1=7; 2=6; 3=5; 4=4; 5=3; 6=2; 7=1') #Higher values represent less effort expectancy (i.e., more ease of use)

# We need to merge effort expectancy for users and non-users, to ensure that we don't enter any missing cases in the model.
data_wave4$EE1_UTAUT <- rowMeans(data_wave4[, c("EE1a_UTAUT_r","EE1b_UTAUT_r")], na.rm = TRUE)
data_wave4$EE2_UTAUT <- rowMeans(data_wave4[, c("EE2a_UTAUT","EE2b_UTAUT")], na.rm = TRUE)

# Some variables need to be dummy-coded.
data_wave4$Beliefs_voluntariness_dummy <- car::recode(data_wave4$Beliefs_voluntariness, '1=0; 2=0; 3=0; 4=0; 5=1; 6=1; 7=1') #Higher values represent less voluntariness
#View(data_wave4[,c("Beliefs_voluntariness","Beliefs_voluntariness_dummy")])
data_wave4$Media_dummy <- car::recode(data_wave4$Media, '1=0; 2=1; 3=1; 4=1; 99=0')
#View(data_wave4[,c("Media","Media_dummy")])

#The variables measured from not true - true (5 point scales with 'I don't know as answer options) are recoded, so that 'I don't know' represents the middle value.
data_wave4$Beliefs_technologyperformance_5p <- car::recode(data_wave4$Beliefs_technologyperformance, '1=1; 2=2; 3=4; 4=5; 99=3') 
#View(data_wave4[,c("Beliefs_technologyperformance","Beliefs_technologyperformance_5p")])
data_wave4$Beliefs_datasafety_5p <- car::recode(data_wave4$Beliefs_datasafety, '1=1; 2=2; 3=4; 4=5; 99=3') 
#View(data_wave4[,c("Beliefs_datasafety","Beliefs_datasafety_5p")])
data_wave4$Beliefs_Conspiracy1_5p <- car::recode(data_wave4$Beliefs_Conspiracy1, '1=1; 2=2; 3=4; 4=5; 99=3') 
#View(data_wave4[,c("Conspiracy1","Conspiracy_5p")])
data_wave4$Beliefs_Conspiracy2_5p <- car::recode(data_wave4$Beliefs_Conspiracy2, '1=1; 2=2; 3=4; 4=5; 99=3') 
#View(data_wave4[,c("Conspiracy2","Conspiracy2_5p")])
data_wave4$Beliefs_locationmonitoring_5p <- car::recode(data_wave4$Beliefs_locationmonitoring, '1=1; 2=2; 3=4; 4=5; 99=3') 
#View(data_wave4[,c("locationmonitoring","locationmonitoring_5p")])
data_wave4$Beliefs_identitymonitoring_5p <- car::recode(data_wave4$Beliefs_identitymonitoring, '1=1; 2=2; 3=4; 4=5; 99=3')
#View(data_wave4[,c("Beliefs_identitymonitoring","Beliefs_identitymonitoring_5p")])
data_wave4$Beliefs_falsesecurity1_5p <- car::recode(data_wave4$Beliefs_falsesecurity1, '1=1; 2=2; 3=4; 4=5; 99=3') 
#View(data_wave4[,c("falsesecurity1","falsesecurity1_5p")])
data_wave4$Beliefs_falsesecurity2_5p <- car::recode(data_wave4$Beliefs_falsesecurity2, '1=1; 2=2; 3=4; 4=5; 99=3') 
#View(data_wave4[,c("falsesecurity2","falsesecurity2_5p")])

# Some variables must be rescaled (the ones measured on a 1 to 5 scale) for the factor analysis
data_wave4$Beliefs_technologyperformance_resc <- scales:::rescale(data_wave4$Beliefs_technologyperformance_5p, to = c(1, 7)) 
#View(data_wave4[,c("Beliefs_technologyperformance", "Beliefs_technologyperformance_resc")])
data_wave4$Beliefs_datasafety_resc <- scales:::rescale(data_wave4$Beliefs_datasafety_5p, to = c(1, 7)) 
#View(data_wave4[,c("Beliefs_datasafety", "Beliefs_datasafety_resc")])
data_wave4$Beliefs_Conspiracy1_resc <- scales:::rescale(data_wave4$Beliefs_Conspiracy1_5p, to = c(1, 7)) 
#View(data_wave4[,c("Beliefs_Conspiracy1", "Beliefs_Conspiracy1_resc")])
data_wave4$Beliefs_Conspiracy2_resc <- scales:::rescale(data_wave4$Beliefs_Conspiracy2_5p, to = c(1, 7)) 
#View(data_wave4[,c("Beliefs_Conspiracy2", "Beliefs_Conspiracy2_resc")])
data_wave4$Beliefs_locationmonitoring_resc <- scales:::rescale(data_wave4$Beliefs_locationmonitoring_5p, to = c(1, 7)) 
#View(data_wave4[,c("Beliefs_locationmonitoring", "Beliefs_locationmonitoring_resc")])
data_wave4$Beliefs_identitymonitoring_resc <- scales:::rescale(data_wave4$Beliefs_identitymonitoring_5p, to = c(1, 7)) 
#View(data_wave4[,c("Beliefs_identitymonitoring", "Beliefs_identitymonitoring_resc")])

# A factor analysis is performed to cluster the context-specific variables.
COVIDfactors <- data.frame(data_wave4[,c("HBM_PSus_other2", "HBM_PSev_other2", "Beliefs_fear", "Beliefs_notificationfear", "Beliefs_benefiteconomic", "Beliefs_civicduty", "Beliefs_TrustGovernment", "Beliefs_Protectriskgroups", "Beliefs_locationmonitoring_resc", "Beliefs_identitymonitoring_resc", "Beliefs_datasafety_resc", "Beliefs_Conspiracy1_resc", "Beliefs_Conspiracy2_resc", "Beliefs_technologyperformance_resc")])

#Remove rows with missing values and keep only complete cases
COVIDfactors2=COVIDfactors[complete.cases(COVIDfactors),]
#View(COVIDfactors)

#Decide the number of factors
ev <- eigen(cor(COVIDfactors2)) # get eigenvalues
print(ev)
ap <- parallel(subject=nrow(COVIDfactors2),var=ncol(COVIDfactors2), rep=100,cent=.05)
nS <- nScree(x=ev$values, aparallel=ap$eigen$qevpea)
plotnScree(nS)

#Factor analysis of the data
factors_COVID <- fa(r = COVIDfactors2, nfactors = 4, rotate="varimax")
#Getting the factor loadings and model analysis
factors_COVID

# New variables are created with the factors retrieved from the factor analysis.
data_wave4$Beliefs_society <- rowMeans(data_wave4[, c("Beliefs_benefiteconomic", "Beliefs_civicduty", "Beliefs_TrustGovernment", "Beliefs_Protectriskgroups", "Beliefs_datasafety_resc")], na.rm = TRUE)
cronbach(data_wave4[, c("Beliefs_benefiteconomic", "Beliefs_civicduty", "Beliefs_TrustGovernment", "Beliefs_Protectriskgroups", "Beliefs_datasafety_resc")])

data_wave4$Beliefs_monitoring <- rowMeans(data_wave4[, c("Beliefs_locationmonitoring_resc", "Beliefs_identitymonitoring_resc")], na.rm = TRUE)
cronbach(data_wave4[, c("Beliefs_locationmonitoring_resc", "Beliefs_identitymonitoring_resc")])
hist(data_wave4$Beliefs_monitoring)

data_wave4$Beliefs_conspiracy <- rowMeans(data_wave4[, c("Beliefs_Conspiracy1_resc", "Beliefs_Conspiracy2_resc")], na.rm = TRUE)
cronbach(data_wave4[, c("Beliefs_Conspiracy1_resc", "Beliefs_Conspiracy2_resc")])
hist(data_wave4$Beliefs_conspiracy) # heavily skewed to the right

data_wave4$Beliefs_fears <- rowMeans(data_wave4[, c("Beliefs_fear", "Beliefs_notificationfear")], na.rm = TRUE)
cronbach(data_wave4[, c("Beliefs_fear", "Beliefs_notificationfear")])
hist(data_wave4$Beliefs_fears) # also a bit skewed to the right

# From the factor analysis it appears that some variables do not belong to a factor. These variables will be dummy-coded and used in the analysis as dummies.
data_wave4$Beliefs_technologyperformance_dummy <- car::recode(data_wave4$Beliefs_technologyperformance, '99=0; 1=0; 2=0; 3=1; 4=1') #Value 0 = not true / don't know, value 1 = true that data is safe
#View(data_wave4[,c("Beliefs_technologyperformance","Beliefs_technologyperformance_dummy")])
data_wave4$HBM_PSusother_dummy <- car::recode(data_wave4$HBM_PSus_other2, '1=0; 2=0; 3=0; 4=0; 5=1; 6=1; 7=1') #Higher values represent higher susceptiblity
#View(data_wave4[,c("HBM_PSus_other2","HBM_PSusother_dummy")])
data_wave4$HBM_PSevother_dummy <- car::recode(data_wave4$HBM_PSev_other2, '1=0; 2=0; 3=0; 4=0; 5=1; 6=1; 7=1') #Higher values represent higher severity 
#View(data_wave4[,c("HBM_PSev_other2","Beliefs_PSevother_dummy")])

``` 

```{r NewvariablesAdherence, include = FALSE}

data_wave4_adherenceNS$AdherenceNS_w4 <- rowMeans(data_wave4_adherenceNS[, c("AdherenceNotificationMeasuresNosymptoms_Test", "AdherenceNotificationMeasuresNosymptoms_Quarantaine", "AdherenceNotificationMeasuresNoSymptoms_Visits")], na.rm = TRUE)
cronbach(data_wave4_adherenceNS[, c("AdherenceNotificationMeasuresNosymptoms_Test", "AdherenceNotificationMeasuresNosymptoms_Quarantaine", "AdherenceNotificationMeasuresNoSymptoms_Visits")])

data_wave4_adherenceS$AdherenceS_w4 <- rowMeans(data_wave4_adherenceS[, c("AdherenceNotificationMeasuresSymptoms_Test", "AdherenceNotificationMeasuresSymptoms_Quarantaine", "AdherenceNotificationMeasuresSymptoms_Visits")], na.rm = TRUE)
cronbach(data_wave4_adherenceS[, c("AdherenceNotificationMeasuresSymptoms_Test", "AdherenceNotificationMeasuresSymptoms_Quarantaine", "AdherenceNotificationMeasuresSymptoms_Visits")])

data_wave4_adherence$AdherenceSelfEfficacy_w4 <- rowMeans(data_wave4_adherence[, c("HBM_selfefficacy_Test", "HBM_selfefficacy_Quarantaine", "HBM_selfefficacy_Visits")], na.rm = TRUE)
cronbach(data_wave4_adherence[, c("HBM_selfefficacy_Test", "HBM_selfefficacy_Quarantaine", "HBM_selfefficacy_Visits")])

data_wave4_adherence$AdherenceBenefits_w4 <- rowMeans(data_wave4_adherence[, c("HBM_perceivedbenefits_Test", "HBM_perceivedbenefits_Quarantaine", "HBM_perceivedbenefits_Visits", "HBM_perceivedbenefits_GP")], na.rm = TRUE)
cronbach(data_wave4_adherence[, c("HBM_selfefficacy_Test", "HBM_selfefficacy_Quarantaine", "HBM_selfefficacy_Visits")])

data_wave4_adherence$AdherenceBarriers_w4 <- rowMeans(data_wave4_adherence[, c("HBM_barriers_Test", "HBM_barriers_Quarantaine", "HBM_barriers_Visits")], na.rm = TRUE)
cronbach(data_wave4_adherence[, c("HBM_barriers_Test", "HBM_barriers_Quarantaine", "HBM_barriers_Visits")])

```

```{r Histograms, include = FALSE}
# Based on the histogram the distribution is fairly normal.
data_wave4$PE_UTAUTx <- rowMeans(data_wave4[, c("PE1_UTAUT", "PE2_UTAUT")], na.rm = TRUE)
hist(data_wave4$PE_UTAUTx)

ggplot(data_wave4, aes(x=PE_UTAUTx, color=Behavior_UTAUT_r)) + geom_histogram()
# Based on the histogram the distribution is a bit skewed.
data_wave4$EE1_UTAUTx <- rowMeans(data_wave4[, c("EE1a_UTAUT_r","EE1b_UTAUT_r")], na.rm = TRUE)
data_wave4$EE2_UTAUTx <- rowMeans(data_wave4[, c("EE2a_UTAUT","EE2b_UTAUT")], na.rm = TRUE)
data_wave4$EE_UTAUTx <- rowMeans(data_wave4[, c("EE1_UTAUT", "EE2_UTAUT")], na.rm = TRUE)
hist(data_wave4$EE_UTAUTx)
# Based on the histogram the distribution seems to be highly centered around te mean (narrow distribution).
data_wave4$SI_UTAUTx <- rowMeans(data_wave4[, c("SI1_UTAUT", "SI2_UTAUT")], na.rm = TRUE)
hist(data_wave4$SI_UTAUTx)
# Based on the histogram the distribution is is strongly skewed.
data_wave4$FC_UTAUTx <- rowMeans(data_wave4[, c("FC1_UTAUT", "FC2_UTAUT")], na.rm = TRUE)
hist(data_wave4$FC_UTAUTx)
# Based on the histogram the distribution is very much skewed (positive skew).
data_wave4$Beliefs_falsesecurityx <- rowMeans(data_wave4[, c("Beliefs_falsesecurity1", "Beliefs_falsesecurity2")], na.rm = TRUE)
hist(data_wave4$Beliefs_falsesecurityx)
# Based on the histogram the distribution is very much skewed (positive skew).
data_wave4$Beliefs_Conspiracyx <- rowMeans(data_wave4[, c("Beliefs_Conspiracy1", "Beliefs_Conspiracy2")], na.rm = TRUE)
hist(data_wave4$Beliefs_Conspiracyx)
# Based on the histogram the distribution is normal.
data_wave4$Beliefs_monitoringx <- rowMeans(data_wave4[, c("Beliefs_locationmonitoring", "Beliefs_identitymonitoring", "Beliefs_datasafety_resc")], na.rm = TRUE)
hist(data_wave4$Beliefs_monitoringx)
# Based on the histogram the distribution is fairly normal.
data_wave4$HBM_PSus_selfx <- rowMeans(data_wave4[, c("HBM_PSus_self1", "HBM_PSus_self2")], na.rm = TRUE)
hist(data_wave4$HBM_PSus_selfx)
# Based on the histogram the distribution is quite skewed (heavy in the right tail).
data_wave4$HBM_PSev_selfx <- rowMeans(data_wave4[, c("HBM_PSev_self1", "HBM_PSev_self2")], na.rm = TRUE)
hist(data_wave4$HBM_PSev_selfx)

```

```{r RegressionUTAUT, include = FALSE}

UTAUT_w4 <- ' 
#Measurement model
PE_UTAUT =~ PE1_UTAUT + PE2_UTAUT 
SI_UTAUT =~ SI1_UTAUT + SI2_UTAUT
FC_UTAUT =~ FC1_UTAUT + FC2_UTAUT
EE_UTAUT =~ EE1_UTAUT + EE2_UTAUT

#Regression model
Behavior_UTAUT_r ~ PE_UTAUT + SI_UTAUT + FC_UTAUT + EE_UTAUT + Beliefs_voluntariness + lftdcat + geslacht

#Covariances between independent vars, see https://www.youtube.com/watch?v=n-ULF6BGVw0 
PE_UTAUT ~~ SI_UTAUT + FC_UTAUT + EE_UTAUT + Beliefs_voluntariness + lftdcat + geslacht
SI_UTAUT ~~ FC_UTAUT + EE_UTAUT + Beliefs_voluntariness + lftdcat + geslacht
FC_UTAUT ~~ EE_UTAUT + Beliefs_voluntariness + lftdcat + geslacht
EE_UTAUT ~~ Beliefs_voluntariness + lftdcat + geslacht
Beliefs_voluntariness ~~ lftdcat + geslacht
lftdcat ~~ geslacht'

fit_UTAUT1 <- sem(UTAUT_w4, data = data_wave4, ordered = TRUE, estimator = "WLSMV") #Ordered = TRUE tells us that all the endogenous variables are categorical. In this case, this is the Behavior_UTAUT var. 
summary(fit_UTAUT1, fit.measures = TRUE, standardized = TRUE, ci = TRUE)

#reliability(fit_UTAUT1) # PE_UTAUT: alpha = .93
                    # SI_UTAUT: alpha = .82
                    # FC_UTAUT: alpha = .80
                    # EE_UTAUT: alpha = .63
                    # PSus_HBM: alpha = .78
                    # PSev_HBM: alpha = .73
        

parameterestimates(fit_UTAUT1) #unstandardized parameters
standardizedsolution(fit_UTAUT1) #standardized parameters

# Create results table
w4_utaut <- standardizedsolution(fit_UTAUT1) %>% filter(lhs == 'Behavior_UTAUT_r' & op == '~') %>% select(rhs, est.std, pvalue)
names(w4_utaut)[names(w4_utaut) == "rhs"] <- "variable"
w4_utaut = join(w4_utaut, var_lookup)

# Reorder
w4_utaut <- w4_utaut[, c("variable", "vardesc", "est.std", "pvalue")]

# Assessing model fit. Ideally, Chi2 is non-significant, CFI is higher than .95, SRMR <.08, and RMSEA is acceptable below .08 (but good below <.05; with the lower bound not higher than .05 and the upper bound not higher than .10). When looking at the fit indices, the model already has a good fit: 
## X2 = 105.428
## CFI   = .999
## RMSEA = .044 (90% CI [.035, .054])
## SRMR  = .029
## R2 = .923
## However, the p-value of chi square is significant, but this could be due to the large N. 

# Statistics (sample means and covariance matrix)
inspect(fit_UTAUT1, "sampstat")

## Unstandardized model matrices
est_fit <- inspect(fit_UTAUT1, "est")
est_fit$lambda # unstandardised loadings
est_fit$psi # covariance matrix

## Standardized model matrices
std_fit <- inspect(fit_UTAUT1, "std")
std_fit$lambda # standardised loadings. All items load well on the latent factors, only EE1_UTAUT is doubtful (b=.54). So overall, convergent validity is ok. 
std_fit$psi # latent variable correlation matrix shows that latent variables are not very highly correlated (< .85), so we can speak of discriminant validity.

# Improve model (if needed, in this case I don't think it is)
# By correlation matrix. From this table, no problematic residual correlations were identified (should be <.1). Only perceived severity and EE have residual correlations exceeding this treshold. 
# resid(fit_UTAUT1, type ="cor")

## By looking at modification indices. 
# mod_ind <- modificationindices(fit_UTAUT1)
# head(mod_ind[order(mod_ind$mi, decreasing=TRUE), ], 10) ##You can order the modification indices. This argument gives you the first 10 highest correlations.

# Compare models
#fits <- list()
#fits$fit1 <- fit_UTAUT1
# Create a new model by adding an additional syntax to a model
#model2 <- paste0(model, "\n", "PE1_UTAUT ~~ FC1_UTAUT")
#fits$fit2 <- cfa(model2, data_wave4)
#round(sapply(fits, function(X) fitmeasures(X)), 3) all output --> in this case, the model was not improved by adding a correlation between PE1_UTAUT and FC1_UTAUT

#Plotting (just to get a vizualisation of whether the model is correct)
semPaths(fit_UTAUT1, "std")

#Print R squared
inspect(fit_UTAUT1, 'r2')
                 
```

```{r RegressionHBM, include = FALSE}

HBM_w4 <- ' 
#Measurement model

PSus_HBM =~ HBM_PSus_self1 + HBM_PSus_self2
PSev_HBM =~ HBM_PSev_self1 + HBM_PSev_self2

#Regression model
Behavior_UTAUT_r ~ PSus_HBM + PSev_HBM + HBM_selfefficacy_CoronaMelder + HBM_barriers_CoronaMelder + HBM_perceivedbenefits_CoronaMelder + lftdcat + geslacht + Media_dummy

#Covariances between independent vars, see https://www.youtube.com/watch?v=n-ULF6BGVw0 
PSus_HBM ~~ PSev_HBM + HBM_selfefficacy_CoronaMelder + HBM_barriers_CoronaMelder + HBM_perceivedbenefits_CoronaMelder + lftdcat + geslacht + Media_dummy
PSev_HBM ~~ HBM_selfefficacy_CoronaMelder + HBM_barriers_CoronaMelder + HBM_perceivedbenefits_CoronaMelder + lftdcat + geslacht + Media_dummy
HBM_selfefficacy_CoronaMelder ~~ HBM_barriers_CoronaMelder + HBM_perceivedbenefits_CoronaMelder + lftdcat + geslacht + Media_dummy
HBM_barriers_CoronaMelder ~~ HBM_perceivedbenefits_CoronaMelder + lftdcat + geslacht + Media_dummy
HBM_perceivedbenefits_CoronaMelder ~~ lftdcat + geslacht + Media_dummy
lftdcat ~~ geslacht + Media_dummy
geslacht ~~ Media_dummy'

fit_HBM1 <- sem(HBM_w4, data = data_wave4, ordered = TRUE, estimator = "WLSMV") #Ordered = TRUE tells us that all the endogenous variables are categorical. #In this case, this is the Behavior_UTAUT var. 
summary(fit_HBM1, fit.measures = TRUE, standardized = TRUE, ci = TRUE)

# RESPECIFICATION. Assessing model fit. Ideally, Chi2 is non-significant, CFI is higher than .95, SRMR <.08, and RMSEA is acceptable below .08 (but good below <.05; with the lower bound not higher than .05 and the upper bound not higher than .10). When looking at the fit indices, model fit is good: 
## Chi square = 71.648
## CFI   = .993
## RMSEA = .054 (90% CI [.042, .067])
## SRMR  = .069
## R2 = .487
## The chi square is significant, but this could be due to the large N. 

## Standardized model matrices
std_fit <- inspect(fit_HBM1, "std")
std_fit$lambda # standardised loadings. All items load well on the latent factors: convergent validity is good. 
std_fit$psi # latent variable correlation matrix shows that latent variables are not very highly correlated (< .85), so we can speak of discriminant validity.

# Create results table
w4_hbm <- standardizedsolution(fit_HBM1) %>% filter(lhs == 'Behavior_UTAUT_r' & op == '~') %>% select(rhs, est.std, pvalue)
names(w4_hbm)[names(w4_hbm) == "rhs"] <- "variable"
w4_hbm = join(w4_hbm, var_lookup)

# Reorder
w4_hbm <- w4_hbm[, c("variable", "vardesc", "est.std", "pvalue")]

#Print R squared
inspect(fit_HBM1, 'r2')

```
   
    
     
  
```{r LogisticRegressionContext, include = FALSE}
#Test of multicollinearity (VIF should not be >5)
lm <- lm(Behavior_UTAUT_r ~ Beliefs_society + Beliefs_fears + Beliefs_monitoring + Beliefs_conspiracy + HBM_PSus_other2 + HBM_PSev_other2 + Beliefs_technologyperformance_5p + lftdcat + geslacht, data = data_wave4)

car::vif(lm)

#Logistic regression
mylogit <- glm(Behavior_UTAUT_r ~ Beliefs_society + Beliefs_fears + Beliefs_monitoring + Beliefs_conspiracy + HBM_PSus_other2 + HBM_PSev_other2 + Beliefs_technologyperformance_5p + lftdcat + geslacht, data = data_wave4, family=binomial)

summary(mylogit)
PseudoR2(mylogit)
confint(mylogit)
nobs(mylogit)

## Pseudo R2 = .295
## AIC = 1172.5

#Odds ratios and 95% CIs
exp(cbind(OR = coef(mylogit), confint(mylogit)))


#Correlation table
#df <- data_wave4[,c("HBM_PSus_other2", "HBM_PSev_other2", "Beliefs_fears", "Beliefs_monitoring", "Beliefs_society", "Beliefs_conspiracy", "Beliefs_technologyperformance_5p", "lftdcat", "geslacht")]

#cortable <- round(cor(na.omit(df), method = "pearson"),2)
#print(cortable)

#upper<-cortable
#upper[upper.tri(cortable)]<-""
#upper<-as.data.frame(upper)
#upper

# Create results table
w1_covid <- data.frame(estimates = coef(summary(mylogit))[-1,'Estimate'], pvalue = coef(summary(mylogit))[-1,'Pr(>|z|)'])
setDT(w1_covid, keep.rownames = "variable")[]
w1_covid = join(w1_covid, var_lookup)

# Reorder
w1_covid <- w1_covid[, c("variable", "vardesc", "estimates", "pvalue")]

```
   
   
   
```{r RegressionAdherenceNosymptoms, include = FALSE}

AdhNS_w4 <- ' 
#Measurement model

Adherence_Selfefficacy =~ HBM_selfefficacy_Test + HBM_selfefficacy_Quarantaine + HBM_selfefficacy_Visits
Adherence_Benefits =~ HBM_perceivedbenefits_Test + HBM_perceivedbenefits_Quarantaine + HBM_perceivedbenefits_Visits
Adherence_Barriers =~ HBM_barriers_Test + HBM_barriers_Quarantaine + HBM_barriers_Visits
PSus_HBM =~ aa*HBM_PSus_self1 + aa*HBM_PSus_self2
PSev_HBM =~ HBM_PSev_self1 + HBM_PSev_self2

#Regression model
AdherenceNS_w4 ~ Adherence_Selfefficacy + Adherence_Benefits + Adherence_Barriers + PSus_HBM + PSev_HBM + lftdcat + geslacht

#Covariances between independent vars, see https://www.youtube.com/watch?v=n-ULF6BGVw0 
Adherence_Selfefficacy ~~ Adherence_Benefits + Adherence_Barriers + PSus_HBM + PSev_HBM + lftdcat + geslacht
Adherence_Benefits ~~ Adherence_Barriers + PSus_HBM + PSev_HBM + lftdcat + geslacht
Adherence_Barriers ~~ PSus_HBM + PSev_HBM + lftdcat + geslacht
PSus_HBM ~~ PSev_HBM + lftdcat + geslacht
PSev_HBM ~~ lftdcat + geslacht
lftdcat ~~ geslacht'

fitadhNS_w4 <- sem(AdhNS_w4, data = data_wave4_adherenceNS, estimator = "MLM") #Ordered = TRUE tells us that all the endogenous variables are categorical. #In this case, this is the Behavior_UTAUT var. 
summary(fitadhNS_w4, fit.measures = TRUE, standardized = TRUE, ci = TRUE)

# RESPECIFICATION. Assessing model fit. Ideally, Chi2 is non-significant, CFI is higher than .95, SRMR <.08, and RMSEA is acceptable below .08 (but good below <.05; with the lower bound not higher than .05 and the upper bound not higher than .10). When looking at the fit indices, model fit is acceptable: 
## Chisquare = 303.967
## CFI   = .934
## RMSEA = .080 (90% CI [.071, .090])
## SRMR  = .052
## The chi square is significant, but this could be due to the large N. 

# Improve model (In this case I think it is neeeded due to the high CFI and RMSEA)
## By looking at modification indices. 
mod_ind <- modificationindices(fitadhNS_w4)
head(mod_ind[order(mod_ind$mi, decreasing=TRUE), ], 10) ##You can order the modification indices. This argument gives you the first 10 highest correlations.

# Compare models --> we improve the model the same way as the symptoms model
fits <- list()
fits$fit1 <- fitadhNS_w4
# Create a new model by adding an additional syntax to a model
AdhNS1_w4 <- paste0(AdhNS_w4, "\n", "HBM_barriers_Test ~~ HBM_perceivedbenefits_Test")
fits$fit2 <- sem(AdhNS1_w4, data_wave4_adherenceNS)
round(sapply(fits, function(X) fitmeasures(X, c("chisq", "df", "cfi", "rmsea", "srmr"))), 2) 
# Model fit is good when a correlation is added between perceived benefits and perceived barriers of testing. This is the only correlation added

## Chi squared = 250.507
## CFI   = .949
## RMSEA = .071 (90% CI [.061, .081])
## SRMR  = .052
## R2 = .084
## The chi square is significant, but this could be due to the large N. 
summary(fits$fit2, fit.measures = TRUE, standardized = TRUE, ci = TRUE, rsquare = TRUE)

semPaths(fits$fit2, "std")



# Create results table
w4ns_adh <- standardizedsolution(fits$fit2) %>% filter(lhs == "AdherenceNS_w4" & op == '~') %>% select(rhs, est.std, pvalue)
names(w4ns_adh)[names(w4ns_adh) == "rhs"] <- "variable"
w4ns_adh = join(w4ns_adh, var_lookup)

# Reorder
w4ns_adh <- w4ns_adh[, c("variable", "vardesc", "est.std", "pvalue")]

```
  
  
  
```{r RegressionAdherenceSymptoms, include = FALSE}

AdhS_w4 <- ' 
#Measurement model

Adherence_Selfefficacy =~ HBM_selfefficacy_Test + HBM_selfefficacy_Quarantaine + HBM_selfefficacy_Visits
Adherence_Benefits =~ HBM_perceivedbenefits_Test + HBM_perceivedbenefits_Quarantaine + HBM_perceivedbenefits_Visits
Adherence_Barriers =~ HBM_barriers_Test + HBM_barriers_Quarantaine + HBM_barriers_Visits
PSus_HBM =~ aa*HBM_PSus_self1 + aa*HBM_PSus_self2
PSev_HBM =~ HBM_PSev_self1 + HBM_PSev_self2

#Regression model
AdherenceS_w4 ~ Adherence_Selfefficacy + Adherence_Benefits + Adherence_Barriers + PSus_HBM + PSev_HBM + lftdcat + geslacht

#Covariances between independent vars, see https://www.youtube.com/watch?v=n-ULF6BGVw0 
Adherence_Selfefficacy ~~ Adherence_Benefits + Adherence_Barriers + PSus_HBM + PSev_HBM + lftdcat + geslacht
Adherence_Benefits ~~ Adherence_Barriers + PSus_HBM + PSev_HBM + lftdcat + geslacht
Adherence_Barriers ~~ PSus_HBM + PSev_HBM + lftdcat + geslacht
PSus_HBM ~~ PSev_HBM + lftdcat + geslacht
PSev_HBM ~~ lftdcat + geslacht
lftdcat ~~ geslacht'

fitadhS_w4 <- sem(AdhS_w4, data = data_wave4_adherenceS, estimator = "MLM") #Ordered = TRUE tells us that all the endogenous variables are categorical. #In this case, this is the Behavior_UTAUT var. 
summary(fitadhS_w4, fit.measures = TRUE, standardized = TRUE, ci = TRUE)


# RESPECIFICATION. Assessing model fit. Ideally, Chi2 is non-significant, CFI is higher than .95, SRMR <.08, and RMSEA is acceptable below .08 (but good below <.05; with the lower bound not higher than .05 and the upper bound not higher than .10). When looking at the fit indices, model fit is acceptable: 
## CFI   = .935
## RMSEA = .080 (90% CI [.071, .090])
## SRMR  = .053
## The chi square is significant, but this could be due to the large N. 

# Improve model (In this case I think it is neeeded due to the high CFI and RMSEA)
## By looking at modification indices. 
mod_ind <- modificationindices(fitadhS_w4)
head(mod_ind[order(mod_ind$mi, decreasing=TRUE), ], 10) ##You can order the modification indices. This argument gives you the first 10 highest correlations.

# Compare models --> we improve the model the same way as the no-symptoms model
fits <- list()
fits$fit1 <- fitadhS_w4
# Create a new model by adding an additional syntax to a model
AdhS1_w4 <- paste0(AdhS_w4, "\n", "HBM_barriers_Test ~~ HBM_perceivedbenefits_Test")
fits$fit2 <- sem(AdhS1_w4, data_wave4_adherenceS)
round(sapply(fits, function(X) fitmeasures(X, c("chisq", "df", "cfi", "rmsea", "srmr"))), 2) 
# Model fit is good when a correlation is added between perceived benefits and perceived barriers of testing. This is the only correlation added

## Chi squared = 250.609
## CFI   = .950
## RMSEA = .071 (90% CI [.061, .081])
## SRMR  = .052
## R2 = .204
## The chi square is significant, but this could be due to the large N. 
summary(fits$fit2, fit.measures = TRUE, standardized = TRUE, ci = TRUE, rsquare = TRUE)


# Create results table
w4s_adh <- standardizedsolution(fits$fit2) %>% filter(lhs == "AdherenceS_w4" & op == '~') %>% select(rhs, est.std, pvalue)
names(w4s_adh)[names(w4s_adh) == "rhs"] <- "variable"
w4s_adh = join(w4s_adh, var_lookup)

# Reorder
w4s_adh <- w4s_adh[, c("variable", "vardesc", "est.std", "pvalue")]

```
    
    
    
```{r echo = FALSE, tab.cap="UTAUT met adoptie als afhankelijke variabele"}
data_table <- w4_utaut[,-1]
# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = list("vardesc" = "Variabele", "est.std" = "β", "pvalue" = "p"))

# Round numbers
ft <- colformat_num(x = ft, j = -1, big.mark = ".", decimal.mark = ",", digits = 3)

# Change layout of table
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "center", part = "all")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining space.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 4.5

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 2)
ft_out <- width(ft_out, j = -1, width = (table_width-2)/(length(colnames(data_table))-1))

ft_out

```
   
    
    
```{r echo = FALSE, tab.cap="Health Belief Model met adoptie als afhankelijke variabele"}
data_table <- w4_hbm[,-1]
# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = list("vardesc" = "Variabele", "est.std" = "β", "pvalue" = "p"))

# Round numbers
ft <- colformat_num(x = ft, j = -1, big.mark = ".", decimal.mark = ",", digits = 3)

# Change layout of table
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "center", part = "all")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining space.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 4.5

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 2)
ft_out <- width(ft_out, j = -1, width = (table_width-2)/(length(colnames(data_table))-1))

ft_out
```
   
   
   
```{r echo = FALSE, tab.cap="Predictiemodel context-gerelateerde variabelen op adoptie"}
data_table <- w1_covid[,-1]
# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = list("vardesc" = "Variabele", "estimates" = "β", "pvalue" = "p"))

# Round numbers
ft <- colformat_num(x = ft, j = -1, big.mark = ".", decimal.mark = ",", digits = 3)

# Change layout of table
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "center", part = "all")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining space.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 4.5

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 2)
ft_out <- width(ft_out, j = -1, width = (table_width-2)/(length(colnames(data_table))-1))

ft_out
```
   
    
     
```{r echo = FALSE, tab.cap="Predictiemodel naleving gedragsmaatregelen, met symptomen"}
data_table <- w4s_adh[,-1]
# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = list("vardesc" = "Variabele", "est.std" = "β", "pvalue" = "p"))

# Round numbers
ft <- colformat_num(x = ft, j = -1, big.mark = ".", decimal.mark = ",", digits = 3)

# Change layout of table
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "center", part = "all")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining space.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 4.5

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 2)
ft_out <- width(ft_out, j = -1, width = (table_width-2)/(length(colnames(data_table))-1))

ft_out
```
     
       
        
```{r echo = FALSE, tab.cap="Predictiemodel naleving gedragsmaatregelen, zonder symptomen"}
data_table <- w4ns_adh[,-1]
# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = list("vardesc" = "Variabele", "est.std" = "β", "pvalue" = "p"))

# Round numbers
ft <- colformat_num(x = ft, j = -1, big.mark = ".", decimal.mark = ",", digits = 3)

# Change layout of table
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "center", part = "all")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining space.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 4.5

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 2)
ft_out <- width(ft_out, j = -1, width = (table_width-2)/(length(colnames(data_table))-1))

ft_out
```
    
    
## Tabellen model fit

```{r ModelfitSEM, echo = FALSE, tab.cap ="Model fit van de Structural Equation Models"}

#Model fit SEMS
dftab <- data.frame(Model = c("UTAUT", "HBM", "Naleving van de maatregelen (zonder symptomen)", "Naleving van de maatregelen (met symptomen)"), 'Chi-Squared' = c('105.428', '71.648', '250.507', '250.609'), CFI = c('.999', '.993', '.949', '.950'), RMSEA = c('.044', '.054', '.071', '.071'), '90percent CI' = c('[.035, .054]', '[.042, .067]', '[.061, .081]', '[.061, .081]'), SRMR = c('.029', '.069', '.052', '.052'), 'R-squared' = c('.923', '.487', '.084', '.204'), check.names = FALSE)



# Build the basic table
ft <- flextable(
  head(dftab, n = nrow(dftab))
)


# Change layout of table
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "center", part = "all")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining space.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 3.5

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 2)
ft_out <- width(ft_out, j = -1, width = (table_width-2)/(length(colnames(data_table))-1))

ft_out

```
   
    
     
```{r ModelfitLogReg, echo = FALSE, tab.cap="Model fit van de logistische regressie"}

#Model fit Log reg
dftab <- data.frame(Model = c("Context-gerelateerde variabelen"), 'Pseudo R-squared' = c('.295'), 'AIC' = c('1172.5'), check.names = FALSE)


# Build the basic table
ft <- flextable(
  head(dftab, n = nrow(dftab))
)


# Change layout of table
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "center", part = "all")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining space.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 4.5

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 2)
ft_out <- width(ft_out, j = -1, width = (table_width-2)/(length(colnames(data_table))-1))

ft_out

```

# Bijlagen
Als bijlage kunt u bij dit rapport vinden:  
- Vragenlijst wave 4  
- Vergelijking demografie sample huidig onderzoek, LISS core panel en CBS  

